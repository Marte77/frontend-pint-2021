'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var d3Selection = require('d3-selection');
var parser = _interopDefault(require('ua-parser-js'));
var d3Shape = require('d3-shape');
var d3TimeFormat = require('d3-time-format');
var d3Transition = require('d3-transition');
var d3Scale = require('d3-scale');
var d3Color = require('d3-color');
var d3Ease = require('d3-ease');
var d3Axis = require('d3-axis');
var d3Dispatch = require('d3-dispatch');
var d3Drag = require('d3-drag');
var d3Interpolate = require('d3-interpolate');
var d3Array = require('d3-array');
var d3Path = require('d3-path');
var d3Collection = require('d3-collection');
var d3Timer = require('d3-timer');
var yup = require('yup');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var ua = parser(window.navigator.userAgent);
var getBrowser = function () {
    return ua.browser.name;
};
var getOS = function () {
    return ua.os.name;
};

/**
 * Copyright (c) 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var browser = getBrowser();
var isIE11 = browser === 'IE'; // ua.includes('rv:11.0');
var isIEEdge = browser === 'Edge'; // ua.includes('Edge');
var isSafari = browser === 'Safari';
var initializeElementAccess = function (node) {
    d3Selection.select(node)
        .attr('tabindex', -1)
        .attr('role', 'presentation')
        .attr('focusable', false);
};
var hideNonessentialGroups = function (rootNode, exception) {
    var childrenG = rootNode.childNodes.length > 1 ? rootNode.childNodes : rootNode.firstElementChild.childNodes;
    if (childrenG) {
        d3Selection.selectAll(childrenG).each(function (_, i, n) {
            if (!(n[i] === exception)) {
                hideNode(n[i]);
            }
        });
    }
};
var setTooltipAccess = function (el) {
    el.setAttribute('role', 'tooltip'); // AT tooltip
    el.setAttribute('aria-hidden', 'true');
    el.setAttribute('tabindex', null);
};
var setLegendAccess = function (root, id) {
    hideNode(root);
    hideNode(root.parentNode, true);
    d3Selection.select(root).classed('vcl-svg', true);
    if (isIE11 || isIEEdge) {
        handleContrast(null, id);
    }
};
var hideNode = function (node, excludeFocusable) {
    d3Selection.select(node)
        .attr('aria-hidden', 'true')
        .attr('role', 'presentation')
        .attr('focusable', !excludeFocusable ? 'false' : null)
        .attr('tabindex', null);
};
var createUrl = function (id) {
    var path = window.location.pathname;
    if (path[path.length - 1] === '/') {
        path = path.substring(0, path.length - 1);
    }
    var ending = id ? id + ')' : '';
    return (!isSafari ? 'url(#' : 'url(' + window.location.protocol + '//' + window.location.host + path + '#') + ending;
};
var setHighContrastListener = function (root, id) {
    d3Selection.select(root).classed('vcl-svg', true);
    var filter = d3Selection.select(root).select('.vcl-inversion-filter');
    if (!filter.size()) {
        var defs = d3Selection.select(root).select('defs');
        if (!defs.size()) {
            defs = d3Selection.select(root).append('defs');
        }
        filter = defs
            .append('filter')
            .attr('class', 'vcl-inversion-filter')
            .attr('color-interpolation-filters', 'sRGB');
        // this operation will "invert" every color: dark blue becomes light orange,
        // pink becomes dark green, etc. This ensures the new luminance is fully inverted
        filter
            .append('feColorMatrix')
            .attr('in', 'SourceGraphic')
            .attr('type', 'matrix')
            .attr('values', "-1 0 0 0 1 \n        0 -1 0 0 1 \n        0 0 -1 0 1\n        0 0 0 1 0");
        // once luminance is inverted, we can rotate the hue back to its original
        // this means that the dark blue is now a light blue instead of light orange
        filter
            .append('feColorMatrix')
            .attr('type', 'hueRotate')
            .attr('values', '180');
    }
    filter.attr('id', 'inversion-' + id);
    var passMediaEventToHandler = function (a) {
        handleContrast(a, id);
    };
    var runContrastHandler = function () {
        handleContrast(null, id);
    };
    if (isIE11 || isIEEdge) {
        // here we are listening to contrast mode being turned on or off as well as
        // listening to the contrast modes being switched between types
        matchMedia('(-ms-high-contrast: active)').addListener(passMediaEventToHandler);
        matchMedia('(-ms-high-contrast: black-on-white)').addListener(runContrastHandler);
        passMediaEventToHandler(matchMedia('(-ms-high-contrast: active)'));
    }
};
var handleContrast = function (a, id) {
    var contrastStatus = a || matchMedia('(-ms-high-contrast: active)');
    if (contrastStatus.matches && !matchMedia('(-ms-high-contrast: black-on-white)').matches) {
        var url = createUrl('inversion-' + id);
        // we will always structure our SVG elements to have a single g that contains
        // all of our elements, so we only need to select the first g element for
        // every SVG within our component space (legend, chart, etc)
        d3Selection.select('#' + id)
            .selectAll('.vcl-svg')
            .select('g')
            .attr('filter', url);
    }
    else {
        d3Selection.select('#' + id)
            .selectAll('.vcl-svg')
            .select('g')
            .attr('filter', null);
    }
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
/************************************
    Variables
************************************/
var numeral, _, VERSION = '2.0.6', formats = {}, locales = {}, defaults = {
    currentLocale: 'en',
    zeroFormat: null,
    nullFormat: null,
    defaultFormat: '0,0',
    scalePercentBy100: true
}, options = {
    currentLocale: defaults.currentLocale,
    zeroFormat: defaults.zeroFormat,
    nullFormat: defaults.nullFormat,
    defaultFormat: defaults.defaultFormat,
    scalePercentBy100: defaults.scalePercentBy100
};
/************************************
    Constructors
************************************/
// Numeral prototype object
function Numeral(input, number) {
    this._input = input;
    this._value = number;
}
numeral = function (input) {
    var value, kind, unformatFunction, regexp;
    if (numeral.isNumeral(input)) {
        value = input.value();
    }
    else if (input === 0 || typeof input === 'undefined') {
        value = 0;
    }
    else if (input === null || _.isNaN(input)) {
        value = null;
    }
    else if (typeof input === 'string') {
        if (options.zeroFormat && input === options.zeroFormat) {
            value = 0;
        }
        else if ((options.nullFormat && input === options.nullFormat) || !input.replace(/[^0-9]+/g, '').length) {
            value = null;
        }
        else {
            for (kind in formats) {
                regexp =
                    typeof formats[kind].regexps.unformat === 'function'
                        ? formats[kind].regexps.unformat()
                        : formats[kind].regexps.unformat;
                if (regexp && input.match(regexp)) {
                    unformatFunction = formats[kind].unformat;
                    break;
                }
            }
            unformatFunction = unformatFunction || numeral._.stringToNumber;
            value = unformatFunction(input);
        }
    }
    else {
        value = Number(input) || null;
    }
    return new Numeral(input, value);
};
// version number
numeral.version = VERSION;
// compare numeral object
numeral.isNumeral = function (obj) {
    return obj instanceof Numeral;
};
// helper functions
numeral._ = _ = {
    // formats numbers separators, decimals places, signs, abbreviations
    numberToFormat: function (value, format, roundingFunction) {
        var locale = locales[numeral.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = '', trillion = 1000000000000, billion = 1000000000, million = 1000000, thousand = 1000, decimal = '', neg = false, abbrForce, // force abbreviation
        abs, int, precision, signed, thousands, output;
        // make sure we never format a null value
        value = value || 0;
        abs = Math.abs(value);
        // see if we should use parentheses for negative number or if we should prefix with a sign
        // if both are present we default to parentheses
        if (numeral._.includes(format, '(')) {
            negP = true;
            format = format.replace(/[\(|\)]/g, '');
        }
        else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
            signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
            format = format.replace(/[\+|\-]/g, '');
        }
        // see if abbreviation is wanted
        if (numeral._.includes(format, 'a')) {
            abbrForce = format.match(/a(k|m|b|t)?/);
            abbrForce = abbrForce ? abbrForce[1] : false;
            // check for space before abbreviation
            if (numeral._.includes(format, ' a')) {
                abbr = ' ';
            }
            format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');
            if ((abs >= trillion && !abbrForce) || abbrForce === 't') {
                // trillion
                abbr += locale.abbreviations.trillion;
                value = value / trillion;
            }
            else if ((abs < trillion && abs >= billion && !abbrForce) || abbrForce === 'b') {
                // billion
                abbr += locale.abbreviations.billion;
                value = value / billion;
            }
            else if ((abs < billion && abs >= million && !abbrForce) || abbrForce === 'm') {
                // million
                abbr += locale.abbreviations.million;
                value = value / million;
            }
            else if ((abs < million && abs >= thousand && !abbrForce) || abbrForce === 'k') {
                // thousand
                abbr += locale.abbreviations.thousand;
                value = value / thousand;
            }
        }
        // check for optional decimals
        if (numeral._.includes(format, '[.]')) {
            optDec = true;
            format = format.replace('[.]', '.');
        }
        // break number and format
        int = value.toString().split('.')[0];
        precision = format.split('.')[1];
        thousands = format.indexOf(',');
        leadingCount = (format
            .split('.')[0]
            .split(',')[0]
            .match(/0/g) || []).length;
        if (precision) {
            if (numeral._.includes(precision, '[')) {
                precision = precision.replace(']', '');
                precision = precision.split('[');
                decimal = numeral._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            }
            else {
                decimal = numeral._.toFixed(value, precision.length, roundingFunction);
            }
            int = decimal.split('.')[0];
            if (numeral._.includes(decimal, '.')) {
                decimal = locale.delimiters.decimal + decimal.split('.')[1];
            }
            else {
                decimal = '';
            }
            if (optDec && Number(decimal.slice(1)) === 0) {
                decimal = '';
            }
        }
        else {
            int = numeral._.toFixed(value, 0, roundingFunction);
        }
        // check abbreviation again after rounding
        if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
            int = String(Number(int) / 1000);
            switch (abbr) {
                case locale.abbreviations.thousand:
                    abbr = locale.abbreviations.million;
                    break;
                case locale.abbreviations.million:
                    abbr = locale.abbreviations.billion;
                    break;
                case locale.abbreviations.billion:
                    abbr = locale.abbreviations.trillion;
                    break;
            }
        }
        // format number
        if (numeral._.includes(int, '-')) {
            int = int.slice(1);
            neg = true;
        }
        if (int.length < leadingCount) {
            for (var i = leadingCount - int.length; i > 0; i--) {
                int = '0' + int;
            }
        }
        if (thousands > -1) {
            int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
        }
        if (format.indexOf('.') === 0) {
            int = '';
        }
        output = int + decimal + (abbr ? abbr : '');
        if (negP) {
            output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
        }
        else {
            if (signed >= 0) {
                output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
            }
            else if (neg) {
                output = '-' + output;
            }
        }
        return output;
    },
    // unformats numbers separators, decimals places, signs, abbreviations
    stringToNumber: function (string) {
        var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
        }, abbreviation, value, regexp;
        if (options.zeroFormat && string === options.zeroFormat) {
            value = 0;
        }
        else if ((options.nullFormat && string === options.nullFormat) || !string.replace(/[^0-9]+/g, '').length) {
            value = null;
        }
        else {
            value = 1;
            if (locale.delimiters.decimal !== '.') {
                string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
            }
            for (abbreviation in abbreviations) {
                regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');
                if (stringOriginal.match(regexp)) {
                    value *= Math.pow(10, abbreviations[abbreviation]);
                    break;
                }
            }
            // check for negative number
            value *=
                (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;
            // remove non numbers
            string = string.replace(/[^0-9\.]+/g, '');
            value *= Number(string);
        }
        return value;
    },
    isNaN: function (value) {
        return typeof value === 'number' && isNaN(value);
    },
    includes: function (string, search) {
        return string.indexOf(search) !== -1;
    },
    insert: function (string, subString, start) {
        return string.slice(0, start) + subString + string.slice(start);
    },
    reduce: function (array, callback /*, initialValue*/) {
        if (this === null) {
            throw new TypeError('Array.prototype.reduce called on null or undefined');
        }
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        var t = Object(array), len = t.length >>> 0, k = 0, value;
        if (arguments.length === 3) {
            value = arguments[2];
        }
        else {
            while (k < len && !(k in t)) {
                k++;
            }
            if (k >= len) {
                throw new TypeError('Reduce of empty array with no initial value');
            }
            value = t[k++];
        }
        for (; k < len; k++) {
            if (k in t) {
                value = callback(value, t[k], k, t);
            }
        }
        return value;
    },
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    multiplier: function (x) {
        var parts = x.toString().split('.');
        return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
    },
    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    correctionFactor: function () {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (accum, next) {
            var mn = _.multiplier(next);
            return accum > mn ? accum : mn;
        }, 1);
    },
    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    toFixed: function (value, maxDecimals, roundingFunction, optionals) {
        var splitValue = value.toString().split('.'), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
        // Use the smallest precision value possible to avoid errors from floating point representation
        if (splitValue.length === 2) {
            boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
        }
        else {
            boundedPrecision = minDecimals;
        }
        power = Math.pow(10, boundedPrecision);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);
        if (optionals > maxDecimals - boundedPrecision) {
            optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
            output = output.replace(optionalsRegExp, '');
        }
        return output;
    }
};
// avaliable options
numeral.options = options;
// avaliable formats
numeral.formats = formats;
// avaliable formats
numeral.locales = locales;
// This function sets the current locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
numeral.locale = function (key) {
    if (key) {
        options.currentLocale = key.toLowerCase();
    }
    return options.currentLocale;
};
// This function provides access to the loaded locale data.  If
// no arguments are passed in, it will simply return the current
// global locale object.
numeral.localeData = function (key) {
    if (!key) {
        return locales[options.currentLocale];
    }
    key = key.toLowerCase();
    if (!locales[key]) {
        throw new Error('Unknown locale : ' + key);
    }
    return locales[key];
};
numeral.reset = function () {
    for (var property in defaults) {
        options[property] = defaults[property];
    }
};
numeral.zeroFormat = function (format) {
    options.zeroFormat = typeof format === 'string' ? format : null;
};
numeral.nullFormat = function (format) {
    options.nullFormat = typeof format === 'string' ? format : null;
};
numeral.defaultFormat = function (format) {
    options.defaultFormat = typeof format === 'string' ? format : '0.0';
};
numeral.register = function (type, name, format) {
    name = name.toLowerCase();
    if (this[type + 's'][name]) {
        throw new TypeError(name + ' ' + type + ' already registered.');
    }
    this[type + 's'][name] = format;
    return format;
};
numeral.validate = function (val, culture) {
    var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
    //coerce val to string
    if (typeof val !== 'string') {
        val += '';
        if (console.warn) {
            console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
        }
    }
    //trim whitespaces from either sides
    val = val.trim();
    //if val is just digits return true
    if (!!val.match(/^\d+$/)) {
        return true;
    }
    //if val is empty return false
    if (val === '') {
        return false;
    }
    //get the decimal and thousands separator from numeral.localeData
    try {
        //check if the culture is understood by numeral. if not, default it to current locale
        localeData = numeral.localeData(culture);
    }
    catch (e) {
        localeData = numeral.localeData(numeral.locale());
    }
    //setup the delimiters and currency symbol based on culture/locale
    _currSymbol = localeData.currency.symbol;
    _abbrObj = localeData.abbreviations;
    _decimalSep = localeData.delimiters.decimal;
    if (localeData.delimiters.thousands === '.') {
        _thousandSep = '\\.';
    }
    else {
        _thousandSep = localeData.delimiters.thousands;
    }
    // validating currency symbol
    temp = val.match(/^[^\d]+/);
    if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
            return false;
        }
    }
    //validating abbreviation symbol
    temp = val.match(/[^\d]+$/);
    if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand &&
            temp[0] !== _abbrObj.million &&
            temp[0] !== _abbrObj.billion &&
            temp[0] !== _abbrObj.trillion) {
            return false;
        }
    }
    _thousandRegEx = new RegExp(_thousandSep + '{2}');
    if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length > 2) {
            return false;
        }
        else {
            if (_valArray.length < 2) {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            }
            else {
                if (_valArray[0].length === 1) {
                    return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                }
                else {
                    return (!!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/));
                }
            }
        }
    }
    return false;
};
/************************************
    Numeral Prototype
************************************/
numeral.fn = Numeral.prototype = {
    clone: function () {
        return numeral(this);
    },
    format: function (inputString, roundingFunction) {
        var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;
        // make sure we have a roundingFunction
        roundingFunction = roundingFunction || Math.round;
        // format based on value
        if (value === 0 && options.zeroFormat !== null) {
            output = options.zeroFormat;
        }
        else if (value === null && options.nullFormat !== null) {
            output = options.nullFormat;
        }
        else {
            for (kind in formats) {
                if (format.match(formats[kind].regexps.format)) {
                    formatFunction = formats[kind].format;
                    break;
                }
            }
            formatFunction = formatFunction || numeral._.numberToFormat;
            output = formatFunction(value, format, roundingFunction);
        }
        return output;
    },
    value: function () {
        return this._value;
    },
    input: function () {
        return this._input;
    },
    set: function (value) {
        this._value = Number(value);
        return this;
    },
    add: function (value) {
        var corrFactor = _.correctionFactor.call(null, this._value, value);
        function cback(accum, curr, currI, O) {
            return accum + Math.round(corrFactor * curr);
        }
        this._value = _.reduce([this._value, value], cback, 0) / corrFactor;
        return this;
    },
    subtract: function (value) {
        var corrFactor = _.correctionFactor.call(null, this._value, value);
        function cback(accum, curr, currI, O) {
            return accum - Math.round(corrFactor * curr);
        }
        this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
        return this;
    },
    multiply: function (value) {
        function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);
            return (Math.round(accum * corrFactor) * Math.round(curr * corrFactor)) / Math.round(corrFactor * corrFactor);
        }
        this._value = _.reduce([this._value, value], cback, 1);
        return this;
    },
    divide: function (value) {
        function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
        }
        this._value = _.reduce([this._value, value], cback);
        return this;
    },
    difference: function (value) {
        return Math.abs(numeral(this._value)
            .subtract(value)
            .value());
    }
};
/************************************
    Default Locale && Format
************************************/
numeral.register('locale', 'en', {
    delimiters: {
        thousands: ',',
        decimal: '.'
    },
    abbreviations: {
        thousand: 'k',
        million: 'm',
        billion: 'b',
        trillion: 't'
    },
    ordinal: function (number) {
        var b = number % 10;
        return ~~((number % 100) / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
        symbol: '$'
    }
});
(function () {
    numeral.register('format', 'bps', {
        regexps: {
            format: /(BPS)/,
            unformat: /(BPS)/
        },
        format: function (value, format, roundingFunction) {
            var space = numeral._.includes(format, ' BPS') ? ' ' : '', output;
            value = value * 10000;
            // check for space before BPS
            format = format.replace(/\s?BPS/, '');
            output = numeral._.numberToFormat(value, format, roundingFunction);
            if (numeral._.includes(output, ')')) {
                output = output.split('');
                output.splice(-1, 0, space + 'BPS');
                output = output.join('');
            }
            else {
                output = output + space + 'BPS';
            }
            return output;
        },
        unformat: function (string) {
            return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
        }
    });
})();
(function () {
    var decimal = {
        base: 1000,
        suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    }, binary = {
        base: 1024,
        suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    };
    var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function (item) {
        return decimal.suffixes.indexOf(item) < 0;
    }));
    var unformatRegex = allSuffixes.join('|');
    // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
    unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';
    numeral.register('format', 'bytes', {
        regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
        },
        format: function (value, format, roundingFunction) {
            var output, bytes = numeral._.includes(format, 'ib') ? binary : decimal, suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '', power, min, max;
            // check for space before
            format = format.replace(/\s?i?b/, '');
            for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);
                if (value === null || value === 0 || (value >= min && value < max)) {
                    suffix += bytes.suffixes[power];
                    if (min > 0) {
                        value = value / min;
                    }
                    break;
                }
            }
            output = numeral._.numberToFormat(value, format, roundingFunction);
            return output + suffix;
        },
        unformat: function (string) {
            var value = numeral._.stringToNumber(string), power, bytesMultiplier;
            if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                    if (numeral._.includes(string, decimal.suffixes[power])) {
                        bytesMultiplier = Math.pow(decimal.base, power);
                        break;
                    }
                    if (numeral._.includes(string, binary.suffixes[power])) {
                        bytesMultiplier = Math.pow(binary.base, power);
                        break;
                    }
                }
                value *= bytesMultiplier || 1;
            }
            return value;
        }
    });
})();
(function () {
    numeral.register('format', 'currency', {
        regexps: {
            format: /(\$)/
        },
        format: function (value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale], symbols = {
                before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
            }, output, symbol, i;
            // strip format of spaces and $
            format = format.replace(/\s?\$\s?/, '');
            // format the number
            output = numeral._.numberToFormat(value, format, roundingFunction);
            // update the before and after based on value
            if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, '');
                symbols.after = symbols.after.replace(/[\-\)]/, '');
            }
            else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                symbols.before = '-' + symbols.before;
            }
            // loop through each before symbol
            for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];
                switch (symbol) {
                    case '$':
                        output = numeral._.insert(output, locale.currency.symbol, i);
                        break;
                    case ' ':
                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                        break;
                }
            }
            // loop through each after symbol
            for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];
                switch (symbol) {
                    case '$':
                        output =
                            i === symbols.after.length - 1
                                ? output + locale.currency.symbol
                                : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                        break;
                    case ' ':
                        output =
                            i === symbols.after.length - 1
                                ? output + ' '
                                : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                        break;
                }
            }
            return output;
        }
    });
})();
(function () {
    numeral.register('format', 'exponential', {
        regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
        },
        format: function (value, format, roundingFunction) {
            var output, exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0', parts = exponential.split('e');
            format = format.replace(/e[\+|\-]{1}0/, '');
            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);
            return output + 'e' + parts[1];
        },
        unformat: function (string) {
            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'), value = Number(parts[0]), power = Number(parts[1]);
            power = numeral._.includes(string, 'e-') ? (power *= -1) : power;
            function cback(accum, curr, currI, O) {
                var corrFactor = numeral._.correctionFactor(accum, curr), num = (accum * corrFactor * (curr * corrFactor)) / (corrFactor * corrFactor);
                return num;
            }
            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
        }
    });
})();
(function () {
    numeral.register('format', 'ordinal', {
        regexps: {
            format: /(o)/
        },
        format: function (value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale], output, ordinal = numeral._.includes(format, ' o') ? ' ' : '';
            // check for space before
            format = format.replace(/\s?o/, '');
            ordinal += locale.ordinal(value);
            output = numeral._.numberToFormat(value, format, roundingFunction);
            return output + ordinal;
        }
    });
})();
(function () {
    numeral.register('format', 'percentage', {
        regexps: {
            format: /(%)/,
            unformat: /(%)/
        },
        format: function (value, format, roundingFunction) {
            var space = numeral._.includes(format, ' %') ? ' ' : '', output;
            if (numeral.options.scalePercentBy100) {
                value = value * 100;
            }
            // check for space before %
            format = format.replace(/\s?\%/, '');
            output = numeral._.numberToFormat(value, format, roundingFunction);
            if (numeral._.includes(output, ')')) {
                output = output.split('');
                output.splice(-1, 0, space + '%');
                output = output.join('');
            }
            else {
                output = output + space + '%';
            }
            return output;
        },
        unformat: function (string) {
            var number = numeral._.stringToNumber(string);
            if (numeral.options.scalePercentBy100) {
                return number * 0.01;
            }
            return number;
        }
    });
})();
(function () {
    numeral.register('format', 'time', {
        regexps: {
            format: /(:)/,
            unformat: /(:)/
        },
        format: function (value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        },
        unformat: function (string) {
            var timeArray = string.split(':'), seconds = 0;
            // turn hours and minutes into seconds and add them all up
            if (timeArray.length === 3) {
                // hours
                seconds = seconds + Number(timeArray[0]) * 60 * 60;
                // minutes
                seconds = seconds + Number(timeArray[1]) * 60;
                // seconds
                seconds = seconds + Number(timeArray[2]);
            }
            else if (timeArray.length === 2) {
                // minutes
                seconds = seconds + Number(timeArray[0]) * 60;
                // seconds
                seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
        }
    });
})();
var numeral$1 = numeral;

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function formatStats(val, format) {
    if (val === void 0) { val = '0'; }
    if (format === void 0) { format = '(0.00a)'; }
    return numeral$1(val).format(format);
    // this type of code would be needed if we abstract the formatting into an api for the users
    // for now we can just force the users to provide the relevant format for numeral to work correctly
    // switch(true) {
    //   //for currency with auto decimal point(s)
    //   case type == 'currency' && decimal == 'auto':
    //     return numeral(val).format('$0.00a');
    //   //for currency with 1 decimal point(s)
    //   case type == 'currency' && decimal == 1:
    //     return numeral(val).format('$0.0a');
    //   //for currency with 1 decimal point(s)
    //   case type == 'number' && decimal == 1:
    //     return numeral(val).format('$0.0a');
    //     //for percent with round-off to next
    //   case type == 'percent':
    //     var t = numeral(val).format('0.00%');
    //     t = Math.ceil(t.substring(0, t.indexOf('%')));
    //     return t + '%';
    // }
}
function roundTo(value, decimals) {
    var scale = Math.pow(10, decimals || 0);
    return Math.round((value + Number.EPSILON) * scale) / scale;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function leastSquares(xSeries, ySeries) {
    var reduceSumFunc = function (prev, cur) {
        return prev + cur;
    };
    var xBar = (xSeries.reduce(reduceSumFunc) * 1.0) / xSeries.length;
    var yBar = (ySeries.reduce(reduceSumFunc) * 1.0) / ySeries.length;
    var ssXX = xSeries
        .map(function (d) {
        return Math.pow(d - xBar, 2);
    })
        .reduce(reduceSumFunc);
    var ssYY = ySeries
        .map(function (d) {
        return Math.pow(d - yBar, 2);
    })
        .reduce(reduceSumFunc);
    var ssXY = xSeries
        .map(function (d, i) {
        return (d - xBar) * (ySeries[i] - yBar);
    })
        .reduce(reduceSumFunc);
    var slope = ssXY / ssXX;
    var intercept = yBar - xBar * slope;
    var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);
    return [slope, intercept, rSquare];
}
function capitalized(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function formatDataLabel(d, labelAccessor, format, normalized) {
    var modifier = normalized ? d.getSum() : 1;
    return format
        ? formatStats(d[labelAccessor] / modifier, format === 'normalized' ? '0[.][0]%' : format)
        : d[labelAccessor] / modifier;
}
var placeDataLabels = function (_a) {
    var root = _a.root, xScale = _a.xScale, yScale = _a.yScale, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, placement = _a.placement, layout = _a.layout, labelOffset = _a.labelOffset, radius = _a.radius, chartType = _a.chartType, normalized = _a.normalized;
    var xPlacement;
    var yPlacement;
    var offset;
    var offset2;
    var textAnchor;
    if (chartType === 'bar') {
        switch (placement) {
            case 'top':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                yPlacement = function (d) { return yScale(Math.max(0, d[valueAccessor])); };
                offset = '-.3em';
                textAnchor = 'middle';
                break;
            case 'bottom':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                yPlacement = function (d) { return yScale(Math.min(0, d[valueAccessor])) - 2; };
                offset = '-.2em';
                textAnchor = 'middle';
                break;
            case 'left':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                offset = '.2em';
                textAnchor = 'start';
                break;
            case 'right':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])) + 2; };
                offset = '.2em';
                textAnchor = 'start';
                break;
            case 'top-left':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                offset = '.2em';
                offset2 = '-.2em';
                textAnchor = 'start';
                break;
            case 'top-right':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                offset = '-3em';
                offset2 = '-.2em';
                textAnchor = 'start';
                break;
            case 'bottom-left':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth(); };
                xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                offset = '.2em';
                offset2 = '1em';
                textAnchor = 'start';
                break;
            case 'bottom-right':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth(); };
                xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                offset = '-3em';
                offset2 = '1em';
                textAnchor = 'start';
                break;
        }
    }
    else if (chartType === 'stacked') {
        var getMod_1 = function (d) { return (normalized ? d.getSum() : 1); };
        if (layout === 'vertical') {
            switch (placement) {
                case 'bottom':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                    yPlacement = function (d) { return yScale(d.stackEnd / getMod_1(d)); };
                    offset = '-.3em';
                    textAnchor = 'middle';
                    break;
                case 'top':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                    yPlacement = function (d) { return yScale(d.stackStart / getMod_1(d)); };
                    offset = '1em';
                    textAnchor = 'middle';
                    break;
                case 'middle':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                    yPlacement = function (d) { return (yScale(d.stackStart / getMod_1(d)) + yScale(d.stackEnd / getMod_1(d))) / 2; };
                    offset = '.3em';
                    textAnchor = 'middle';
                    break;
            }
        }
        else {
            switch (placement) {
                case 'base':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                    xPlacement = function (d) { return (d.stackEnd < 0 ? xScale(d.stackStart / getMod_1(d)) : xScale(d.stackEnd / getMod_1(d))); };
                    offset = function (d) { return (d.stackEnd < 0 ? '-.3em' : '.3em'); };
                    textAnchor = function (d) { return (d.stackEnd < 0 ? 'end' : 'start'); };
                    break;
                case 'end':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                    xPlacement = function (d) { return (d.stackEnd < 0 ? xScale(d.stackEnd / getMod_1(d)) : xScale(d.stackStart / getMod_1(d))); };
                    offset = function (d) { return (d.stackEnd < 0 ? '.3em' : '-.3em'); };
                    textAnchor = function (d) { return (d.stackEnd < 0 ? 'start' : 'end'); };
                    break;
                case 'middle':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                    xPlacement = function (d) { return (xScale(d.stackStart) + xScale(d.stackEnd)) / 2; };
                    offset = '0em';
                    textAnchor = 'middle';
                    break;
            }
        }
    }
    else if (chartType === 'line') {
        switch (placement) {
            case 'top':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d[valueAccessor]); };
                offset2 = '-0.6em';
                textAnchor = 'middle';
                break;
            case 'bottom':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d[valueAccessor]) + 20; };
                textAnchor = 'middle';
                break;
            case 'left':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                xPlacement = function (d) { return xScale(d[valueAccessor]); };
                offset = '.2em';
                textAnchor = 'start';
                break;
            case 'right':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                xPlacement = function (d) { return xScale(d[valueAccessor]) + 4; };
                offset = '.2em';
                textAnchor = 'start';
                break;
        }
    }
    else if (chartType === 'parallel') {
        switch (placement) {
            case 'bottom-right':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d); };
                offset = '0.3em';
                offset2 = '0.9em';
                textAnchor = 'start';
                break;
            case 'top-right':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d); };
                offset = '0.3em';
                offset2 = '-0.1em';
                textAnchor = 'start';
                break;
            case 'bottom-left':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d); };
                offset = '-0.3em';
                offset2 = '0.9em';
                textAnchor = 'end';
                break;
            case 'top-left':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d); };
                offset = '-0.3em';
                offset2 = '-0.1em';
                textAnchor = 'end';
                break;
        }
    }
    else if (chartType === 'dumbbell') {
        switch (placement) {
            case 'ends':
                xPlacement = function (d) { return (layout === 'vertical' ? xScale(d[ordinalAccessor]) : xScale(d[valueAccessor]) - d.offset); };
                yPlacement = function (d) { return (layout === 'vertical' ? yScale(d[valueAccessor]) + d.offset : yScale(d[ordinalAccessor])); };
                offset = function (d) {
                    return layout === 'vertical' && d.offset >= 0
                        ? '0.9em'
                        : layout === 'vertical'
                            ? '-0.3em'
                            : d.offset >= 0
                                ? '-0.3em'
                                : '0.3em';
                };
                offset2 = layout === 'vertical' ? '0.0em' : '0.3em';
                textAnchor = function (d) {
                    return layout === 'vertical' ? 'middle' : d.offset >= 0 ? 'end' : 'start';
                };
                break;
            case 'top':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) - Math.abs(d.offset); };
                xPlacement = function (d) { return xScale(d[valueAccessor]); };
                offset2 = '-0.3em'; // d => -Math.abs(d.offset);
                offset = '0.0em';
                textAnchor = 'middle';
                break;
            case 'bottom':
                yPlacement = function (d) { return yScale(d[ordinalAccessor]) + Math.abs(d.offset); };
                xPlacement = function (d) { return xScale(d[valueAccessor]) + 4; };
                offset2 = '0.9em'; // d => Math.abs(d.offset);
                offset = '0.0em';
                textAnchor = 'middle';
                break;
            case 'left':
                yPlacement = function (d) { return yScale(d[valueAccessor]); };
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) - 4 - Math.abs(d.offset); };
                offset2 = '0.0em'; // d => -Math.abs(d.offset);
                offset = '0.3em';
                textAnchor = 'end';
                break;
            case 'right':
                yPlacement = function (d) { return yScale(d[valueAccessor]); };
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) + 4 + Math.abs(d.offset); };
                offset2 = '0.0em'; // d => Math.abs(d.offset);
                offset = '0.3em';
                textAnchor = 'start';
                break;
        }
    }
    else if (chartType === 'pie') {
        switch (placement) {
            case 'inside':
                offset2 = '0.1em';
                textAnchor = 'middle';
                break;
            case 'outside':
                textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                xPlacement = function (d) { return (radius + 5) * Math.sin((d.startAngle + d.endAngle) / 2); };
                yPlacement = function (d) { return -(radius + 5) * Math.cos((d.startAngle + d.endAngle) / 2); };
                offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset : -labelOffset); };
                break;
            case 'edge':
                xPlacement = function (d) { return (radius + 10) * Math.sin(d.endAngle); };
                yPlacement = function (d) { return -(radius + 10) * Math.cos(d.endAngle); };
                offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset : -labelOffset); };
                textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                break;
            case 'note':
                textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                xPlacement = function (d) { return (radius + 5) * Math.sin((d.startAngle + d.endAngle) / 2); };
                yPlacement = function (d) { return -(radius + 5) * Math.cos((d.startAngle + d.endAngle) / 2); };
                offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset + 15 : -labelOffset + 15); };
                break;
            case 'note_edge':
                xPlacement = function (d) { return (radius + 10) * Math.sin(d.endAngle); };
                yPlacement = function (d) { return -(radius + 10) * Math.cos(d.endAngle); };
                offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset + 15 : -labelOffset + 15); };
                textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                break;
        }
    }
    else if (chartType === 'scatter') {
        switch (placement) {
            case 'top':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d[valueAccessor]) - labelOffset; };
                offset2 = '-0.35em';
                textAnchor = 'middle';
                break;
            case 'bottom':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                yPlacement = function (d) { return yScale(d[valueAccessor]) + labelOffset; };
                offset2 = '0.9em';
                textAnchor = 'middle';
                break;
            case 'left':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) - labelOffset; };
                yPlacement = function (d) { return yScale(d[valueAccessor]); };
                offset = '-.4em';
                offset2 = '0.3em';
                textAnchor = 'end';
                break;
            case 'right':
                xPlacement = function (d) { return xScale(d[ordinalAccessor]) + labelOffset; };
                yPlacement = function (d) { return yScale(d[valueAccessor]); };
                offset = '.35em';
                offset2 = '0.3em';
                textAnchor = 'start';
                break;
        }
    }
    else if (chartType === 'heat-map') {
        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
        yPlacement = function (d) { return yScale(d[valueAccessor]) + yScale.bandwidth() / 2; };
        offset2 = '.5em';
        textAnchor = 'middle';
    }
    else if (chartType === 'world-map') {
        xPlacement = function (d) { return xScale([+d[ordinalAccessor], +d[valueAccessor]])[0]; };
        yPlacement = function (d) { return xScale([+d[ordinalAccessor], +d[valueAccessor]])[1]; };
    }
    root
        .attr('x', xPlacement)
        .attr('y', yPlacement)
        .attr(layout === 'vertical' ? 'dy' : 'dx', offset)
        .attr(layout === 'vertical' ? 'dx' : 'dy', offset2)
        .attr('text-anchor', textAnchor);
};
function getDataSymbol(symbolFunc, symbolType) {
    var symbolMap = {
        cross: d3Shape.symbolCross,
        circle: d3Shape.symbolCircle,
        square: d3Shape.symbolSquare,
        star: d3Shape.symbolStar,
        triangle: d3Shape.symbolTriangle,
        diamond: d3Shape.symbolDiamond
    };
    return symbolMap[symbolType] ? symbolFunc.type(symbolMap[symbolType])() : symbolFunc.type(d3Shape.symbolCircle)();
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var formatDate = function (_a) {
    var date = _a.date, format = _a.format, offsetTimezone = _a.offsetTimezone;
    var userTimezoneOffset = offsetTimezone ? date.getTimezoneOffset() * 60000 : 0;
    var offsetDate = new Date(date.getTime() + userTimezoneOffset);
    format = format.includes('%') ? format : '%Y %b';
    var formatedDate = d3TimeFormat.timeFormat(format)(offsetDate);
    return formatedDate;
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var buildTooltipContent = function (_a) {
    var data = _a.data, tooltipLabel = _a.tooltipLabel, xAxis = _a.xAxis, yAxis = _a.yAxis, dataLabel = _a.dataLabel, layout = _a.layout, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, xAccessor = _a.xAccessor, // equivalent to joinNameAccessor / markerNameAccessor in map
    yAccessor = _a.yAccessor, // equivalent to joinAccessor / markerAccessor in map
    groupAccessor = _a.groupAccessor, // equivalent to seriesAccessor in line, dumbbell, parallel
    diffLabelDetails = _a.diffLabelDetails, normalized = _a.normalized, chartType = _a.chartType;
    // user assigned tooltipLabel
    if (tooltipLabel && tooltipLabel.labelAccessor.length > 0) {
        var labelStr_1 = '';
        tooltipLabel.labelAccessor.map(function (k, i) {
            var title = tooltipLabel.labelTitle && tooltipLabel.labelTitle[i] !== '' ? tooltipLabel.labelTitle[i] + ': ' : '';
            labelStr_1 += title + "<b>" + (tooltipLabel.format && tooltipLabel.format[i]
                ? data[k] instanceof Date
                    ? formatDate({
                        date: data[k],
                        format: tooltipLabel.format[i],
                        offsetTimezone: true
                    })
                    : normalized && tooltipLabel.format[i] === 'normalized' // only for stacked-bar value
                        ? formatDataLabel(data, k, dataLabel.format, k === valueAccessor)
                        : !isNaN(parseFloat(data[k]))
                            ? formatStats(data[k], tooltipLabel.format[i])
                            : data[k]
                : data[k]) + " </b><br/>";
        });
        labelStr_1.replace(',', '');
        return labelStr_1;
    }
    else {
        //default tooltip
        var defaultLabel = '';
        var firstTitle = xAxis && yAxis
            ? (layout === 'horizontal' ? yAxis.label : xAxis.label) || xAccessor || ordinalAccessor
            : ordinalAccessor;
        var secondTitle = xAxis && yAxis
            ? (layout === 'horizontal' ? xAxis.label : yAxis.label) || yAccessor || valueAccessor
            : valueAccessor;
        // bar, pie
        if (chartType === 'bar') {
            defaultLabel = "\n      <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + " </b>\n      " + (capitalized(firstTitle) + ': <b>' + data[ordinalAccessor]) + " </b><br/> \n        " + (capitalized(secondTitle) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format) + "</b>";
        }
        // if we have normalized then we output percent and value
        else if (chartType === 'pie') {
            defaultLabel = "\n        " + (capitalized(firstTitle) + ': <b>' + data[ordinalAccessor]) + " </b><br/> \n        " + (normalized
                ? capitalized(secondTitle) +
                    ' (%): <b>' +
                    formatDataLabel(data, valueAccessor, '0[.][0]%', normalized) +
                    '</b><br/>'
                : '') + "\n        " + (capitalized(secondTitle) + ': ') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format === 'normalized' ? '0[.][0]a' : dataLabel.format) + "</b>\n      ";
        }
        // scatter-plot
        else if (chartType === 'scatter') {
            defaultLabel = "\n        <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + " </b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + formatStats(data[xAccessor], xAxis.format || '') + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + formatStats(data[yAccessor], yAxis.format || '') + "</b>";
        }
        // line, parallel
        else if (chartType === 'line' || chartType === 'parallel') {
            defaultLabel = "\n        <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + "</b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + (data[ordinalAccessor] instanceof Date
                ? formatDate({
                    date: data[ordinalAccessor],
                    format: xAxis.format,
                    offsetTimezone: true
                })
                : data[ordinalAccessor]) + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
        }
        // stacked-bar, clustered-bar
        else if (chartType === 'stacked' || chartType === 'clustered') {
            defaultLabel = "\n        <b>" + (data[groupAccessor] + '<br/>') + "</b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + data[ordinalAccessor] + " </b><br/> \n        " + (normalized
                ? capitalized(secondTitle) +
                    ' (%): <b>' +
                    formatDataLabel(data, valueAccessor, '0[.][0]%', normalized) +
                    '</b><br/>'
                : '') + "\n        " + (capitalized(secondTitle) + ': ') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format === 'normalized' ? '0[.][0]a' : dataLabel.format) + "</b>\n      ";
        }
        // heat-map
        else if (chartType === 'heat-map') {
            defaultLabel = "\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + (data[xAccessor] instanceof Date
                ? formatDate({
                    date: data[xAccessor],
                    format: xAxis.format,
                    offsetTimezone: true
                })
                : data[xAccessor]) + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + (data[yAccessor] instanceof Date
                ? formatDate({
                    date: data[yAccessor],
                    format: yAxis.format,
                    offsetTimezone: true
                })
                : data[yAccessor]) + " </b><br/>\n        " + (capitalized(valueAccessor) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
        }
        // circle-packing
        else if (chartType === 'circle-packing') {
            defaultLabel = "\n        <b>" + capitalized(data[ordinalAccessor]) + " </b><br/>\n        " + (capitalized(groupAccessor) + ': <b>' + data[groupAccessor]) + " </b><br/>\n        " + (capitalized(valueAccessor) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
        }
        // world-map
        else if (chartType === 'world-map') {
            defaultLabel = "\n        <b>" + data[xAccessor] + " (" + data[yAccessor] + ") </b><br/>\n          " + valueAccessor + ": \n          <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
        }
        // dumbbell
        else if (chartType === 'dumbbell') {
            if (data && data.key && data.values) {
                defaultLabel =
                    "<b>\n          " + (data.values[0][ordinalAccessor] instanceof Date
                        ? formatDate({
                            date: data.values[0][ordinalAccessor],
                            format: xAxis.format,
                            offsetTimezone: true
                        })
                        : data.values[0][ordinalAccessor]) + " </b><br/>" +
                        'Difference: ' +
                        ("<b>" + (dataLabel.format
                            ? formatStats(data[diffLabelDetails.calculation], dataLabel.format)
                            : data[diffLabelDetails.calculation]) + " <br/></b>") +
                        data.values[0][groupAccessor] +
                        ': ' +
                        ("<b>" + (dataLabel.format
                            ? formatStats(data.values[0][valueAccessor], dataLabel.format)
                            : data.values[0][valueAccessor]) + " </b><br/>") +
                        data.values[1][groupAccessor] +
                        ': ' +
                        ("<b>" + (dataLabel.format
                            ? formatStats(data.values[1][valueAccessor], dataLabel.format)
                            : data.values[1][valueAccessor]) + "</b>\n        ");
            }
            else {
                defaultLabel =
                    "<b>\n        " + (data[ordinalAccessor] instanceof Date
                        ? formatDate({
                            date: data[ordinalAccessor],
                            format: xAxis.format,
                            offsetTimezone: true
                        })
                        : data[ordinalAccessor]) + " </b><br/>" +
                        data[groupAccessor] +
                        ': ' +
                        ("<b>" + (dataLabel.format ? formatStats(data[valueAccessor], dataLabel.format) : data[valueAccessor]) + "</b>\n        ");
            }
        }
        // alluvial-diagram
        else if (chartType === 'alluvial-diagram') {
            defaultLabel = "\n      <b>" + capitalized(data['source'][ordinalAccessor]) + "</b> to <b>" + capitalized(data['target'][ordinalAccessor]) + " </b><br/>\n      " + (capitalized(valueAccessor) + ':') + "\n      <b>" + (dataLabel && dataLabel.format ? formatStats(data['value'], dataLabel.format) : data['value']) + "</b>";
        }
        return defaultLabel;
    }
};
var overrideTitleTooltip = function (uniqueID, toRemove) {
    var paddingIdBegin = 'visa-viz-padding-container-g-';
    var paddingG = d3Selection.select("#" + paddingIdBegin + uniqueID);
    if (toRemove) {
        if (paddingG.select('title').size() === 0) {
            paddingG.append('title').text('');
        }
    }
    else {
        paddingG.select('title').remove();
    }
};
var initTooltipStyle = function (root) {
    root
        .style('position', 'absolute')
        .style('padding', '0.5rem')
        .style('opacity', 0)
        .style('background-color', '#ffffff')
        .style('font-size', '14px')
        .style('font-weight', '400')
        .style('color', '#222222')
        .style('border', '1px solid #565656')
        .style('border-radius', '3px')
        .style('pointer-events', 'none')
        .style('min-width', '80px')
        .style('max-width', '300px');
    root.append('p').style('margin', 0);
};
var drawTooltip = function (_a) {
    var root = _a.root, data = _a.data, event = _a.event, isToShow = _a.isToShow, tooltipLabel = _a.tooltipLabel, xAxis = _a.xAxis, yAxis = _a.yAxis, dataLabel = _a.dataLabel, layout = _a.layout, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, xAccessor = _a.xAccessor, // equivalent to joinNameAccessor / markerNameAccessor in map
    yAccessor = _a.yAccessor, // equivalent to joinAccessor / markerAccessor in map
    groupAccessor = _a.groupAccessor, // equivalent to seriesAccessor in line, dumbbell, parallel
    diffLabelDetails = _a.diffLabelDetails, normalized = _a.normalized, chartType = _a.chartType;
    var toShow = function () {
        var positions = [event.pageX, event.pageY];
        var tooltipContent = buildTooltipContent({
            data: data,
            tooltipLabel: tooltipLabel,
            xAxis: xAxis,
            yAxis: yAxis,
            dataLabel: dataLabel,
            layout: layout,
            ordinalAccessor: ordinalAccessor,
            valueAccessor: valueAccessor,
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            groupAccessor: groupAccessor,
            diffLabelDetails: diffLabelDetails,
            normalized: normalized,
            chartType: chartType
        });
        // get bounds of parent (e.g., placement of chart container)
        var parentBounds = root.node().parentElement.getBoundingClientRect();
        // place tooltip on top left temporary to populate and not have wrap
        root.style('left', '0px').style('top', '0px');
        // populate tooltip so we can get its bounds as well
        root.select('p').html(tooltipContent);
        // now we get bounds for height/width/top/left after populating content
        var bounds = root.node().getBoundingClientRect();
        // if the page has been scrolled we need to account for that
        var adjLeft = (document.body.scrollLeft || 0) + (document.documentElement.scrollLeft || 0);
        var adjLeftFlip = parentBounds.width / 2 - (positions[0] - bounds.left - adjLeft) < 0 ? bounds.width : 0;
        var adjTop = (document.body.scrollTop || 0) + (document.documentElement.scrollTop || 0);
        // place tooltip and then fade in
        // left = mouse position - adjust left for parent container location (bounds.left) - adjust for scroll - adjust to left if on right half of graph
        // right = mouse position - adjust up for parent container location (bounds.right) - adjust for height of tooltip - adjust for scroll
        root
            .style('left', positions[0] - bounds.left - adjLeft - adjLeftFlip + "px")
            .style('top', positions[1] - bounds.top - bounds.height - adjTop + "px")
            .transition(d3Transition.transition().duration(200))
            .style('opacity', 1);
    };
    var toHide = function () {
        root.transition(d3Transition.transition().duration(500)).style('opacity', 0);
    };
    if (root) {
        isToShow ? toShow() : toHide();
        setTooltipAccess(root.node());
    }
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var circularFind = function (array, index) {
    var remainder = index % array.length;
    return array[remainder === 0 ? 0 : remainder];
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var visaColors = {
    pri_grey: '#5C5C5C',
    sec_blue: '#003ea9',
    sec_orange: '#ef8400',
    sec_yellow: '#ffd700',
    comp_blue: '#2bb4da',
    comp_green: '#00a25e',
    supp_pink: '#ae48b4',
    supp_purple: '#7f48b4',
    supp_green: '#649f4a',
    supp_red: '#a50026',
    // for data viz component
    base_grey: '#D7D7DE',
    light_text: '#ffffff',
    grey_text: '#565656',
    dark_text: '#222222',
    // blue to black theme
    oss_blue: '#0051dc',
    oss_light_blue: '#7FA8ED',
    oss_dark_grey: '#363636',
    oss_light_grey: '#D7D7D7',
    // for categorical palettes
    categorical_blue: '#226092',
    categorical_light_blue: '#7c99b1',
    categorical_blue_text: '#164d79',
    categorical_purple: '#796aaf',
    categorical_light_purple: '#cacae7',
    categorical_purple_text: '#66589b',
    categorical_olive: '#829e46',
    categorical_light_olive: '#abb798',
    categorical_olive_text: '#498329',
    categorical_grey: '#7a6763',
    categorical_light_grey: '#a19491',
    categorical_grey_text: '#6e5a55',
    categorical_rose: '#c18174',
    categorical_light_rose: '#e7c0b8',
    categorical_rose_text: '#954737',
    categorical_brown: '#43312d',
    categorical_light_brown: '#624c48',
    categorical_brown_text: '#43312d'
};
function darkerColor(color) {
    var hexColor = visaColors[color] || color;
    return d3Color.hsl(hexColor)
        .darker(1.5)
        .hex();
}
function brighterColor(color) {
    var hexColor = visaColors[color] || color;
    var brighterScale = d3Scale.scaleLinear()
        .domain([0, 0.45])
        .range([4, 2]);
    return d3Color.hsl(hexColor)
        .brighter(brighterScale(d3Color.hsl(hexColor).l))
        .hex();
    // return "white"
}
function outlineColor(color) {
    var hexColor = visaColors[color] || color;
    return d3Color.hsl(hexColor).l > 0.4 ? darkerColor(hexColor) : brighterColor(hexColor);
}
var sequentialColorIndex = [
    [7],
    [7],
    [2, 6],
    [0, 3, 6],
    [0, 2, 4, 6],
    [0, 1, 3, 5, 7],
    [1, 2, 3, 4, 5, 6],
    [0, 1, 2, 3, 4, 5, 6],
    [0, 1, 2, 3, 4, 5, 6, 7]
];
var divergingColorIndex = [
    [0],
    [0],
    [0, 9],
    [0, 4, 9],
    [0, 3, 6, 9],
    [0, 2, 4, 6, 9],
    [0, 2, 4, 5, 7, 9],
    [0, 1, 2, 4, 7, 8, 9],
    [0, 1, 2, 3, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
];
var categoricalColorIndex = [
    [0],
    [0],
    [0, 1],
    [0, 1, 2],
    [0, 1, 2, 3],
    [0, 1, 2, 3, 4],
    [0, 1, 2, 3, 4, 5],
    [0, 1, 2, 3, 4, 5, 6],
    [0, 1, 2, 3, 4, 5, 6, 7],
    [0, 1, 2, 3, 4, 5, 6, 7, 8],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] //8-11
];
function getColors(colorPalette, dataRange) {
    var colorArr = [];
    colorArr['single_blue'] = [visaColors.categorical_blue];
    colorArr['single_brown'] = [visaColors.categorical_brown];
    colorArr['single_grey'] = [visaColors.pri_grey];
    colorArr['single_secBlue'] = [visaColors.sec_blue];
    colorArr['single_secOrange'] = [visaColors.sec_orange];
    colorArr['single_compBlue'] = [visaColors.comp_blue];
    colorArr['single_compGreen'] = [visaColors.comp_green];
    colorArr['single_suppPink'] = [visaColors.supp_pink];
    colorArr['single_suppPurple'] = [visaColors.supp_purple];
    colorArr['single_suppGreen'] = [visaColors.supp_green];
    colorArr['single_ossBlue'] = [visaColors.oss_blue];
    colorArr['single_ossLightBlue'] = [visaColors.oss_light_blue];
    colorArr['single_ossGrey'] = [visaColors.oss_dark_grey];
    colorArr['single_ossLightGrey'] = [visaColors.oss_light_grey];
    colorArr['single_categorical_blue'] = [visaColors.categorical_blue];
    colorArr['single_categorical_light_blue'] = [visaColors.categorical_light_blue];
    colorArr['single_categorical_blue_text'] = [visaColors.categorical_blue_text];
    colorArr['single_categorical_purple'] = [visaColors.categorical_purple];
    colorArr['single_categorical_light_purple'] = [visaColors.categorical_light_purple];
    colorArr['single_categorical_purple_text'] = [visaColors.categorical_purple_text];
    colorArr['single_categorical_olive'] = [visaColors.categorical_olive];
    colorArr['single_categorical_light_olive'] = [visaColors.categorical_light_olive];
    colorArr['single_categorical_olive_text'] = [visaColors.categorical_olive_text];
    colorArr['single_categorical_grey'] = [visaColors.categorical_grey];
    colorArr['single_categorical_light_grey'] = [visaColors.categorical_light_grey];
    colorArr['single_categorical_grey_text'] = [visaColors.categorical_grey_text];
    colorArr['single_categorical_rose'] = [visaColors.categorical_rose];
    colorArr['single_categorical_light_rose'] = [visaColors.categorical_light_rose];
    colorArr['single_categorical_rose_text'] = [visaColors.categorical_rose_text];
    colorArr['single_categorical_brown'] = [visaColors.categorical_brown];
    colorArr['single_categorical_light_brown'] = [visaColors.categorical_light_brown];
    colorArr['single_categorical_brown_text'] = [visaColors.categorical_brown_text];
    colorArr['sequential_grey'] = [
        '#f2f2f2',
        '#d7d7d7',
        '#bdbdbd',
        '#a3a3a3',
        '#898989',
        '#717171',
        '#595959',
        '#434343',
        '#2e2e2e'
    ];
    colorArr['sequential_secBlue'] = [
        '#ecf9f9',
        '#c0e0f1',
        '#91c8ea',
        '#57b0e2',
        '#0c96d7',
        '#1778c7',
        '#145bb8',
        '#003da8',
        '#002c76'
    ];
    colorArr['sequential_secOrange'] = [
        '#fee9c7',
        '#ffc78d',
        '#faa654',
        '#ef8506',
        '#e36001',
        '#c04e04',
        '#9c3d05',
        '#7b2c05',
        '#5c1c00'
    ];
    colorArr['sequential_compBlue'] = [
        '#f3fbfe',
        '#bde3f2',
        '#81cae6',
        '#2ab1d7',
        '#2294b5',
        '#1b7994',
        '#135d74',
        '#0c4557',
        '#062c3a'
    ];
    colorArr['sequential_compGreen'] = [
        '#eafed4',
        '#bae7b4',
        '#89cf95',
        '#53b677',
        '#009e5c',
        '#00814b',
        '#00663b',
        '#004b2b',
        '#00321d'
    ];
    colorArr['sequential_suppPink'] = [
        '#f8f4f9',
        '#f3cef3',
        '#eca6ed',
        '#e37ce6',
        '#d74adf',
        '#aa45af',
        '#86378a',
        '#632a66',
        '#421b44'
    ];
    colorArr['sequential_suppPurple'] = [
        '#f7fcfd',
        '#e3daec',
        '#cebadd',
        '#b59acc',
        '#977ebb',
        '#7367a5',
        '#554f87',
        '#423667',
        '#331d48'
    ];
    colorArr['sequential_suppGreen'] = [
        '#ffffe5',
        '#deebc3',
        '#bed6a2',
        '#9ec283',
        '#7fae61',
        '#5e9a48',
        '#448340',
        '#286e3a',
        '#005a32'
    ];
    colorArr['diverging_RtoB'] = [
        '#a50026',
        '#c7422a',
        '#df7232',
        '#f3a14b',
        '#ffcf7b',
        '#afdbf1',
        '#7ab7e5',
        '#5390d1',
        '#386bb6',
        '#2d4697'
    ];
    colorArr['diverging_RtoG'] = [
        '#972800',
        '#ba4d18',
        '#df7131',
        '#f0a04e',
        '#fecd6e',
        '#bcdeba',
        '#72c1a7',
        '#529f8e',
        '#307e75',
        '#015e5d'
    ];
    colorArr['diverging_GtoP'] = [
        '#194f46',
        '#377258',
        '#57976f',
        '#7abb8c',
        '#a6e0b5',
        '#bbd4f9',
        '#aba6ea',
        '#9879d2',
        '#7655b2',
        '#3c3f85'
    ];
    colorArr['categorical'] = ['#7c99b1', '#cacae7', '#abb798', '#a19491', '#e7c0b8', '#624c48'];
    colorArr['categorical_light'] = ['#7c99b1', '#cacae7', '#abb798', '#a19491', '#e7c0b8', '#624c48'];
    colorArr['categorical_dark'] = ['#226092', '#796aaf', '#829e46', '#7a6763', '#c18174', '#43312d'];
    colorArr['categorical_text'] = ['#164d79', '#66589b', '#498329', '#6e5a55', '#954737', '#43312d'];
    var selectedColor = typeof colorPalette === 'string' ? colorArr[colorPalette] : colorPalette;
    if (Array.isArray(dataRange)) {
        // range of data keys is passed
        var colorScale = void 0;
        if (typeof dataRange[0] === 'string') {
            var newColorArr_1 = [];
            var colorIndex = colorPalette.includes('diverging')
                ? divergingColorIndex
                : colorPalette.includes('categorical')
                    ? categoricalColorIndex
                    : sequentialColorIndex;
            typeof colorPalette === 'string' && colorIndex[dataRange.length]
                ? colorIndex[dataRange.length].map(function (key) {
                    selectedColor[key] ? newColorArr_1.push(selectedColor[key]) : newColorArr_1.push(selectedColor[0]);
                })
                : (newColorArr_1 = selectedColor);
            colorScale = d3Scale.scaleOrdinal()
                .domain(dataRange)
                .range(newColorArr_1);
        }
        else {
            colorScale = d3Scale.scaleQuantize()
                .domain(dataRange)
                .range(selectedColor);
        }
        return colorScale;
    }
    else if (Number.isInteger(dataRange)) {
        // number of colors is passed
        var newColorArr_2 = [];
        var colorIndex = colorPalette.includes('diverging')
            ? divergingColorIndex
            : colorPalette.includes('categorical')
                ? categoricalColorIndex
                : sequentialColorIndex;
        colorIndex[dataRange]
            ? colorIndex[dataRange].map(function (key) {
                selectedColor[key] ? newColorArr_2.push(selectedColor[key]) : newColorArr_2.push(selectedColor[0]);
            })
            : (newColorArr_2 = selectedColor);
        return newColorArr_2;
    }
    else
        return selectedColor;
}
/**
 * This function will find up to two strokes for a given input color. This is only designed for accessible graphics.
 *
 * This function is designed with VGAR compliance in mind, using the WCAG 2.1 contrast ratio formula to find the highest contrast stroke colors possible for a graphical element. Formula: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests
 *
 * @see  uses two visa/visa-charts-utils functions: calculateLuminance()  and calculateRelativeLuminance().
 *
 * @param {string}   fillColor           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
 *
 * @return {string[]} Returns an array containing color hex values as strings. The first array position is always contrasted against the fill color. The second array position is sometimes empty but if it has a value it will always be the original color. The second value only populates if the original color has more than 3:1 contrast against white.
 */
function getAccessibleStrokes(fillColor) {
    var strokes = [];
    strokes.push(getContrastingStroke(fillColor));
    var luminanceToWhite = calculateRelativeLuminance(calculateLuminance(fillColor), 1);
    if (luminanceToWhite >= 3) {
        strokes.push(fillColor);
    }
    return strokes;
}
// experimental function
// early tests show that this method can still fail to produce a valid stroke
// this is abandoned until further need
function getRecursiveStroke(foreground, background) {
    var extents = {};
    var foregroundLuminance = calculateLuminance(foreground);
    var backgroundLuminance = calculateLuminance(background);
    var foregroundToWhite = calculateRelativeLuminance(foregroundLuminance, 1);
    var backgroundToWhite = calculateRelativeLuminance(backgroundLuminance, 1);
    extents[foreground] = {};
    extents[background] = {};
    extents[foreground].min = foregroundToWhite - 3 > 1 ? foregroundToWhite - 3 : 1;
    extents[foreground].max = foregroundToWhite + 3 < 21 ? foregroundToWhite + 3 : 21;
    extents[background].min = backgroundToWhite - 3 > 1 ? backgroundToWhite - 3 : 1;
    extents[background].max = backgroundToWhite + 3 < 21 ? backgroundToWhite + 3 : 21;
    var darkerColor = extents[foreground].max >= extents[background].max ? foreground : background;
    var lighterColor = extents[foreground].min <= extents[background].min ? foreground : background;
    var lightestValue = extents[lighterColor].min;
    var darkestValue = extents[darkerColor].max;
    var gaps = {
        dark: 21 - darkestValue > 0 ? 21 - darkestValue : 0,
        light: lightestValue - 1 > 0 ? lightestValue - 1 : 0
    };
    var foundStroke = '';
    var operation = '';
    var target = '';
    if (lighterColor === foreground && extents[foreground].max < extents[background].min) {
        // try darkening foreground into the inner gap space
        operation = 'darken';
        target = foreground;
    }
    else if (darkerColor === foreground && extents[foreground].min > extents[background].max) {
        // try lightening foreground into the inner gap space
        operation = 'lighten';
        target = foreground;
    }
    if (operation) {
        var colorAttempt = processColor(target, operation, 3);
        var attemptLuminance = calculateLuminance(colorAttempt);
        foundStroke = calculateRelativeLuminance(backgroundLuminance, attemptLuminance) >= 3 ? colorAttempt : 0;
    }
    if (!foundStroke) {
        // the inner gap didn't work, must try exterior gaps
        if (darkerColor === foreground && gaps.dark) {
            // try darkening foreground into the outer gap space
            operation = 'darken';
            target = foreground;
        }
        else if (lighterColor === foreground && gaps.light) {
            // try lightening foreground into the outer gap space
            operation = 'lighten';
            target = foreground;
        }
        foundStroke = operation ? processColor(target, operation, 3) : '';
    }
    if (!foundStroke) {
        // must try exterior gaps using the background color
        if (gaps.dark > gaps.light) {
            // try darkening foreground into the gap space
            operation = 'darken';
            target = background;
        }
        else {
            // try lighting foreground into the gap space
            operation = 'lighten';
            target = background;
        }
        foundStroke = operation ? processColor(target, operation, 3) : '';
    }
    if (!foundStroke) {
        foundStroke = foreground;
    }
    return foundStroke;
}
function processColor(color, operation, contrast) {
    var originalLuminance = calculateLuminance(color);
    var hslObject = d3Color.hsl(color);
    var limitReached = false;
    var impossible = false;
    if (operation === 'darken') {
        hslObject.l -= 0.01;
        while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < contrast &&
            !impossible) {
            hslObject.l -= 0.01;
            if (limitReached) {
                impossible = true;
            }
            if (hslObject.l < 0) {
                hslObject.l = 0;
                limitReached = true;
            }
        }
    }
    else {
        hslObject.l += 0.01;
        while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < contrast &&
            !impossible) {
            hslObject.l += 0.01;
            if (limitReached) {
                impossible = true;
            }
            if (hslObject.l > 1) {
                hslObject.l = 1;
                limitReached = true;
            }
        }
    }
    return !impossible ? hslObject.hex() : '';
}
function getContrastingStroke(fillColor) {
    var originalLuminance = calculateLuminance(fillColor);
    var luminanceToWhite = calculateRelativeLuminance(originalLuminance, 1);
    var hslObject = d3Color.hsl(fillColor);
    if (luminanceToWhite < 3) {
        hslObject.l -= 0.01;
        while (hslObject.l > 0 &&
            calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < 3 &&
            hslObject.l) {
            hslObject.l -= 0.01;
            if (hslObject.l < 0) {
                hslObject.l = 0;
            }
        }
    }
    else {
        hslObject.l += 0.01;
        while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < 3 &&
            hslObject.l !== 1) {
            hslObject.l += 0.01;
            if (hslObject.l > 1) {
                hslObject.l = 1;
            }
        }
    }
    return hslObject.hex();
}
function ensureTextContrast(textColor) {
    var originalLuminance = calculateLuminance(textColor);
    var luminanceToWhite = calculateRelativeLuminance(originalLuminance, 1);
    var hslObject = d3Color.hsl(textColor);
    if (luminanceToWhite < 4.5) {
        hslObject.l -= 0.01;
        while (hslObject.l > 0 && calculateRelativeLuminance(calculateLuminance(hslObject.hex()), 1) < 4.5 && hslObject.l) {
            hslObject.l -= 0.01;
            if (hslObject.l < 0) {
                hslObject.l = 0;
            }
        }
    }
    return hslObject.hex();
}
/**
 * This function will calculate the perceived luminance of a valid HTML color.
 *
 * Formula and specification from WCAG 2.0: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests.
 *
 * @param {string}   color           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
 *
 * @return {number} Returns a luminance value between 0 (black, no luminance) and 1 (white, full luminance).
 */
function calculateLuminance(color) {
    function calcColorScore(normalizedColor) {
        return normalizedColor <= 0.03928 ? normalizedColor / 12.92 : Math.pow((normalizedColor + 0.055) / 1.055, 2.4);
    }
    var rgbObject = d3Color.rgb(color);
    var rLuminance = 0.2126 * calcColorScore(rgbObject.r / 255);
    var gLuminance = 0.7152 * calcColorScore(rgbObject.g / 255);
    var bLuminance = 0.0722 * calcColorScore(rgbObject.b / 255);
    return rLuminance + gLuminance + bLuminance;
}
/**
 * This function will calculate the contrast ratio between two luminance values.
 *
 * Input luminance values may be supplied in any order. The output will always place the highest value as the numerator. Formula and specification from WCAG 2.0: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests.
 *
 * @see  visa/visa-charts-utils: calculateLuminance() to convert an HTML color into a luminance value (which is the expected input of this function).
 *
 * @param {number}   luminance1           This value must be the calculated luminance of a color.
 * @param {number}   luminance2           This value must be the calculated luminance of another color.
 *
 * @return {number} Returns a contrast ratio between luminance values ranging from 1 (identical luminance) to 21 (complete opposites - black against white).
 */
function calculateRelativeLuminance(luminance1, luminance2) {
    return luminance1 >= luminance2
        ? (luminance1 + 0.05) / (luminance2 + 0.05)
        : (luminance2 + 0.05) / (luminance1 + 0.05);
}
/**
 * This function will find the most appropriate text color (foreground) given a background color.
 *
 * This function is designed with VGAR compliance in mind, using the WCAG 2 contrast ratio formula to find the highest contrast text possible. Formula: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests
 *
 * @see  uses two visa/visa-charts-utils functions: calculateLuminance()  and calculateRelativeLuminance().
 *
 * @param {string}   backgroundColor           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
 *
 * @return {string} Returns a color hex value, either '#ffffff' (white) or '#222222' (lead).
 */
function autoTextColor(backgroundColor) {
    var lightLuminance = calculateLuminance(visaColors['light_text']);
    var greyLuminance = calculateLuminance(visaColors['dark_text']);
    var backgroundLuminance = calculateLuminance(backgroundColor);
    var relativeToLight = calculateRelativeLuminance(lightLuminance, backgroundLuminance);
    var relativeToGrey = calculateRelativeLuminance(greyLuminance, backgroundLuminance);
    return relativeToGrey < 4.5 && relativeToLight < 4.5
        ? visaColors['dark_text']
        : relativeToGrey > relativeToLight
            ? visaColors['dark_text']
            : visaColors['light_text'];
}
function convertVisaColor(colorArr) {
    if (colorArr[0].includes('_')) {
        colorArr.map(function (c, i) { return (colorArr[i] = visaColors[c]); });
    }
    return colorArr;
}
function visaColorToHex(color) {
    var hexColor = visaColors[color] || color;
    return hexColor;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var isSafari$1 = getBrowser() === 'Safari';
var indices = {
    categorical: [[0], [0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5]],
    sequential: [
        [0],
        [0],
        [0, 8],
        [0, 4, 8],
        [1, 3, 5, 7],
        [0, 2, 4, 6, 8],
        [1, 2, 3, 4, 5, 6],
        [1, 2, 3, 4, 5, 6, 7],
        [0, 1, 2, 3, 4, 5, 6, 7],
        [0, 1, 2, 3, 4, 5, 6, 7, 8]
    ],
    diverging_center: [
        ,
        // this scheme is odd-length only
        [5],
        ,
        [0, 5, 10],
        ,
        [1, 3, 5, 7, 9],
        ,
        [2, 3, 4, 5, 6, 7, 8],
        ,
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        ,
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    ],
    diverging_split: [
        ,
        ,
        // this scheme is even-length only
        // this index does not appear on this scheme
        [1, 8],
        ,
        [0, 3, 6, 9],
        ,
        [0, 2, 4, 5, 7, 9],
        ,
        [0, 1, 2, 3, 6, 7, 8, 9],
        ,
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ]
};
function getTexture(_a) {
    var scheme = _a.scheme, id = _a.id, index = _a.index, fillColor = _a.fillColor, textureColor = _a.textureColor;
    var textureData = {
        categorical: [
            {
                attributes: {
                    width: 12,
                    height: 12,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12',
                            height: '12',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0,0 l 12,12 M -3,9 l 6,6 M 9,-3 l 6,6',
                            'stroke-width': '1',
                            'shape-rendering': 'auto',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12,
                    height: 12,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12',
                            height: '12',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '6',
                            cy: '6',
                            r: '1',
                            fill: "" + textureColor,
                            stroke: '#343434',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '0',
                            cy: '0',
                            r: '1',
                            fill: "" + textureColor,
                            stroke: '#343434',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '0',
                            cy: '12',
                            r: '1',
                            fill: "" + textureColor,
                            stroke: '#343434',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '12',
                            cy: '0',
                            r: '1',
                            fill: "" + textureColor,
                            stroke: '#343434',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '12',
                            cy: '12',
                            r: '1',
                            fill: "" + textureColor,
                            stroke: '#343434',
                            'stroke-width': '0'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 24,
                    height: 24,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '24',
                            height: '24',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0,0 l 24,24 M -6,18 l 12,12 M 18,-6 l 12,12',
                            'stroke-width': '1',
                            'shape-rendering': 'auto',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0,24 l 24,-24 M -6,6 l 12,-12 M 18,30 l 12,-12',
                            'stroke-width': '1',
                            'shape-rendering': 'auto',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12,
                    height: 12,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12',
                            height: '12',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 4.5,4.5l3,3M4.5,7.5l3,-3',
                            fill: 'transparent',
                            stroke: "" + textureColor,
                            'stroke-width': '1',
                            'stroke-linecap': 'square',
                            'shape-rendering': 'auto'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 10,
                    height: 10,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10',
                            height: '10',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 5, 0 l 0, 10',
                            'stroke-width': '1',
                            'shape-rendering': 'auto',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12,
                    height: 12,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12',
                            height: '12',
                            fill: "" + fillColor
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '6',
                            cy: '6',
                            r: '1.5',
                            fill: 'none',
                            stroke: "" + textureColor,
                            'stroke-width': '1'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '2',
                            cy: '10',
                            r: '1.5',
                            fill: 'none',
                            stroke: "" + textureColor,
                            'stroke-width': '1'
                        }
                    },
                    {
                        name: 'circle',
                        attributes: {
                            cx: '10',
                            cy: '2',
                            r: '1.5',
                            fill: 'none',
                            stroke: "" + textureColor,
                            'stroke-width': '1'
                        }
                    }
                ]
            }
        ],
        sequential: [
            {
                attributes: {
                    width: 10,
                    height: 10,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10',
                            height: '10',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 0 L 10 0M 0 10 L 10 10',
                            'stroke-width': '1',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 52.40843064167849,
                    height: 10.187166949552141,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '52.40843064167849',
                            height: '10.187166949552141',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -52.40843064167849 10.187166949552141 L 52.40843064167849 -10.187166949552141M -52.40843064167849 20.374333899104283 L 104.81686128335699 -10.187166949552141M 0 20.374333899104283 L 104.81686128335699 0',
                            'stroke-width': '2',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 26.694671625540145,
                    height: 10.785347426775834,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '26.694671625540145',
                            height: '10.785347426775834',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -26.694671625540145 10.785347426775834 L 26.694671625540145 -10.785347426775834M -26.694671625540145 21.570694853551668 L 53.38934325108029 -10.785347426775834M 0 21.570694853551668 L 53.38934325108029 0',
                            'stroke-width': '3',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 17.882916499714003,
                    height: 12.062179485039053,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '17.882916499714003',
                            height: '12.062179485039053',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -17.882916499714003 12.062179485039053 L 17.882916499714003 -12.062179485039053M -17.882916499714003 24.124358970078106 L 35.76583299942801 -12.062179485039053M 0 24.124358970078106 L 35.76583299942801 0',
                            'stroke-width': '4',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 14.142135623730951,
                    height: 14.14213562373095,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '14.142135623730951',
                            height: '14.14213562373095',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -14.142135623730951 14.14213562373095 L 14.142135623730951 -14.14213562373095M -14.142135623730951 28.2842712474619 L 28.284271247461902 -14.14213562373095M 0 28.2842712474619 L 28.284271247461902 0',
                            'stroke-width': '5',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12.062179485039053,
                    height: 17.882916499714003,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12.062179485039053',
                            height: '17.882916499714003',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -12.062179485039053 17.882916499714003 L 12.062179485039053 -17.882916499714003M -12.062179485039053 35.76583299942801 L 24.124358970078106 -17.882916499714003M 0 35.76583299942801 L 24.124358970078106 0',
                            'stroke-width': '6',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 10.863603774052963,
                    height: 25.593046652474495,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10.863603774052963',
                            height: '25.593046652474495',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -10.863603774052963 25.593046652474495 L 10.863603774052963 -25.593046652474495M -10.863603774052963 51.18609330494899 L 21.727207548105927 -25.593046652474495M 0 51.18609330494899 L 21.727207548105927 0',
                            'stroke-width': '7',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 10.187166949552141,
                    height: 52.40843064167844,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10.187166949552141',
                            height: '52.40843064167844',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -10.187166949552141 52.40843064167844 L 10.187166949552141 -52.40843064167844M -10.187166949552141 104.81686128335689 L 20.374333899104283 -52.40843064167844M 0 104.81686128335689 L 20.374333899104283 0',
                            'stroke-width': '8',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 10,
                    height: 10,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10',
                            height: '10',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 0 L 0 10M 10 0 L 10 10',
                            'stroke-width': '9',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            }
        ],
        diverging_split: [
            {
                attributes: {
                    width: 10.35276180410083,
                    height: 38.63703305156273,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10.35276180410083',
                            height: '38.63703305156273',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -38.63703305156273 L 20.70552360820166 38.63703305156273M -10.35276180410083 -38.63703305156273 L 10.35276180410083 38.63703305156273M -10.35276180410083 0 L 10.35276180410083 77.27406610312546',
                            'stroke-width': '9',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 11.547005383792516,
                    height: 20.000000000000004,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '11.547005383792516',
                            height: '20.000000000000004',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -20.000000000000004 L 23.094010767585033 20.000000000000004M -11.547005383792516 -20.000000000000004 L 11.547005383792516 20.000000000000004M -11.547005383792516 0 L 11.547005383792516 40.00000000000001',
                            'stroke-width': '7',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 14.142135623730951,
                    height: 14.142135623730951,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '14.142135623730951',
                            height: '14.142135623730951',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -14.142135623730951 L 28.284271247461902 14.142135623730951M -14.142135623730951 -14.142135623730951 L 14.142135623730951 14.142135623730951M -14.142135623730951 0 L 14.142135623730951 28.284271247461902',
                            'stroke-width': '5',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 20.000000000000004,
                    height: 11.547005383792516,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '20.000000000000004',
                            height: '11.547005383792516',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -11.547005383792516 L 40.00000000000001 11.547005383792516M -20.000000000000004 -11.547005383792516 L 20.000000000000004 11.547005383792516M -20.000000000000004 0 L 20.000000000000004 23.094010767585033',
                            'stroke-width': '3',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 38.63703305156273,
                    height: 10.35276180410083,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '38.63703305156273',
                            height: '10.35276180410083',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -10.35276180410083 L 77.27406610312546 10.35276180410083M -38.63703305156273 -10.35276180410083 L 38.63703305156273 10.35276180410083M -38.63703305156273 0 L 38.63703305156273 20.70552360820166',
                            'stroke-width': '1',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 38.63703305156273,
                    height: 10.35276180410083,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '38.63703305156273',
                            height: '10.35276180410083',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -38.63703305156273 10.35276180410083 L 38.63703305156273 -10.35276180410083M -38.63703305156273 20.70552360820166 L 77.27406610312546 -10.35276180410083M 0 20.70552360820166 L 77.27406610312546 0',
                            'stroke-width': '1',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 20.000000000000004,
                    height: 11.547005383792515,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '20.000000000000004',
                            height: '11.547005383792515',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -20.000000000000004 11.547005383792515 L 20.000000000000004 -11.547005383792515M -20.000000000000004 23.09401076758503 L 40.00000000000001 -11.547005383792515M 0 23.09401076758503 L 40.00000000000001 0',
                            'stroke-width': '3',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 14.142135623730951,
                    height: 14.14213562373095,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '14.142135623730951',
                            height: '14.14213562373095',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -14.142135623730951 14.14213562373095 L 14.142135623730951 -14.14213562373095M -14.142135623730951 28.2842712474619 L 28.284271247461902 -14.14213562373095M 0 28.2842712474619 L 28.284271247461902 0',
                            'stroke-width': '5',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 11.547005383792516,
                    height: 20.000000000000004,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '11.547005383792516',
                            height: '20.000000000000004',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -11.547005383792516 20.000000000000004 L 11.547005383792516 -20.000000000000004M -11.547005383792516 40.00000000000001 L 23.094010767585033 -20.000000000000004M 0 40.00000000000001 L 23.094010767585033 0',
                            'stroke-width': '7',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 10.35276180410083,
                    height: 38.637033051562696,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '10.35276180410083',
                            height: '38.637033051562696',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -10.35276180410083 38.637033051562696 L 10.35276180410083 -38.637033051562696M -10.35276180410083 77.27406610312539 L 20.70552360820166 -38.637033051562696M 0 77.27406610312539 L 20.70552360820166 0',
                            'stroke-width': '9',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            }
        ],
        diverging_center: [
            {
                attributes: {
                    width: 12.423314164920995,
                    height: 46.36443966187528,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12.423314164920995',
                            height: '46.36443966187528',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -46.36443966187528 L 24.84662832984199 46.36443966187528M -12.423314164920995 -46.36443966187528 L 12.423314164920995 46.36443966187528M -12.423314164920995 0 L 12.423314164920995 92.72887932375056',
                            'stroke-width': '11',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 13.85640646055102,
                    height: 24.000000000000004,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '13.85640646055102',
                            height: '24.000000000000004',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -24.000000000000004 L 27.71281292110204 24.000000000000004M -13.85640646055102 -24.000000000000004 L 13.85640646055102 24.000000000000004M -13.85640646055102 0 L 13.85640646055102 48.00000000000001',
                            'stroke-width': '9',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 16.970562748477143,
                    height: 16.970562748477143,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '16.970562748477143',
                            height: '16.970562748477143',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -16.970562748477143 L 33.941125496954285 16.970562748477143M -16.970562748477143 -16.970562748477143 L 16.970562748477143 16.970562748477143M -16.970562748477143 0 L 16.970562748477143 33.941125496954285',
                            'stroke-width': '7',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 24.000000000000004,
                    height: 13.85640646055102,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '24.000000000000004',
                            height: '13.85640646055102',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -13.85640646055102 L 48.00000000000001 13.85640646055102M -24.000000000000004 -13.85640646055102 L 24.000000000000004 13.85640646055102M -24.000000000000004 0 L 24.000000000000004 27.71281292110204',
                            'stroke-width': '5',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 46.36443966187528,
                    height: 12.423314164920995,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '46.36443966187528',
                            height: '12.423314164920995',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 -12.423314164920995 L 92.72887932375056 12.423314164920995M -46.36443966187528 -12.423314164920995 L 46.36443966187528 12.423314164920995M -46.36443966187528 0 L 46.36443966187528 24.84662832984199',
                            'stroke-width': '3',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12,
                    height: 12,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12',
                            height: '12',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M 0 0 L 12 0M 0 12 L 12 12',
                            'stroke-width': '1',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 46.36443966187528,
                    height: 12.423314164920995,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '46.36443966187528',
                            height: '12.423314164920995',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -46.36443966187528 12.423314164920995 L 46.36443966187528 -12.423314164920995M -46.36443966187528 24.84662832984199 L 92.72887932375056 -12.423314164920995M 0 24.84662832984199 L 92.72887932375056 0',
                            'stroke-width': '3',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 24.000000000000004,
                    height: 13.856406460551018,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '24.000000000000004',
                            height: '13.856406460551018',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -24.000000000000004 13.856406460551018 L 24.000000000000004 -13.856406460551018M -24.000000000000004 27.712812921102035 L 48.00000000000001 -13.856406460551018M 0 27.712812921102035 L 48.00000000000001 0',
                            'stroke-width': '5',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 16.970562748477143,
                    height: 16.97056274847714,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '16.970562748477143',
                            height: '16.97056274847714',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -16.970562748477143 16.97056274847714 L 16.970562748477143 -16.97056274847714M -16.970562748477143 33.94112549695428 L 33.941125496954285 -16.97056274847714M 0 33.94112549695428 L 33.941125496954285 0',
                            'stroke-width': '7',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 13.85640646055102,
                    height: 24.000000000000004,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '13.85640646055102',
                            height: '24.000000000000004',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -13.85640646055102 24.000000000000004 L 13.85640646055102 -24.000000000000004M -13.85640646055102 48.00000000000001 L 27.71281292110204 -24.000000000000004M 0 48.00000000000001 L 27.71281292110204 0',
                            'stroke-width': '9',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            },
            {
                attributes: {
                    width: 12.423314164920995,
                    height: 46.36443966187523,
                    patternUnits: 'userSpaceOnUse',
                    id: "" + id,
                    class: 'VCL-texture-pattern'
                },
                children: [
                    {
                        name: 'rect',
                        attributes: {
                            width: '12.423314164920995',
                            height: '46.36443966187523',
                            fill: "" + fillColor,
                            stroke: 'rgba(255, 0, 0, 0.1)',
                            'stroke-width': '0'
                        }
                    },
                    {
                        name: 'path',
                        attributes: {
                            d: 'M -12.423314164920995 46.36443966187523 L 12.423314164920995 -46.36443966187523M -12.423314164920995 92.72887932375046 L 24.84662832984199 -46.36443966187523M 0 92.72887932375046 L 24.84662832984199 0',
                            'stroke-width': '11',
                            stroke: "" + textureColor,
                            'stroke-linecap': 'square'
                        }
                    }
                ]
            }
        ]
    };
    // need to check categorical index to fill constancy!! Should import the scheme here
    return textureData[scheme][index];
}
var checkAttributeTransitions = function (source, attributeArray) {
    var change = false;
    var i = 0;
    while (!change && i < attributeArray.length) {
        var d = attributeArray[i];
        var currentAttributeValue = d.numeric ? parseFloat(source.attr(d.attr)) : source.attr(d.attr);
        change = !(currentAttributeValue === d.newValue);
        i++;
    }
    return change;
};
function runTextureLifecycle(source, data, transitionDisabled) {
    var parent = d3Selection.select(source);
    var defs = parent.select('defs');
    if (!defs.size()) {
        defs = parent.append('defs');
    }
    var patterns = defs.selectAll('.VCL-texture-pattern').data(data, function (d) { return d.scheme + d.index; });
    // remove old patterns
    patterns
        .exit()
        .transition()
        .duration(!transitionDisabled ? 750 : 0)
        .remove();
    // append new patterns
    var enter = patterns.enter().append('pattern');
    // update all existing patterns
    var update = patterns.merge(enter);
    update
        .each(function (d, i, n) {
        var patternAttributes = Object.keys(d.attributes);
        var me = d3Selection.select(n[i]);
        patternAttributes.forEach(function (attr) {
            me.attr(attr, d.attributes[attr]);
        });
    })
        .attr('patternContentUnits', 'userSpaceOnUse')
        .attr('x', 0)
        .attr('y', 0);
    var children = update.selectAll('.VCL-t-p-e').data(function (d) { return d.children; }, function (d, i) { return d.name + i; });
    // remove children that are a different type, by slot order
    children.exit().remove();
    // append new children, also according to slot order and type
    var enterChildren = children
        .enter()
        .append(function (d) {
        return document.createElementNS('http://www.w3.org/2000/svg', d.name);
    })
        .attr('class', 'VCL-t-p-e');
    // update all existing children
    var updateChildren = children.merge(enterChildren);
    updateChildren.each(function (d, i, n) {
        var me = d3Selection.select(n[i]);
        var childAttributes = Object.keys(d.attributes);
        childAttributes.forEach(function (attr) {
            me.attr(attr, d.attributes[attr]);
        });
    });
}
function convertColorsToTextures(_a) {
    var colors = _a.colors, rootSVG = _a.rootSVG, id = _a.id, scheme = _a.scheme, disableTransitions = _a.disableTransitions;
    var output = [];
    var textures = [];
    var i = 0;
    var colorArray = colors.range ? colors.range() : colors;
    // if (colorArray.length === 1) {
    //   output.push;
    // }
    // removePatterns(rootSVG);
    colorArray.forEach(function (color) {
        // we create a unique ID for each texture
        var textureId = id + '_texture_' + i;
        // get one color for the texture/stroke and one for the fill, depending on the scheme
        var contrastedColors = prepareStrokeColorsFromScheme(color, i, colorArray, scheme);
        // we retrieve the appropriate pattern data for the texture
        var texture = getTexture({
            scheme: contrastedColors.textureScheme,
            id: textureId,
            index: indices[contrastedColors.textureScheme][colors.length][i],
            fillColor: contrastedColors.fillColor,
            textureColor: contrastedColors.textureColor
        });
        // we append the pattern to the dom
        // appendPattern(rootSVG, texture);
        texture.scheme = contrastedColors.textureScheme;
        texture.index = indices[contrastedColors.textureScheme][colors.length][i];
        textures.push(texture);
        // we add the url to this pattern to our output array
        output.push(createUrl$1(textureId));
        i++;
    });
    runTextureLifecycle(rootSVG, textures, disableTransitions);
    // return array of "url(#[id])" strings for use in place of hex codes for element fills
    return output;
}
var prepareStrokeColorsFromScheme = function (color, i, colorArray, scheme) {
    // the sequential scheme colors are easiest, so they are default
    var fillColor = colorArray[0];
    var textureColor = colorArray[colorArray.length - 1];
    var textureScheme = scheme === 'categorical' || !scheme
        ? 'categorical'
        : scheme === 'sequential'
            ? 'sequential'
            : colorArray.length % 2
                ? 'diverging_center' // odd numbered scheme
                : 'diverging_split'; // even numbered scheme
    if (textureScheme === 'categorical') {
        // we calculate the appropriate stroke color for the texture
        textureColor = getContrastingStroke(color);
        fillColor = color;
    }
    else if (textureScheme !== 'sequential') {
        if (textureScheme.includes('center')) {
            // center diverging scheme
            var firstHalfIndex = (colorArray.length - 1) / 2 - 1;
            var middleIndex = firstHalfIndex + 1;
            var secondHalfIndex = middleIndex + 1;
            if (i <= firstHalfIndex) {
                textureColor = colorArray[0];
                fillColor = colorArray[firstHalfIndex];
            }
            else if (i >= secondHalfIndex) {
                textureColor = colorArray[colorArray.length - 1];
                fillColor = colorArray[secondHalfIndex];
            }
            else {
                // we calculate the appropriate stroke color for the texture
                textureColor = getContrastingStroke(color);
                fillColor = color;
            }
        }
        else {
            // split diverging scheme
            var topHalfIndex = colorArray.length / 2;
            if (i < topHalfIndex) {
                textureColor = colorArray[0];
                fillColor = colorArray[topHalfIndex - 1];
            }
            else {
                textureColor = colorArray[colorArray.length - 1];
                fillColor = colorArray[topHalfIndex];
            }
        }
    }
    return {
        fillColor: fillColor,
        textureColor: textureColor,
        textureScheme: textureScheme
    };
};
var removeFilters = function (root) {
    d3Selection.select(root)
        .selectAll('.VCL-accessibility-stroke-filter')
        .remove();
};
var createTextStrokeFilter = function (_a) {
    var root = _a.root, id = _a.id, color = _a.color, strokeSizeOverride = _a.strokeSizeOverride;
    var sanitizedColor = color[0] === '#' ? color.substr(1) : color;
    var s = ((strokeSizeOverride || '') + '').replace('.', 'p');
    var strokeClass = 'VCL-t-s-f-' + sanitizedColor + s;
    var strokeId = strokeClass + id + s;
    var filter = d3Selection.select(root).select('.' + strokeClass);
    if (!filter.size()) {
        // select(root).selectAll('VCL-text-stroke-filter').remove()
        var defs = d3Selection.select(root).select('defs');
        if (!defs.size()) {
            defs = d3Selection.select(root).append('defs');
        }
        filter = defs
            .append('filter')
            .attr('id', strokeId)
            .attr('class', strokeClass);
        filter
            .append('feMorphology')
            .attr('in', 'SourceAlpha')
            .attr('result', 'dilatedText')
            .attr('operator', 'dilate')
            .attr('radius', strokeSizeOverride || 1.5);
        filter
            .append('feFlood')
            .attr('flood-color', color || '#ffffff')
            .attr('flood-opacity', 1)
            .attr('result', 'whiteTextFlood');
        filter
            .append('feComposite')
            .attr('in', 'whiteTextFlood')
            .attr('in2', 'dilatedText')
            .attr('operator', 'in')
            .attr('result', 'textOutline');
        var merge = filter.append('feMerge');
        merge.append('feMergeNode').attr('in', 'textOutline');
        if (!strokeSizeOverride) {
            // this ensures that text (which use the default) will always have effective outlines
            merge.append('feMergeNode').attr('in', 'textOutline');
            merge.append('feMergeNode').attr('in', 'textOutline');
        }
        merge.append('feMergeNode').attr('in', 'SourceGraphic');
    }
    else {
        filter.attr('id', strokeId);
    }
    return createUrl$1(strokeId);
};
var createMultiStrokeFilter = function (_a) {
    var root = _a.root, id = _a.id, state = _a.state, fillColor = _a.fillColor, strokeWidth = _a.strokeWidth, forceStrokeColor = _a.forceStrokeColor, includeOuterStroke = _a.includeOuterStroke, strokeOnHover = _a.strokeOnHover, alwaysShowStroke = _a.alwaysShowStroke, stacked = _a.stacked;
    var rootDefs = d3Selection.select(root).select('defs');
    var strokes = getAccessibleStrokes(fillColor);
    // dark fills that are at rest don't need a stroke
    var primaryStroke = (state !== 'hover' || strokeOnHover) && (strokes.length === 1 || state === 'click') ? strokes[0] : fillColor;
    // cleanup is always the same as base fill
    var cleanupStroke = fillColor;
    // if there is an edge, use it - this is only for dark fills
    var edgeStroke = strokes[1] || '';
    // if we include outer stroke, it is always white
    var outerStroke = includeOuterStroke ? '#ffffff' : '';
    var filterId = 'VCL-filter-' + (primaryStroke[0] === '#' ? primaryStroke.substring(1) : primaryStroke) + '-' + state + '-' + id;
    if (rootDefs.select('#' + filterId).size()) {
        rootDefs.select('#' + filterId).remove();
    }
    var filter = rootDefs
        .append('filter')
        .attr('id', filterId)
        .attr('class', 'VCL-accessibility-stroke-filter');
    var data = createFilterData(state !== 'hover' && forceStrokeColor ? forceStrokeColor : primaryStroke, cleanupStroke, primaryStroke !== fillColor || state === 'hover' || alwaysShowStroke ? strokeWidth : 0, outerStroke, edgeStroke, !stacked ? 0 : 0.5);
    data.forEach(function (filterComposite) {
        filter
            .append('feMorphology')
            .attr('in', 'SourceAlpha')
            .attr('operator', filterComposite.operator)
            .attr('radius', filterComposite.radius)
            .attr('result', filterComposite.result
            ? filterComposite.result + '-morph'
            : 'morph-' + filterComposite.operator + '-' + filterComposite.radius);
        if (filterComposite.color) {
            filter
                .append('feFlood')
                .attr('flood-color', filterComposite.color)
                .attr('result', filterComposite.result + '-color');
        }
        filter
            .append('feComposite')
            .attr('in', filterComposite.result ? filterComposite.result + '-color' : 'SourceGraphic')
            .attr('in2', filterComposite.result
            ? filterComposite.result + '-morph'
            : 'morph-' + filterComposite.operator + '-' + filterComposite.radius)
            .attr('operator', 'in')
            .attr('result', filterComposite.result ? filterComposite.result + '-stroke' : 'fill');
    });
    var feMerge = filter.append('feMerge');
    data.forEach(function (filterComposite) {
        feMerge.append('feMergeNode').attr('in', filterComposite.result ? filterComposite.result + '-stroke' : 'fill');
    });
    return createUrl$1(filterId);
};
var createFilterData = function (primary, clean, strokeWidth, outside, edge, adjustForStack) {
    var output = [];
    var browser = getBrowser();
    var mod = browser !== 'IE' && browser !== 'Edge' ? 0 : 1;
    var strokeStart = browser !== 'Safari' ? mod : 0.1;
    if (outside) {
        output.push({
            color: outside,
            result: 'outside',
            operator: !adjustForStack ? 'dilate' : 'erode',
            radius: !adjustForStack ? 1 : 0
        });
    }
    if (edge) {
        strokeStart++;
        output.push({
            color: edge,
            result: 'edge',
            operator: 'erode',
            radius: mod + adjustForStack
        });
    }
    output.push({
        color: primary,
        result: 'primary',
        operator: 'erode',
        radius: strokeStart + adjustForStack
    });
    output.push({
        color: clean,
        result: 'clean',
        operator: 'erode',
        radius: strokeStart + strokeWidth + adjustForStack
    });
    output.push({
        operator: 'erode',
        radius: strokeStart + strokeWidth + 1 + adjustForStack
    });
    return output;
};
var removeHoverStrokes = function (root) {
    var className = 'vcl-accessibility-focus';
    d3Selection.select(root)
        .selectAll('.' + className + '-hoverSource')
        .classed(className + '-hoverSource', false);
    d3Selection.select(root)
        .selectAll('.' + className + '-hover')
        .remove();
};
var removeDuplicateStrokes = function (parent, id) {
    var root = d3Selection.select(parent.ownerSVGElement);
    root.selectAll('.vcl-accessibility-focus-hoverSource').classed('vcl-accessibility-focus-hoverSource', false);
    root.select('#VCL-clip-' + id).remove();
    root.select('#VCL-hover-stroke-' + id).remove();
    root.select('#VCL-buffer-stroke' + id).remove();
    root.select('#VCL-parent-' + id).remove();
};
var drawHoverStrokes = function (_a) {
    var inputElement = _a.inputElement, id = _a.id, key = _a.key, strokeWidth = _a.strokeWidth, fill = _a.fill, recursive = _a.recursive, strokeOverride = _a.strokeOverride;
    var strokes = getAccessibleStrokes(fill);
    var stroke = strokeOverride || strokes[0];
    var shouldBuffer = !!strokes[1];
    var uniqueElementId = createId(id, key);
    var source = inputElement.tagName !== 'DIV'
        ? inputElement
        : d3Selection.select(inputElement.parentNode)
            .select('svg')
            .node();
    var className = 'vcl-accessibility-focus';
    var shouldHideOutline = d3Selection.select(source)
        .style('outline')
        .includes('auto');
    if (shouldHideOutline) {
        d3Selection.select(source)
            .style('outline-width', '0px')
            .style('outline-offset', '0px')
            .style('outline-color', 'none');
    }
    var parent = source.parentNode;
    removeDuplicateStrokes(parent, uniqueElementId);
    d3Selection.select(source).classed(className + '-hoverSource', true);
    var dashedStrokeLayer = source.cloneNode(false);
    var darkElementBuffer = shouldBuffer ? source.cloneNode(false) : null;
    var clipPathElement = source.cloneNode(false);
    var clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    clipPath.appendChild(clipPathElement);
    if (!recursive) {
        var parentOfParent = parent.parentNode;
        var parentCopy = parent.cloneNode(false);
        var newParent = d3Selection.select(parentCopy).attr('id', 'VCL-parent-' + uniqueElementId);
        parentCopy.appendChild(clipPath);
        parentCopy.appendChild(dashedStrokeLayer);
        if (shouldBuffer) {
            parentCopy.appendChild(darkElementBuffer);
        }
        if (parent.nextSibling) {
            parentOfParent.insertBefore(parentCopy, parent.nextSibling);
        }
        else {
            parentOfParent.appendChild(parentCopy);
        }
        applyDefaults(newParent, className);
    }
    else {
        if (source.nextSibling) {
            if (shouldBuffer) {
                parent.insertBefore(darkElementBuffer, source.nextSibling);
            }
            parent.insertBefore(dashedStrokeLayer, source.nextSibling);
            parent.insertBefore(clipPath, source.nextSibling);
        }
        else {
            parent.appendChild(clipPath);
            parent.appendChild(dashedStrokeLayer);
            if (shouldBuffer) {
                parent.appendChild(darkElementBuffer);
            }
        }
    }
    var clipId = 'VCL-clip-' + uniqueElementId;
    var url = createUrl$1(clipId);
    d3Selection.select(clipPath)
        .attr('id', clipId)
        .attr('clipPathUnits', 'userSpaceOnUse')
        .attr('class', className + '-highlight ' + className + '-hover');
    var clip = d3Selection.select(clipPathElement)
        .attr('id', 'VCL-clip-element-' + uniqueElementId)
        .style('opacity', 1)
        .attr('opacity', 1);
    applyDefaults(clip, className);
    var strokeElement = d3Selection.select(dashedStrokeLayer)
        .attr('id', 'VCL-buffer-stroke-' + uniqueElementId)
        .style('opacity', 1)
        .attr('opacity', 1)
        .style('stroke', stroke);
    applyDefaults(strokeElement, className);
    applyOutlineOverride(strokeElement, strokeWidth, url, shouldBuffer, true);
    if (shouldBuffer) {
        var buffer = d3Selection.select(darkElementBuffer)
            .attr('id', 'VCL-buffer-stroke-' + uniqueElementId)
            .style('opacity', 1)
            .attr('opacity', 1)
            .style('stroke', fill);
        applyDefaults(buffer, className);
        applyOutlineOverride(buffer, 1, url, false, false);
    }
};
// this is currently unused, but will allow for future strokes to transition with a chart
// (rather than hiding during transition). See commented section in bar chart for use.
var mirrorStrokeTransition = function (_a) {
    var id = _a.id, key = _a.key, attribute = _a.attribute, newValue = _a.newValue, easing = _a.easing, duration = _a.duration;
    var baseId = createId(id, key);
    var layers = ['VCL-clip-element-', 'VCL-buffer-stroke-', 'VCL-buffer-stroke-'];
    layers.forEach(function (layer) {
        var targetId = '#' + layer + baseId;
        var target = d3Selection.select(targetId);
        if (target.size()) {
            if (duration) {
                target = target.transition(attribute).duration(duration);
                if (easing) {
                    target = target.ease(easing);
                }
            }
            target.attr(attribute, newValue);
        }
    });
};
var applyDefaults = function (selection, className) {
    selection
        .attr('class', className + '-highlight ' + className + '-hover')
        .attr('focusable', false)
        .attr('aria-label', null)
        .attr('aria-hidden', true)
        .attr('role', null)
        .style('pointer-events', 'none')
        .attr('tabindex', null)
        .attr('mix-blend-mode', null)
        .style('mix-blend-mode', null);
};
var applyOutlineOverride = function (selection, extraStrokeWidth, url, buffer, dash) {
    selection
        .style('stroke-linecap', 'butt')
        .style('outline-offset', '0px')
        .style('outline-color', 'none')
        .style('outline-width', '0px')
        .attr('fill', 'none')
        .style('fill', 'none')
        .style('stroke-opacity', 1)
        .attr('marker-start', null)
        .attr('marker-end', null)
        .attr('filter', null)
        .attr('stroke-dasharray', dash ? '8 6' : null)
        .attr('clip-path', url)
        .style('stroke-width', function (_, i, n) {
        var scaleIndex = d3Selection.select(n[i]).attr('transform')
            ? d3Selection.select(n[i])
                .attr('transform')
                .indexOf('scale')
            : -1;
        var scale = 1;
        if (scaleIndex > -1) {
            var scaleSubstring = d3Selection.select(n[i])
                .attr('transform')
                .substring(scaleIndex + 6);
            var endSubstring = scaleSubstring.indexOf(',') < scaleSubstring.indexOf(')') && scaleSubstring.indexOf(',') !== -1
                ? scaleSubstring.indexOf(',')
                : scaleSubstring.indexOf(')');
            scale = +scaleSubstring.substring(0, endSubstring);
        }
        return ((buffer ? 2 : 0) + extraStrokeWidth * 2) / scale + 'px';
    });
};
var createUrl$1 = function (id) {
    var path = window.location.pathname;
    if (path[path.length - 1] === '/') {
        path = path.substring(0, path.length - 1);
    }
    return ((!isSafari$1 ? 'url(#' : 'url(' + window.location.protocol + '//' + window.location.host + path + '#') + id + ')');
};
var createId = function (id, key) {
    var parsedKey = key instanceof Date ? key.getTime() : key;
    return id + '-' + (parsedKey + '').replace(/\W/g, '-');
};

var defaultHoverStrokeWidth = 2;
var defaultClickStrokeWidth = 2;
function checkInteraction(d, default_op, hover_op, hoverHighlight, clickHighlight, interactionKeys) {
    // data: d, default opacity: default_op, hover opacity: hover_op, hoverHighlight, clickHighlight, interactionKeys
    var elementOpacity = default_op === 0 ? 0 : hover_op;
    var matchClick = checkClicked(d, clickHighlight, interactionKeys);
    var matchHover = checkHovered(d, hoverHighlight, interactionKeys);
    if (matchHover || matchClick) {
        elementOpacity = default_op;
    }
    else if ((!hoverHighlight || matchHover) && (clickHighlight.length === 0 || matchClick)) {
        elementOpacity = default_op;
    }
    return elementOpacity;
}
function checkHovered(d, hoverHighlight, interactionKeys) {
    var matchHover = 0;
    if (hoverHighlight) {
        interactionKeys.map(function (key) {
            if (hoverHighlight[key] instanceof Date && d[key] instanceof Date) {
                if (hoverHighlight[key].getTime() === d[key].getTime()) {
                    matchHover++;
                }
            }
            else if (hoverHighlight[key] === d[key]) {
                matchHover++;
            }
        });
    }
    return interactionKeys && interactionKeys.length && matchHover === interactionKeys.length;
}
function checkClicked(d, clickHighlight, interactionKeys) {
    // first set flag to false by default
    var clickedCheck = false;
    // if we have clickHighlight and it has length then we need to check it
    if (clickHighlight && clickHighlight.length) {
        var _loop_1 = function (i) {
            // we are checking all keys fresh for each object in click highlight
            var matchedClick = 0;
            // now we need to check each key in interactionKeys, if we have a match with data increment matchedClick
            interactionKeys.map(function (key) {
                if (clickHighlight[i][key] instanceof Date && d[key] instanceof Date) {
                    if (clickHighlight[i][key].getTime() === d[key].getTime()) {
                        matchedClick++;
                    }
                }
                else if (clickHighlight[i][key] === d[key]) {
                    matchedClick++;
                }
            });
            // check whether all interactions keys matched, if so return true and immediately stop looping
            if (matchedClick === interactionKeys.length) {
                clickedCheck = true;
                return "break";
            }
        };
        // loop through each element in clickHighlight
        for (var i = 0; i < clickHighlight.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    }
    // return results back to component if we have interaction keys and interaction keys length
    return interactionKeys && interactionKeys.length && clickedCheck;
}
var buildStrokes = function (_a) {
    var root = _a.root, id = _a.id, colors = _a.colors, clickStyle = _a.clickStyle, hoverStyle = _a.hoverStyle, additionalStrokeSize = _a.additionalStrokeSize, strokeOnHover = _a.strokeOnHover, stacked = _a.stacked, strokeOverride = _a.strokeOverride;
    var strokes = {};
    var additionalStrokeExists = additionalStrokeSize || additionalStrokeSize === 0;
    var i = 0;
    colors.forEach(function (color) {
        var restSize = additionalStrokeExists ? additionalStrokeSize : 1;
        if (!strokes['rest' + color]) {
            strokes['rest' + color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'rest',
                fillColor: color,
                forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                strokeWidth: restSize,
                includeOuterStroke: true,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        if (additionalStrokeExists && !strokes['default' + color]) {
            strokes['default' + color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'default',
                fillColor: color,
                forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                strokeWidth: 1,
                includeOuterStroke: true,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        if (hoverStyle && hoverStyle.color && !strokes['hover' + hoverStyle.color]) {
            strokes['hover' + hoverStyle.color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'hover',
                fillColor: hoverStyle.color,
                strokeWidth: hoverStyle && hoverStyle.strokeWidth ? parseFloat(hoverStyle.strokeWidth) : defaultHoverStrokeWidth,
                includeOuterStroke: true,
                strokeOnHover: strokeOnHover,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        else {
            strokes['hover' + color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'hover',
                fillColor: color,
                forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                strokeWidth: hoverStyle && hoverStyle.strokeWidth ? parseFloat(hoverStyle.strokeWidth) : defaultHoverStrokeWidth,
                includeOuterStroke: true,
                strokeOnHover: strokeOnHover,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        if (clickStyle && clickStyle.color && !strokes['click' + clickStyle.color]) {
            strokes['click' + clickStyle.color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'click',
                fillColor: clickStyle.color,
                strokeWidth: clickStyle && clickStyle.strokeWidth ? parseFloat(clickStyle.strokeWidth) : defaultClickStrokeWidth,
                includeOuterStroke: true,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        else {
            strokes['click' + color] = createMultiStrokeFilter({
                root: root,
                id: id,
                state: 'click',
                fillColor: color,
                forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                strokeWidth: clickStyle && clickStyle.strokeWidth ? parseFloat(clickStyle.strokeWidth) : defaultClickStrokeWidth,
                includeOuterStroke: true,
                alwaysShowStroke: !!additionalStrokeExists,
                stacked: stacked
            });
        }
        i++;
    });
    return strokes;
};
var interactionStyle = function (_a) {
    var data = _a.data, clickHighlight = _a.clickHighlight, hoverHighlight = _a.hoverHighlight, clickStyle = _a.clickStyle, hoverStyle = _a.hoverStyle, interactionKeys = _a.interactionKeys, defaultStroke = _a.defaultStroke, defaultStrokeWidth = _a.defaultStrokeWidth, offset = _a.offset;
    var strokeColor = clickHighlight.length > 0 && checkClicked(data, clickHighlight, interactionKeys)
        ? defaultStroke
        : hoverHighlight && checkHovered(data, hoverHighlight, interactionKeys)
            ? defaultStroke
            : 'none';
    var strokeStyle = checkClicked(data, clickHighlight, interactionKeys) ? 'solid' : 'dashed';
    var strokeWidth = checkClicked(data, clickHighlight, interactionKeys)
        ? clickStyle.strokeWidth || defaultStrokeWidth
        : hoverHighlight && checkHovered(data, hoverHighlight, interactionKeys) && hoverStyle.strokeWidth
            ? hoverStyle.strokeWidth || defaultStrokeWidth
            : 0;
    if (typeof strokeWidth === 'string' && strokeWidth.includes('px')) {
        strokeWidth = parseInt(strokeWidth.substr(0, strokeWidth.indexOf('p')));
    }
    var strokeOffset = offset ? strokeWidth + offset : strokeWidth;
    // const strokeOffset = checkClicked(data, clickHighlight, interactionKeys) ? strokeWidth : strokeWidth + 2;
    return ("outline-color:" +
        strokeColor +
        ";\n        outline-style:" +
        strokeStyle +
        ";\n        outline-width:" +
        strokeWidth +
        "px;\n        outline-offset:-" +
        strokeOffset +
        "px;");
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function getTextWidth(text, fontSize, noPadding) {
    // this gets garbage collected after this function scope closes, since we do not append
    var padding = !noPadding ? 1.1 : 1; // for a11y we add padding, up to 10% of the text's dimensions
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.font = fontSize + 'px OpenSans'; //+ fontFace;
    return context.measureText(text).width * padding;
}
var verifyTextHasSpace = function (_a) {
    var text = _a.text, dimensions = _a.dimensions, fontSize = _a.fontSize, noPadding = _a.noPadding;
    // dimensions = { width: 97, height: 29 }
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.font = fontSize + 'px OpenSans';
    var measurementData = context.measureText(text);
    var padding = !noPadding ? 1.1 : 1; // for a11y we add padding, up to 10% of the text's dimensions
    var keys = Object.keys(dimensions);
    var textHasRoom = true;
    var i = 0;
    while (textHasRoom && i < keys.length) {
        if (!(keys[i] === 'height')) {
            textHasRoom = measurementData[keys[i]] * padding <= dimensions[keys[i]];
        }
        else {
            textHasRoom = fontSize * padding <= dimensions[keys[i]];
        }
        i++;
    }
    return textHasRoom;
};
var manuallyWrapText = function (_a) {
    var text = _a.text, width = _a.width, fontSize = _a.fontSize, noPadding = _a.noPadding, wholeWords = _a.wholeWords;
    // split into words
    var words = text.split(/\s+/).reverse();
    // turn words into lines
    var lines = [];
    var lineNumber = 0;
    var word = words.pop();
    while (word) {
        var line = lines[lineNumber];
        if (!line) {
            lines.push([]);
            line = lines[lineNumber];
        }
        // add current word to line
        line.push(word);
        var lineWidth = getTextWidth(line.join(' '), fontSize);
        // check if line has 1 word but is too long, if so:
        if (line.length === 1 && lineWidth > width) {
            // check if we aren't forcing whole words
            if (!wholeWords) {
                // if we aren't: split word, add hyphen, put split word ending at front of words array
                var splitWord = splitStringAtWidth(word, width, fontSize, noPadding);
                // remove whole word
                line.pop();
                // add first word plus hyphen
                line.push(splitWord[0] + (splitWord[1] ? '-' : ''));
                // use the second half of the word in the next iteration, if it exists
                if (splitWord[1]) {
                    word = splitWord[1];
                }
                else {
                    word = words.pop();
                }
            }
            else {
                // proceed with a line overlapping
                // prepare the next word for iteration
                word = words.pop();
            }
            // line is done, create single string
            lines[lineNumber] = line.join(' ');
            // start a new line
            lineNumber++;
        }
        else if (lineWidth > width) {
            // check if line is too long
            // - remove the word that just pushed the line over length
            line.pop();
            // line is done, create single string
            lines[lineNumber] = line.join(' ');
            // start a new line
            lineNumber++;
        }
        else {
            // prepare the next word for iteration
            word = words.pop();
            if (!word) {
                // no words left? line is done, create single string
                lines[lineNumber] = line.join(' ');
            }
        }
    }
    return lines;
};
var splitStringAtWidth = function (string, width, fontSize, noPadding) {
    if (string.length <= 1) {
        return [string, ''];
    }
    var index = string.length - 1;
    var start = string.substring(0, index);
    var end = string.substring(index);
    while (getTextWidth(start + '-', fontSize, noPadding) > width && index > 1) {
        index--;
        start = string.substring(0, index);
        end = string.substring(index);
    }
    return [start, end];
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var tickArguments = [];
var tickValues = null;
var duration = 750;
var orient = 1;
var tickFormat = null;
var tickSizeInner = 6;
var tickSizeOuter = 6;
var tickPadding = 3;
var xOffset = 0;
var yOffset = 0;
var tickWidth = 0;
var scale;
var hideAxisPath;
var k = 1;
var x = 'x';
var transform = translateX;
var orientTop = 1;
var orientRight = 2;
var orientBottom = 3;
var orientLeft = 4;
var epsilon = 1e-6;
var drawAxis = function (_a) {
    var root = _a.root, height = _a.height, width = _a.width, axisScale = _a.axisScale, left = _a.left, right = _a.right, top = _a.top, wrapLabel = _a.wrapLabel, format = _a.format, dateFormat = _a.dateFormat, tickInterval = _a.tickInterval, label = _a.label, padding = _a.padding, hide = _a.hide, markOffset = _a.markOffset, hidePath = _a.hidePath, ticks = _a.ticks;
    scale = axisScale;
    hideAxisPath = hidePath;
    tickValues = ticks ? ticks : null;
    var opacity = 1;
    if (hide) {
        opacity = 0;
    }
    tickWidth = wrapLabel ? wrapLabel : 0;
    if (markOffset) {
        // mark line at x=0
        if (left) {
            var axisBase = root.selectAll('.axis-mark-y');
            if (axisBase.empty()) {
                duration = 0;
                axisBase = root.append('g').attr('class', 'axis-mark-y axis-mark');
            }
            tickFormat = function () { return null; };
            orient = orientLeft;
            setOrientation();
            axisBase
                .attr('data-testid', 'y-axis-mark')
                .transition('axis_base')
                .attr('transform', markOffset > 0 ? "translate(" + markOffset + ", 0)" : '')
                .ease(d3Ease.easeCircleIn)
                .duration(duration)
                .attr('transform', markOffset > 0 ? "translate(" + markOffset + ", 0)" : '')
                .attr('opacity', opacity)
                .call(axis);
        }
        else {
            // mark line at y=0
            var axisBase = root.selectAll('.axis-mark-x');
            if (axisBase.empty()) {
                duration = 0;
                axisBase = root.append('g');
            }
            tickFormat = function () { return null; };
            orient = orientBottom;
            setOrientation();
            axisBase
                .attr('class', 'axis-mark-x axis-mark')
                .attr('data-testid', 'x-axis-mark')
                .transition('axis_base')
                .ease(d3Ease.easeCircleIn)
                .duration(duration)
                .attr('transform', markOffset > 0 ? "translate(0, " + markOffset + ")" : '')
                .attr('opacity', opacity)
                .call(axis);
        }
    }
    else if (left) {
        // left y axis
        var axisNode = root
            .selectAll('.axis')
            .filter('.y')
            .filter('.left');
        var axisLabel = root
            .selectAll('.axis-label')
            .filter('.y')
            .filter('.left');
        if (axisNode.empty()) {
            duration = 0;
            axisNode = root.append('g');
            axisLabel = root.append('text');
        }
        tickFormat = function (data, i) {
            if (tickInterval && i % tickInterval !== 0) {
                return null;
            }
            else if (format && typeof data === 'number') {
                return formatStats(data, format);
            }
            else if (data instanceof Date) {
                var formatTime = d3TimeFormat.timeFormat(dateFormat);
                return formatTime(data);
            }
            else {
                return data;
            }
        };
        tickSizeInner = 0;
        tickSizeOuter = 0;
        tickPadding = 10;
        if (tickWidth) {
            xOffset = -8;
            yOffset = 0.6;
        }
        orient = orientLeft;
        setOrientation();
        axisNode
            .attr('class', 'y axis left')
            .attr('data-testid', 'y-axis')
            .transition('axis_node')
            .ease(d3Ease.easeCircleIn)
            .duration(duration)
            .attr('opacity', opacity)
            .call(axis);
        axisLabel
            .attr('class', 'y axis-label left')
            .attr('data-testid', 'y-axis-label')
            .attr('transform', "rotate(-90)")
            .text(label)
            .transition('axis_label')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('y', padding ? 0 - padding.left : -50)
            .attr('x', 0 - height / 2)
            .attr('dy', '1em');
        // .attr("opacity",opacity);
    }
    else if (right) {
        // right y axis
        var axisNode = root
            .selectAll('.axis')
            .filter('.y')
            .filter('.right');
        var axisLabel = root
            .selectAll('.axis-label')
            .filter('.y')
            .filter('.right');
        if (axisNode.empty()) {
            duration = 0;
            axisNode = root.append('g');
            axisLabel = root.append('text');
        }
        tickFormat = function (data, i) {
            if (tickInterval && i % tickInterval !== 0) {
                return null;
            }
            else if (format && typeof data === 'number') {
                return formatStats(data, format);
            }
            else if (data instanceof Date) {
                var formatTime = d3TimeFormat.timeFormat(dateFormat);
                return formatTime(data);
            }
            else {
                return data;
            }
        };
        tickSizeInner = 0;
        tickSizeOuter = 0;
        tickPadding = 10;
        if (tickWidth) {
            xOffset = 8;
            yOffset = 0.6;
        }
        orient = orientRight;
        setOrientation();
        axisNode
            .attr('class', 'y axis right')
            .attr('data-testid', 'sec-y-axis')
            .transition('axis_node')
            .ease(d3Ease.easeCircleIn)
            .duration(duration)
            .attr('transform', "translate(" + width + ",0)")
            .attr('opacity', opacity)
            .call(axis);
        axisLabel
            .attr('class', 'y axis-label right')
            .attr('data-testid', 'sec-y-axis-label')
            .attr('transform', "rotate(-90)")
            .text(label || 'Cumulative Percentage')
            .transition('axis_label')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('y', padding ? width + padding.left + padding.right - 50 : width - 50)
            .attr('x', 0 - height / 2)
            .attr('dy', '1em');
        // .attr("opacity",opacity);
    }
    else if (top) {
        // x axis on top
        var axisNode = root
            .selectAll('.axis')
            .filter('.x')
            .filter('.top');
        var axisLabel = root
            .selectAll('.axis-label')
            .filter('.x')
            .filter('.top');
        if (axisNode.empty()) {
            duration = 0;
            axisNode = root.append('g');
            axisLabel = root.append('text');
        }
        tickFormat = function (data, i) {
            if (tickInterval && i % tickInterval !== 0) {
                return null;
            }
            else if (format && typeof data === 'number') {
                return formatStats(data, format);
            }
            else if (data instanceof Date) {
                var formatTime = d3TimeFormat.timeFormat(dateFormat);
                return formatTime(data);
            }
            else {
                return data;
            }
        };
        tickSizeInner = 0;
        tickSizeOuter = 0;
        tickPadding = 10;
        if (tickWidth) {
            xOffset = 0;
            yOffset = 1;
        }
        orient = orientTop;
        setOrientation();
        axisNode
            .attr('class', 'x axis top')
            .attr('data-testid', 'sec-x-axis')
            .transition('axis_node')
            .ease(d3Ease.easeCircleIn)
            .duration(duration)
            .attr('transform', "translate(0, 0)")
            .attr('opacity', opacity)
            .call(axis);
        axisLabel
            .attr('class', 'x axis-label top')
            .attr('data-testid', 'sec-x-axis-label')
            .attr('transform', "translate(0, 0)")
            .text(format && typeof label === 'number' ? formatStats(label, format) : label)
            .transition('axis_label')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('x', width / 2)
            .attr('y', padding ? -padding.top : -50)
            .attr('dy', '1em');
        // .attr("opacity",opacity);
    }
    else {
        // x axis at bottom
        var axisNode = root
            .selectAll('.axis')
            .filter('.x')
            .filter('.bottom');
        var axisLabel = root
            .selectAll('.axis-label')
            .filter('.x')
            .filter('.bottom');
        if (axisNode.empty()) {
            duration = 0;
            axisNode = root.append('g');
            axisLabel = root.append('text');
        }
        tickFormat = function (data, i) {
            if (tickInterval && i % tickInterval !== 0) {
                return null;
            }
            else if (format && typeof data === 'number') {
                return formatStats(data, format);
            }
            else if (data instanceof Date) {
                var formatTime = d3TimeFormat.timeFormat(dateFormat);
                return formatTime(data);
            }
            else {
                return data;
            }
        };
        tickSizeInner = 0;
        tickSizeOuter = 0;
        tickPadding = 10;
        if (tickWidth) {
            xOffset = 0;
            yOffset = 1;
        }
        orient = orientBottom;
        setOrientation();
        axisNode
            .attr('class', 'x axis bottom')
            .attr('data-testid', 'x-axis')
            .transition('axis_node')
            .ease(d3Ease.easeCircleIn)
            .duration(duration)
            .attr('transform', "translate(0, " + height + ")")
            .attr('opacity', opacity)
            .call(axis);
        axisLabel
            .attr('class', 'x axis-label bottom')
            .attr('data-testid', 'x-axis-label')
            .attr('transform', "translate(0, 0)")
            .text(format && typeof label === 'number' ? formatStats(label, format) : label)
            .transition('axis_label')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('x', width / 2)
            .attr('y', padding ? height + padding.bottom : height);
        // .attr("opacity",opacity);
    }
    duration = 750;
};
function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues;
    var format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat;
    var spacing = Math.max(tickSizeInner, 0) + tickPadding;
    var range = scale.range();
    var range0 = +range[0] + 0.5;
    var range1 = +range[range.length - 1] + 0.5;
    var position = (scale.bandwidth ? center : number)(scale.copy());
    var selection = context.selection ? context.selection() : context;
    var path = selection.selectAll('.domain').data([null]);
    var tick = selection
        .selectAll('.tick')
        .data(values, scale)
        .order();
    var tickExit = tick.exit();
    var tickEnter = tick
        .enter()
        .append('g')
        .attr('class', 'tick')
        .attr('data-testid', 'axis-tick');
    var line = tick.select('line');
    var text = tick.select('text');
    path = path.merge(path
        .enter()
        .insert('path', '.tick')
        .attr('class', 'domain')
        .attr('stroke', 'currentColor'));
    selection.selectAll('.domain').attr('class', hideAxisPath ? 'domain hidden' : 'domain');
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter
        .append('line')
        .attr('data-testid', 'axis-tick-line')
        .attr('stroke', 'currentColor')
        .attr(x + '2', k * tickSizeInner));
    if (!scale.formattedTicks) {
        scale.formattedTicks = [];
    }
    text = text
        .merge(tickEnter
        .append('text')
        .attr('data-testid', 'axis-tick-text')
        .attr('fill', 'currentColor')
        .attr(x, k * spacing)
        .attr('dy', orient === orientTop ? '0em' : orient === orientBottom ? '0.71em' : '0.32em'))
        .text(function (d, i) {
        if (format(d, i)) {
            scale.formattedTicks.push(format(d, i));
        }
        return format(d, i);
    });
    if (tickWidth > 0) {
        text.call(wrap);
    }
    if (context !== selection) {
        path = path
            .transition(context)
            .duration(duration)
            .ease(d3Ease.easeCircleIn);
        tick = tick
            .transition(context)
            .duration(duration)
            .ease(d3Ease.easeCircleIn);
        line = line
            .transition(context)
            .duration(duration)
            .ease(d3Ease.easeCircleIn);
        text = text
            .transition(context)
            .duration(duration)
            .ease(d3Ease.easeCircleIn);
        tickExit = tickExit
            .transition(context)
            .attr('opacity', epsilon)
            .attr('transform', function (d) {
            return isFinite((d = position(d))) ? transform(d) : this.getAttribute('transform');
        });
        tickEnter.attr('opacity', epsilon).attr('transform', function (d) {
            var p = this.parentNode.__axis;
            return transform(p && isFinite((p = p(d))) ? p : position(d));
        });
    }
    tickExit.remove();
    path.attr('d', orient === orientLeft || orient === orientRight
        ? tickSizeOuter
            ? 'M' + k * tickSizeOuter + ',' + range0 + 'H0.5V' + range1 + 'H' + k * tickSizeOuter
            : 'M0.5,' + range0 + 'V' + range1
        : tickSizeOuter
            ? 'M' + range0 + ',' + k * tickSizeOuter + 'V0.5H' + range1 + 'V' + k * tickSizeOuter
            : 'M' + range0 + ',0.5H' + range1);
    tick.attr('opacity', 1).attr('transform', function (d) { return transform(position(d)); });
    line.attr(x + '2', k * tickSizeInner);
    text.attr(x, k * spacing);
    selection
        .filter(entering)
        .attr('fill', 'none')
        .attr('font-size', 10)
        .attr('font-family', 'sans-serif')
        .attr('text-anchor', orient === orientRight ? 'start' : orient === orientLeft ? 'end' : 'middle');
    selection.each(function () {
        this.__axis = position;
    });
}
function wrap(selection) {
    selection.each(function () {
        var text = d3Selection.select(this);
        var words = manuallyWrapText({
            text: text.text(),
            width: tickWidth,
            fontSize: 12,
            noPadding: false,
            wholeWords: false
        });
        var lineHeight = yOffset; // ems
        var lineNumber = 0;
        var y = text.attr('y');
        var dy = parseFloat(text.attr('dy'));
        text.text(null);
        words.forEach(function (word) {
            text
                .append('tspan')
                .attr('data-testid', 'axis-tick-text-tspan')
                .attr('x', xOffset)
                .attr('y', y)
                .attr('dy', lineNumber * lineHeight + dy + 'em')
                .text(word);
            lineNumber++;
        });
    });
}
function setOrientation() {
    k = orient === orientTop || orient === orientLeft ? -1 : 1;
    x = orient === orientLeft || orient === orientRight ? 'x' : 'y';
    transform = orient === orientTop || orient === orientBottom ? translateX : translateY;
}
function identity(id) {
    return id;
}
function translateX(xPos) {
    return 'translate(' + (xPos + 0.5) + ',0)';
}
function translateY(yPos) {
    return 'translate(0,' + (yPos + 0.5) + ')';
}
function number(scaleFunction) {
    return function (d) {
        return +scaleFunction(d);
    };
}
function center(scaleFunction) {
    var offset = Math.max(0, scaleFunction.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scaleFunction.round()) {
        offset = Math.round(offset);
    }
    return function (d) {
        return +scaleFunction(d) + offset;
    };
}
function entering() {
    return !this.__axis;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var drawGrid = function (root, height, width, axis, left, hide, tickInterval) {
    var duration = 750;
    var opacity = 1;
    if (hide) {
        opacity = 0;
    }
    if (left) {
        var grid = root.selectAll('.grid').filter('.left');
        if (!grid.node()) {
            duration = 0;
            grid = root
                .append('g')
                .attr('class', 'grid left')
                .attr('data-testid', 'grid-left');
        }
        grid
            .transition('grid-left-update')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('opacity', opacity)
            .call(d3Axis.axisLeft(axis)
            .tickSize(-width)
            .tickFormat('')
            .tickValues((axis.ticks ? axis.ticks() : axis.domain()).filter(function (_, i) { return !(tickInterval && i % tickInterval !== 0); })));
    }
    else {
        var grid = root.selectAll('.grid').filter('.bottom');
        if (!grid.node()) {
            duration = 0;
            grid = root
                .append('g')
                .attr('class', 'grid bottom')
                .attr('data-testid', 'grid-bottom');
        }
        grid
            .transition('grid-bottom-update')
            .duration(duration)
            .ease(d3Ease.easeCircleIn)
            .attr('opacity', opacity)
            .call(d3Axis.axisBottom(axis)
            .tickSize(height)
            .tickFormat('')
            .tickValues((axis.ticks ? axis.ticks() : axis.domain()).filter(function (_, i) { return !(tickInterval && i % tickInterval !== 0); })));
    }
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var baseSymbols = {
    /*13*/ cross: 'M-1.0606601717798214,-0.3535533905932738L-0.3535533905932738,-0.3535533905932738L-0.3535533905932738,-1.0606601717798214L0.3535533905932738,-1.0606601717798214L0.3535533905932738,-0.3535533905932738L1.0606601717798214,-0.3535533905932738L1.0606601717798214,0.3535533905932738L0.3535533905932738,0.3535533905932738L0.3535533905932738,1.0606601717798214L-0.3535533905932738,1.0606601717798214L-0.3535533905932738,0.3535533905932738L-1.0606601717798214,0.3535533905932738Z',
    /*14*/ circle: 'M1,0A1,1,0,1,1,-1,0A1,1,0,1,1,1,0',
    /*2*/ square: 'M-0.9219544457292888,-0.9219544457292888h1.8439088914585775v1.8439088914585775h-1.8439088914585775Z',
    /*11*/ star: 'M0,-1.4621735258409942L0.3282784098583098,-0.4518364682100035L1.3906096597053377,-0.4518364682100036L0.5311656249235138,0.17258617349950994L0.859444034781824,1.1829232311305005L1.1102230246251565e-16,0.5585005894209871L-0.8594440347818236,1.1829232311305007L-0.5311656249235137,0.17258617349951003L-1.390609659705338,-0.4518364682100033L-0.3282784098583099,-0.4518364682100034Z',
    /*4*/ triangle: 'M0,-1.330616708716245L1.1523478724483067,0.6653083543581225L-1.1523478724483067,0.6653083543581225Z',
    /*5*/ diamond: 'M0,-1.4416868484808527L0.8323582900575635,0L0,1.4416868484808527L-0.8323582900575635,0Z'
};
var generalizedSymbols = {
    cross: 'M-1.0606601238250732,-0.3535534143447876L-0.919238805770874,-0.3535534143447876L-0.7778174877166748,-0.3535534143447876L-0.6363961100578308,-0.3535534143447876L-0.4949747920036316,-0.3535534143447876L-0.3535534739494324,-0.3535534143447876L-0.3535533845424652,-0.4949747323989868L-0.3535533845424652,-0.636396050453186L-0.3535534143447876,-0.7778173685073853L-0.3535534143447876,-0.9192386865615845L-0.3535534143447876,-1.0606600046157837L-0.21213221549987793,-1.0606601238250732L-0.07071077823638916,-1.0606601238250732L0.07071053981781006,-1.0606601238250732L0.21213185787200928,-1.0606601238250732L0.3535531759262085,-1.0606601238250732L0.35355344414711,-0.9192389249801636L0.35355344414711,-0.7778176069259644L0.3535534143447876,-0.6363962888717651L0.3535534143447876,-0.4949749708175659L0.3535534143447876,-0.3535536527633667L0.49497461318969727,-0.3535534143447876L0.6363959312438965,-0.3535534143447876L0.7778174877166748,-0.3535534143447876L0.919238805770874,-0.3535534143447876L1.0606601238250732,-0.3535534143447876L1.0606601238250732,-0.21213233470916748L1.0606601238250732,-0.07071101665496826L1.0606601238250732,0.07071030139923096L1.0606601238250732,0.21213161945343018L1.0606601238250732,0.3535529375076294L0.9192391633987427,0.35355332493782043L0.7778178453445435,0.3535533547401428L0.6363965272903442,0.3535533845424652L0.494975209236145,0.3535533845424652L0.3535538911819458,0.3535534143447876L0.35355344414711,0.49497437477111816L0.35355344414711,0.6363956928253174L0.3535534143447876,0.7778170108795166L0.3535534143447876,0.9192383289337158L0.3535534143447876,1.060659646987915L0.21213233470916748,1.0606600046157837L0.07071101665496826,1.0606600046157837L-0.07071030139923096,1.0606601238250732L-0.21213161945343018,1.0606601238250732L-0.3535529375076294,1.0606601238250732L-0.3535533845424652,0.9192386865615845L-0.3535533845424652,0.7778173685073853L-0.3535534143447876,0.636396050453186L-0.3535534143447876,0.4949747323989868L-0.3535534143447876,0.3535534143447876L-0.49497485160827637,0.35355332493782043L-0.6363961696624756,0.3535533547401428L-0.7778174877166748,0.3535533845424652L-0.919238805770874,0.3535533845424652L-1.0606601238250732,0.3535534143447876L-1.0606601238250732,0.21213185787200928L-1.0606601238250732,0.07071053981781006L-1.0606601238250732,-0.07071077823638916L-1.0606601238250732,-0.21213209629058838Z',
    circle: 'M1,0L0.9952487945556641,0.10496900230646133L0.9802308678627014,0.20940586924552917L0.9531400799751282,0.31073155999183655L0.9148818850517273,0.4079720079898834L0.8663365244865417,0.5002545714378357L0.8094649910926819,0.5883480906486511L0.743568480014801,0.6698152422904968L0.6695123314857483,0.7439088225364685L0.5881620049476624,0.8099220395088196L0.5004010796546936,0.867180347442627L0.4069012701511383,0.9140697717666626L0.30910128355026245,0.9513185620307922L0.2079721838235855,0.9784069061279297L0.10456041246652603,0.9948219656944275L9.057112038135529e-8,1L-0.10454819351434708,0.994599461555481L-0.20796485245227814,0.9783451557159424L-0.30910056829452515,0.9513131976127625L-0.40682557225227356,0.9137774109840393L-0.5000651478767395,0.8661796450614929L-0.5878113508224487,0.8090839982032776L-0.6691301465034485,0.7431550621986389L-0.7431550025939941,0.6691302061080933L-0.8090841770172119,0.5878111720085144L-0.8661795258522034,0.5000653266906738L-0.9137775301933289,0.4068255126476288L-0.9513131976127625,0.30910077691078186L-0.9783450961112976,0.20796531438827515L-0.994599461555481,0.10454835742712021L-1,1.5099580252808664e-7L-0.9952487945556641,-0.1049688383936882L-0.9802308082580566,-0.2094057947397232L-0.953140139579773,-0.3107314109802246L-0.9148820638656616,-0.4079718291759491L-0.8663367629051208,-0.5002543926239014L-0.8094651103019714,-0.5883479714393616L-0.7435685396194458,-0.6698151230812073L-0.6695123314857483,-0.7439088225364685L-0.5881620645523071,-0.8099220395088196L-0.5004012584686279,-0.867180347442627L-0.4069012701511383,-0.9140697717666626L-0.30910128355026245,-0.9513185620307922L-0.20797239243984222,-0.9784069061279297L-0.10456059128046036,-0.9948219656944275L-3.026798367500305e-9,-1L0.10454817116260529,-0.994599461555481L0.2079651653766632,-0.9783450961112976L0.30910080671310425,-0.9513131380081177L0.4068260192871094,-0.913777232170105L0.5000655055046082,-0.8661794066429138L0.587811291217804,-0.8090839982032776L0.6691306233406067,-0.7431545853614807L0.7431554198265076,-0.6691297292709351L0.8090841770172119,-0.5878111124038696L0.866179883480072,-0.5000647306442261L0.9137775301933289,-0.4068252444267273L0.9513131976127625,-0.309100478887558L0.9783451557159424,-0.20796477794647217L0.9945995211601257,-0.10454780608415604Z',
    square: 'M-0.9219544529914856,-0.9219544529914856L-0.799027144908905,-0.9219544529914856L-0.676099956035614,-0.9219544529914856L-0.5531726479530334,-0.9219544529914856L-0.4302453398704529,-0.9219544529914856L-0.30731815099716187,-0.9219544529914856L-0.18439096212387085,-0.9219544529914856L-0.06146365404129028,-0.9219544529914856L0.06146365404129028,-0.9219544529914856L0.1843908429145813,-0.9219544529914856L0.30731815099716187,-0.9219544529914856L0.43024545907974243,-0.9219544529914856L0.5531726479530334,-0.9219544529914856L0.676099956035614,-0.9219544529914856L0.799027144908905,-0.9219544529914856L0.9219544529914856,-0.9219544529914856L0.9219545125961304,-0.799027144908905L0.9219545125961304,-0.676099956035614L0.9219545125961304,-0.553172767162323L0.9219545125961304,-0.4302453398704529L0.9219545125961304,-0.30731815099716187L0.9219545125961304,-0.18439096212387085L0.9219545125961304,-0.06146353483200073L0.9219545125961304,0.06146365404129028L0.9219545125961304,0.1843908429145813L0.9219544529914856,0.3073182702064514L0.9219544529914856,0.43024545907974243L0.9219544529914856,0.5531726479530334L0.9219544529914856,0.6760998368263245L0.9219544529914856,0.7990272641181946L0.9219544529914856,0.9219544529914856L0.7990273833274841,0.9219542145729065L0.676099956035614,0.9219542145729065L0.553172767162323,0.9219542145729065L0.430245578289032,0.9219542741775513L0.30731838941574097,0.9219542741775513L0.18439120054244995,0.9219542741775513L0.06146353483200073,0.921954333782196L-0.06146365404129028,0.921954333782196L-0.1843908429145813,0.921954333782196L-0.3073180317878723,0.921954333782196L-0.43024522066116333,0.9219543933868408L-0.5531724095344543,0.9219543933868408L-0.6760995984077454,0.9219543933868408L-0.7990272641181946,0.9219544529914856L-0.9219544529914856,0.9219544529914856L-0.9219543933868408,0.799027144908905L-0.9219543933868408,0.676099956035614L-0.9219543933868408,0.553172767162323L-0.9219543933868408,0.430245578289032L-0.9219543933868408,0.30731791257858276L-0.9219543933868408,0.18439072370529175L-0.9219543933868408,0.06146353483200073L-0.9219543933868408,-0.06146365404129028L-0.9219543933868408,-0.1843908429145813L-0.9219544529914856,-0.3073180317878723L-0.9219544529914856,-0.43024522066116333L-0.9219544529914856,-0.5531728863716125L-0.9219544529914856,-0.6761000752449036L-0.9219544529914856,-0.7990272641181946Z',
    star: 'M0,-1.462173581123352L0.05471307039260864,-1.2937841415405273L0.1094261109828949,-1.125394582748413L0.16413918137550354,-0.9570050239562988L0.21885225176811218,-0.7886155843734741L0.2735653221607208,-0.6202260255813599L0.32827839255332947,-0.4518364667892456L0.505333662033081,-0.4518364667892456L0.6823887825012207,-0.4518364667892456L0.8594440221786499,-0.4518364667892456L1.036499261856079,-0.4518364667892456L1.2135545015335083,-0.4518364667892456L1.3906097412109375,-0.4518364667892456L1.2473692893981934,-0.34776610136032104L1.104128360748291,-0.24369558691978455L0.9608877897262573,-0.13962522149085999L0.8176472187042236,-0.03555482625961304L0.6744064092636108,0.06851568818092346L0.5311657786369324,0.17258606851100922L0.5858786702156067,0.34097564220428467L0.6405917406082153,0.5093650817871094L0.6953047513961792,0.6777544617652893L0.7500178813934326,0.8461441397666931L0.8047309517860413,1.014533519744873L0.8594440817832947,1.1829231977462769L0.7162032723426819,1.078852653503418L0.5729628205299377,0.9747823476791382L0.42972204089164734,0.8707118630409241L0.28648123145103455,0.76664137840271L0.1432408094406128,0.6625710725784302L1.1102230246251565e-16,0.5585005879402161L-0.1432408094406128,0.6625711917877197L-0.28648126125335693,0.76664137840271L-0.42972204089164734,0.8707119226455688L-0.5729628801345825,0.9747824668884277L-0.7162032723426819,1.078852653503418L-0.8594440817832947,1.1829231977462769L-0.8047309517860413,1.014533519744873L-0.7500178217887878,0.846143901348114L-0.695304811000824,0.6777547001838684L-0.6405916810035706,0.5093650817871094L-0.5858786106109619,0.34097540378570557L-0.531165599822998,0.17258620262145996L-0.674406111240387,0.0685158371925354L-0.8176469206809998,-0.0355546772480011L-0.9608873128890991,-0.1396249234676361L-1.104128122329712,-0.2436954379081726L-1.2473689317703247,-0.3477659523487091L-1.3906097412109375,-0.4518364667892456L-1.2135542631149292,-0.4518364667892456L-1.0364998579025269,-0.4518364667892456L-0.8594444990158081,-0.4518364667892456L-0.6823891401290894,-0.4518364667892456L-0.5053337812423706,-0.4518364667892456L-0.32827839255332947,-0.4518364667892456L-0.27356526255607605,-0.6202262043952942L-0.21885214745998383,-0.788615882396698L-0.16413933038711548,-0.9570046067237854L-0.10942622274160385,-1.1253942251205444L-0.054713111370801926,-1.2937839031219482Z',
    triangle: 'M0,-1.3306167125701904L0.05761754512786865,-1.2308205366134644L0.1152348518371582,-1.1310244798660278L0.17285221815109253,-1.0312281847000122L0.23046964406967163,-0.9314318895339966L0.28808706998825073,-0.8316354751586914L0.34570443630218506,-0.7318392992019653L0.4033218026161194,-0.6320431232452393L0.4609392285346985,-0.5322468280792236L0.5185565948486328,-0.432450532913208L0.5761740207672119,-0.33265429735183716L0.6337913870811462,-0.2328580617904663L0.6914087533950806,-0.13306176662445068L0.7490261793136597,-0.033265531063079834L0.8066436052322388,0.06653076410293579L0.8642609119415283,0.16632699966430664L0.9218782782554626,0.2661232054233551L0.9794957041740417,0.3659195303916931L1.037113070487976,0.4657157063484192L1.0947304964065552,0.5655120611190796L1.1523479223251343,0.6653083562850952L1.0371133089065552,0.6653079986572266L0.921878457069397,0.6653080582618713L0.8066436052322388,0.6653080582618713L0.6914087533950806,0.6653080582618713L0.5761741399765015,0.6653081178665161L0.46093928813934326,0.6653081178665161L0.34570443630218506,0.6653081178665161L0.23046958446502686,0.6653081178665161L0.11523497104644775,0.6653081774711609L1.1920928955078125e-7,0.6653081774711609L-0.11523473262786865,0.6653081774711609L-0.23046934604644775,0.6653082370758057L-0.34570419788360596,0.6653082370758057L-0.46093904972076416,0.6653082370758057L-0.5761736631393433,0.6653082966804504L-0.6914085149765015,0.6653082966804504L-0.8066433668136597,0.6653082966804504L-0.9218782186508179,0.6653082966804504L-1.037113070487976,0.6653083562850952L-1.1523479223251343,0.6653083562850952L-1.094730257987976,0.5655120611190796L-1.037113070487976,0.4657161235809326L-0.9794957041740417,0.365919828414917L-0.9218782782554626,0.26612353324890137L-0.8642608523368835,0.1663271188735962L-0.8066434264183044,0.06653082370758057L-0.7490260004997253,-0.03326547145843506L-0.6914085745811462,-0.13306176662445068L-0.6337913870811462,-0.23285770416259766L-0.5761739611625671,-0.3326539993286133L-0.518556535243988,-0.4324502944946289L-0.4609391391277313,-0.5322465896606445L-0.4033217132091522,-0.6320429444313049L-0.3457042872905731,-0.7318392395973206L-0.288086861371994,-0.831635594367981L-0.2304694503545761,-0.9314318895339966L-0.1728522628545761,-1.0312278270721436L-0.1152348443865776,-1.1310241222381592L-0.0576174221932888,-1.2308204174041748Z',
    diamond: 'M0,-1.4416868686676025L0.05549061298370361,-1.3455744981765747L0.11098116636276245,-1.2494620084762573L0.1664717197418213,-1.15334951877594L0.22196227312088013,-1.057237148284912L0.27745282649993896,-0.96112459897995L0.3329433500766754,-0.8650121688842773L0.38843390345573425,-0.76889967918396L0.4439244568347931,-0.6727872490882874L0.49941501021385193,-0.57667475938797L0.5549055337905884,-0.480562299489975L0.6103960871696472,-0.38444983959198L0.665886640548706,-0.288337379693985L0.7213771939277649,-0.19222491979599L0.7768677473068237,-0.096112459897995L0.8323583006858826,0L0.7768678665161133,0.09611248970031738L0.7213772535324097,0.19222497940063477L0.6658867001533508,0.2883373498916626L0.6103960871696472,0.38444995880126953L0.5549055933952332,0.48056232929229736L0.4994150996208191,0.5766746401786804L0.4439244866371155,0.6727872490882874L0.38843387365341187,0.7688997983932495L0.3329433500766754,0.8650121092796326L0.27745285630226135,0.9611244797706604L0.22196224331855774,1.0572370290756226L0.16647161543369293,1.1533496379852295L0.11098112165927887,1.2494620084762573L0.05549062043428421,1.3455742597579956L0,1.4416868686676025L-0.05549055337905884,1.345574140548706L-0.11098110675811768,1.2494617700576782L-0.16647160053253174,1.15334951877594L-0.22196221351623535,1.057236909866333L-0.27745282649993896,0.9611243605613708L-0.332943320274353,0.865011990070343L-0.3884338140487671,0.7688996195793152L-0.44392454624176025,0.6727868914604187L-0.4994150698184967,0.5766745209693909L-0.5549055337905884,0.4805621802806854L-0.6103960275650024,0.3844498097896576L-0.6658865809440613,0.28833746910095215L-0.7213773131370544,0.19222471117973328L-0.7768678069114685,0.09611235558986664L-0.8323583006858826,0L-0.7768675684928894,-0.09611260890960693L-0.7213770747184753,-0.19222497940063477L-0.6658865809440613,-0.2883373498916626L-0.6103960871696472,-0.38444972038269043L-0.5549055933952332,-0.4805620312690735L-0.4994148910045624,-0.5766748189926147L-0.4439243972301483,-0.6727871894836426L-0.38843390345573425,-0.7688995003700256L-0.3329431712627411,-0.8650122880935669L-0.277452677488327,-0.9611246585845947L-0.22196219861507416,-1.0572370290756226L-0.1664717048406601,-1.1533493995666504L-0.11098121851682663,-1.2494617700576782L-0.055490490049123764,-1.3455744981765747Z'
};
var symbols = {
    cross: {
        general: generalizedSymbols.cross,
        base: baseSymbols.cross
    },
    circle: {
        general: generalizedSymbols.circle,
        base: baseSymbols.circle
    },
    square: {
        general: generalizedSymbols.square,
        base: baseSymbols.square
    },
    star: {
        general: generalizedSymbols.star,
        base: baseSymbols.star
    },
    triangle: {
        general: generalizedSymbols.triangle,
        base: baseSymbols.triangle
    },
    diamond: {
        general: generalizedSymbols.diamond,
        base: baseSymbols.diamond
    }
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var drawLegend = function (_a) {
    var root = _a.root, uniqueID = _a.uniqueID, width = _a.width, height = _a.height, colorArr = _a.colorArr, baseColorArr = _a.baseColorArr, hideStrokes = _a.hideStrokes, dashPatterns = _a.dashPatterns, scale = _a.scale, steps = _a.steps, margin = _a.margin, padding = _a.padding, duration = _a.duration, type = _a.type, secondary = _a.secondary, fontSize = _a.fontSize, data = _a.data, labelKey = _a.labelKey, label = _a.label, symbol = _a.symbol, format = _a.format, hide = _a.hide, hoverHighlight = _a.hoverHighlight, clickHighlight = _a.clickHighlight, groupAccessor = _a.groupAccessor, interactionKeys = _a.interactionKeys, hoverStyle = _a.hoverStyle, clickStyle = _a.clickStyle, hoverOpacity = _a.hoverOpacity;
    var totalWidth = width + padding.left + padding.right + 5;
    var leftOffset = padding.left + margin.left;
    var offsetLegend = type === 'scatter' || type === 'key' || type === 'line' || type === 'bar';
    var legendWidth = steps ? width / steps : 0;
    var legendHeight = 15;
    height = hide ? 0 : height + (offsetLegend ? 25 : 5);
    var opacity = hide ? 0 : 1;
    if (type === 'parallel') {
        type = 'line';
    }
    root.attr('viewBox', '0 0 ' + totalWidth + ' ' + height);
    var paddingWrapper = root.select('.legend-padding-wrapper');
    if (!root.select('.legend-padding-wrapper').size()) {
        paddingWrapper = root.append('g').attr('class', 'legend-padding-wrapper');
    }
    var symbolMod = !symbol ? 4 : 7;
    paddingWrapper.attr('transform', "translate(" + ((offsetLegend ? leftOffset : 0) + symbolMod) + "," + (offsetLegend ? 24 : 4) + ")");
    switch (type) {
        default:
            root
                .attr('opacity', opacity)
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('style', hide ? 'display: none;' : null)
                .attr('transform', "translate(0, 0)");
            var defaultLegend = paddingWrapper.selectAll('.legend.default').data([0].concat(colorArr));
            root.selectAll('.key').remove();
            root.selectAll('.gradient').remove();
            defaultLegend
                .enter()
                .append('g')
                .attr('class', 'legend default')
                .merge(defaultLegend)
                .attr('transform', function (_, i) {
                return i === 0 ? "translate(" + leftOffset + ", 20)" : "translate(" + ((i - 1) * legendWidth + leftOffset) + ", 20)";
            })
                .each(function (d, i, n) {
                var gridLabel = i === 0
                    ? formatStats(scale.invertExtent(colorArr[0])[0], format)
                    : formatStats(scale.invertExtent(d)[1], format);
                var labelPosition = i === 0 ? 0 : legendWidth;
                var colorGrid = d3Selection.select(n[i])
                    .selectAll('rect')
                    .data([d]);
                colorGrid
                    .enter()
                    .append('rect')
                    .attr('opacity', 0)
                    .merge(colorGrid)
                    .attr('width', legendWidth)
                    .attr('height', legendHeight)
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('fill', d)
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', opacity);
                colorGrid
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
                var gridText = d3Selection.select(n[i])
                    .selectAll('text')
                    .data([d]);
                gridText
                    .enter()
                    .append('text')
                    .attr('opacity', 0)
                    .merge(gridText)
                    .attr('dx', labelPosition)
                    .attr('dy', '2.5em')
                    .transition('update')
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .text(gridLabel)
                    .attr('opacity', opacity);
                gridText
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
            });
            defaultLegend.exit().remove();
            break;
        case 'gradient':
            var gradientId = new Date().getTime();
            // draw legend as a gradient band
            root
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('style', hide ? 'display: none;' : null)
                .attr('transform', "translate(0, 20)")
                .attr('opacity', opacity);
            root.selectAll('.key').remove();
            root.selectAll('.default').remove();
            var textDiv = paddingWrapper.selectAll('text.gradient').data([0].concat(colorArr));
            textDiv
                .enter()
                .append('text')
                .attr('class', 'legend-text gradient')
                .merge(textDiv)
                .attr('transform', function (_, i) {
                return i === 0 ? "translate(" + leftOffset + ", 0)" : "translate(" + ((i - 1) * legendWidth + leftOffset) + ", 0)";
            })
                .attr('opacity', 0)
                .attr('dx', function (_, i) { return (i === 0 ? 0 : legendWidth); })
                .attr('dy', '2.5em')
                .transition('update')
                .duration(duration)
                .ease(d3Ease.easeCircleIn)
                .text(function (d, i) {
                return i === 0
                    ? formatStats(scale.invertExtent(colorArr[0])[0], format)
                    : formatStats(scale.invertExtent(d)[1], format);
            })
                .attr('opacity', function (_, i) { return (i === 0 || i === colorArr.length ? opacity : 0); });
            textDiv
                .exit()
                .transition()
                .duration(duration)
                .ease(d3Ease.easeCircleIn)
                .attr('opacity', 0)
                .remove();
            if (!paddingWrapper.selectAll('.legend').empty()) {
                paddingWrapper.selectAll('.legend').remove();
            }
            var gradientDiv = paddingWrapper.append('g').attr('class', 'legend gradient');
            gradientDiv
                .append('defs')
                .append('linearGradient')
                .attr('id', 'mainGradient-' + gradientId)
                .selectAll('stop')
                .data(colorArr)
                .enter()
                .append('stop')
                .attr('offset', function (_, i) { return (100 / colorArr.length) * (i + 1) + '%'; })
                .attr('stop-color', function (d) { return d; });
            gradientDiv
                .append('rect')
                .attr('class', 'legend-gradient')
                .attr('x', leftOffset)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', legendHeight)
                .attr('style', 'fill: url(#mainGradient-' + gradientId + ')');
            break;
        case 'key':
            var accumWidth_1 = 0;
            var yPos_1 = 0;
            root
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('opacity', opacity)
                .attr('style', hide ? 'display: none;' : null);
            var currentKeyLegend = paddingWrapper.selectAll('.legend.key').data(colorArr);
            root.selectAll('.default').remove();
            root.selectAll('.gradient').remove();
            currentKeyLegend
                .enter()
                .append('g')
                .attr('class', 'legend key')
                .merge(currentKeyLegend)
                .each(function (d, i, n) {
                var prevLabel = i === 0
                    ? ''
                    : label
                        ? label[i - 1]
                        : formatStats(scale.invertExtent(colorArr[i - 1])[0], format) +
                            '-' +
                            formatStats(scale.invertExtent(colorArr[i - 1])[1], format);
                accumWidth_1 = i === 0 ? 0 : accumWidth_1 + getTextWidth(prevLabel, fontSize) + 40;
                if (accumWidth_1 + getTextWidth(prevLabel, fontSize) > width) {
                    //wrap legends if the length is larger than chart width
                    accumWidth_1 = 0;
                    yPos_1 += fontSize + 10; // line height
                }
                var keyLabel = label
                    ? label[i]
                    : formatStats(scale.invertExtent(d)[0], format) + '-' + formatStats(scale.invertExtent(d)[1], format);
                var keyDot = d3Selection.select(n[i])
                    .selectAll('rect')
                    .data([d]);
                keyDot
                    .enter()
                    .append('rect')
                    .attr('opacity', 0)
                    .merge(keyDot)
                    .attr('fill', d)
                    .attr('width', 15)
                    .attr('height', 15)
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('x', accumWidth_1)
                    .attr('y', yPos_1)
                    .attr('opacity', opacity);
                keyDot
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
                var keyText = d3Selection.select(n[i])
                    .selectAll('text')
                    .data([keyLabel]);
                keyText
                    .enter()
                    .append('text')
                    .attr('class', 'key-text')
                    .attr('opacity', 0)
                    .merge(keyText)
                    .attr('dx', '.2em')
                    .attr('dy', 13)
                    .transition('update')
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .text(keyLabel)
                    .attr('x', accumWidth_1 + 20)
                    .attr('y', yPos_1)
                    .attr('opacity', opacity);
                keyText
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
            });
            currentKeyLegend.exit().remove();
            break;
        case 'line':
            var accumWidthLine_1 = 0;
            var yPosLine_1 = 0;
            var strokeWidth_1 = 3;
            var dashIdealSize_1 = [28, 28, 26, 28, 26];
            root
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('opacity', 1)
                .attr('style', hide ? 'display: none;' : null);
            var currentLineLegend = paddingWrapper.selectAll('.legend').data(data);
            currentLineLegend
                .enter()
                .append('g')
                .attr('class', 'legend')
                .merge(currentLineLegend)
                .each(function (d, i, n) {
                var prevLabel = i === 0 ? '' : label ? label[i - 1] : data[i - 1].key;
                var keyLabel = label ? label[i] : d.key;
                accumWidthLine_1 = i === 0 ? 0 : accumWidthLine_1 + getTextWidth(prevLabel, fontSize) + 60;
                if (accumWidthLine_1 + getTextWidth(keyLabel, fontSize) > width) {
                    //wrap legends if the length is larger than chart width
                    accumWidthLine_1 = 0;
                    yPosLine_1 += fontSize + 10; // line height
                }
                var keyDot = d3Selection.select(n[i])
                    .selectAll('line')
                    .data([d.key]);
                keyDot
                    .enter()
                    .append('line')
                    .merge(keyDot)
                    .style('stroke-width', secondary.includes(d.key) ? strokeWidth_1 - 1 : strokeWidth_1)
                    .style('stroke', colorArr[i])
                    .style('stroke-dasharray', secondary.includes(d.key) ? '2,2' : dashPatterns && i < dashPatterns.length ? dashPatterns[i] : '')
                    .attr('stroke-width', secondary.includes(d.key) ? strokeWidth_1 - 1 : strokeWidth_1)
                    .attr('stroke', colorArr[i])
                    .attr('stroke-dasharray', secondary.includes(d.key) ? '2,2' : dashPatterns && i < dashPatterns.length ? dashPatterns[i] : '')
                    .style('opacity', opacity)
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('x1', accumWidthLine_1)
                    .attr('x2', accumWidthLine_1 +
                    (secondary.includes(d.key) ? 30 : dashPatterns && i < dashPatterns.length ? dashIdealSize_1[i] : 30))
                    .attr('y1', yPosLine_1 + 8)
                    .attr('y2', yPosLine_1 + 8);
                keyDot
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
                var keyText = d3Selection.select(n[i])
                    .selectAll('text')
                    .data([d.key]);
                keyText
                    .enter()
                    .append('text')
                    .attr('class', 'key-text')
                    .attr('opacity', 0)
                    .merge(keyText)
                    .attr('dx', '.2em')
                    .attr('dy', 13)
                    .transition('update')
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .text(keyLabel)
                    .attr('x', accumWidthLine_1 +
                    5 +
                    (secondary.includes(d.key) ? 30 : dashPatterns && i < dashPatterns.length ? dashIdealSize_1[i] : 30))
                    .attr('y', yPosLine_1)
                    .attr('opacity', opacity);
                keyText
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
            });
            currentLineLegend.exit().remove();
            break;
        case 'bar':
            var accumWidthBar_1 = 0;
            var yPosBar_1 = 0;
            root
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('opacity', opacity)
                .attr('style', hide ? 'display: none;' : null);
            var currentBarLegend = paddingWrapper.selectAll('.legend.bar').data(data);
            currentBarLegend
                .enter()
                .append('g')
                .attr('class', 'legend bar')
                .merge(currentBarLegend)
                .each(function (d, i, n) {
                var prevLabel = i === 0
                    ? ''
                    : label && label[i - 1]
                        ? format
                            ? formatStats(label[i - 1], format)
                            : label[i - 1]
                        : format
                            ? formatStats(data[i - 1][labelKey], format)
                            : data[i - 1][labelKey];
                var keyLabel = label && label[i]
                    ? format
                        ? formatStats(label[i], format)
                        : label[i]
                    : format
                        ? formatStats(d[labelKey], format)
                        : d[labelKey];
                accumWidthBar_1 = i === 0 ? 0 : accumWidthBar_1 + getTextWidth(prevLabel, fontSize) + 45;
                if (accumWidthBar_1 + getTextWidth(keyLabel, fontSize) > width) {
                    //wrap legends if the length is larger than chart width
                    accumWidthBar_1 = 0;
                    yPosBar_1 += fontSize + 10; // line height
                }
                var keyDot = d3Selection.select(n[i])
                    .selectAll('rect')
                    .data([d[labelKey]]);
                keyDot
                    .enter()
                    .append('rect')
                    .attr('class', 'bar-rect')
                    .attr('opacity', 0)
                    .merge(keyDot)
                    .attr('fill', scale ? scale(d[labelKey]) : colorArr[i] || colorArr(d[labelKey]))
                    .attr('width', 20)
                    .attr('height', 20)
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('x', accumWidthBar_1)
                    .attr('y', yPosBar_1)
                    .attr('opacity', opacity);
                keyDot
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
                var keyText = d3Selection.select(n[i])
                    .selectAll('text')
                    .data([d[labelKey]]);
                keyText
                    .enter()
                    .append('text')
                    .attr('class', 'bar-text')
                    .attr('opacity', 0)
                    .merge(keyText)
                    .attr('dx', '.2em')
                    .attr('dy', 16)
                    .transition('update')
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .text(keyLabel)
                    .attr('x', accumWidthBar_1 + 25)
                    .attr('y', yPosBar_1)
                    .attr('opacity', opacity);
                keyText
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
            });
            currentBarLegend.exit().remove();
            break;
        case 'scatter':
            var accumWidthScatter_1 = 0;
            var yPosScatter_1 = 0;
            root
                .attr('width', totalWidth)
                .attr('height', height)
                .attr('opacity', opacity)
                .attr('style', hide ? 'display: none;' : null);
            var currentScatterLegend = paddingWrapper.selectAll('.legend').data(data);
            currentScatterLegend
                .enter()
                .append('g')
                .attr('class', 'legend')
                .merge(currentScatterLegend)
                .each(function (d, i, n) {
                var prevLabel = i === 0 ? '' : label ? label[i - 1] : data[i - 1].key;
                var keyLabel = label ? label[i] : d.key;
                accumWidthScatter_1 = i === 0 ? 0 : accumWidthScatter_1 + getTextWidth(prevLabel, fontSize) + 50;
                if (accumWidthScatter_1 + getTextWidth(keyLabel, fontSize) > width) {
                    //wrap legends if the length is larger than chart width
                    accumWidthScatter_1 = 0;
                    yPosScatter_1 += fontSize + 10; // line height
                }
                var keyDot = d3Selection.select(n[i])
                    .selectAll('path')
                    .data([d]);
                keyDot
                    .enter()
                    .append('path')
                    .attr('opacity', 0)
                    .merge(keyDot)
                    .attr('fill', colorArr[i])
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('transform', "translate(" + (+accumWidthScatter_1 + 4) + "," + (+yPosScatter_1 + 8) + ")  scale(4)")
                    .attr('d', symbols[symbol[i] || symbol[0]].general)
                    .attr('opacity', opacity);
                keyDot
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
                var keyText = d3Selection.select(n[i])
                    .selectAll('text')
                    .data([d]);
                keyText
                    .enter()
                    .append('text')
                    .attr('class', 'key-text')
                    .attr('opacity', 0)
                    .merge(keyText)
                    .attr('dx', '.2em')
                    .attr('dy', 13)
                    .transition('update')
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .text(keyLabel)
                    .attr('x', accumWidthScatter_1 + 15)
                    .attr('y', yPosScatter_1)
                    .attr('opacity', opacity);
                keyText
                    .exit()
                    .transition()
                    .duration(duration)
                    .ease(d3Ease.easeCircleIn)
                    .attr('opacity', 0)
                    .remove();
            });
            currentScatterLegend.exit().remove();
            break;
    }
    if (baseColorArr && !hideStrokes) {
        var isArray_1 = Array.isArray(baseColorArr);
        root.selectAll('.legend').each(function (d, i, n) {
            var baseColor = isArray_1 && baseColorArr.length === 1
                ? baseColorArr[0]
                : isArray_1
                    ? baseColorArr[i]
                    : baseColorArr[i] || baseColorArr(d[labelKey]);
            if (baseColor) {
                var contrast = calculateRelativeLuminance(calculateLuminance(baseColor), 1);
                var contrastFriendlyColor = contrast < 3 ? getContrastingStroke(baseColor) : baseColor;
                d3Selection.select(n[i].firstElementChild).attr('data-base-color', baseColor);
                d3Selection.select(n[i].firstElementChild).attr('stroke', contrastFriendlyColor);
                d3Selection.select(n[i].firstElementChild).attr('stroke-width', 1);
            }
        });
    }
    else if (type !== 'line') {
        root
            .selectAll('.legend')
            .selectAll('*')
            .attr('stroke', 'none')
            .attr('stroke-width', 0);
    }
    root.attr('data-type', type || 'default');
    root.selectAll('.legend *:first-child').each(function (_, i, n) {
        var me = d3Selection.select(n[i]);
        if (me.attr('fill')) {
            me.attr('data-fill', me.attr('fill'));
        }
        if (me.attr('stroke')) {
            me.attr('data-stroke', me.attr('stroke'));
        }
        if (me.attr('stroke-width')) {
            me.attr('data-stroke-width', me.attr('stroke-width'));
        }
    });
    setLegendInteractionState({
        root: root,
        uniqueID: uniqueID,
        interactionKeys: interactionKeys,
        groupAccessor: groupAccessor,
        hoverHighlight: hoverHighlight,
        clickHighlight: clickHighlight,
        hoverStyle: hoverStyle,
        clickStyle: clickStyle,
        hoverOpacity: hoverOpacity
    });
    setLegendAccess(root.node(), uniqueID);
};
var setLegendInteractionState = function (_a) {
    var root = _a.root, uniqueID = _a.uniqueID, interactionKeys = _a.interactionKeys, groupAccessor = _a.groupAccessor, hoverHighlight = _a.hoverHighlight, clickHighlight = _a.clickHighlight, hoverStyle = _a.hoverStyle, clickStyle = _a.clickStyle, hoverOpacity = _a.hoverOpacity;
    var type = root.attr('data-type');
    if (type !== 'gradient') {
        root.selectAll('.legend').each(function (d, i, n) {
            var child = d3Selection.select(n[i].firstElementChild);
            var text = d3Selection.select(n[i]).select('text');
            var datum = !d.values ? d : d.values[0];
            var validLegendInteraction = groupAccessor && interactionKeys.length === 1 && interactionKeys[0] === groupAccessor;
            var hovered = checkHovered(datum, hoverHighlight, interactionKeys) && validLegendInteraction;
            var clicked = checkClicked(datum, clickHighlight, interactionKeys) && validLegendInteraction;
            var fill = child.attr('data-fill');
            var stroke = child.attr('data-stroke');
            var resultingStroke = '';
            if (fill) {
                var clickColor = clickStyle ? visaColorToHex(clickStyle.color) : '';
                var hoverColor = hoverStyle ? visaColorToHex(hoverStyle.color) : '';
                var resultingFill = clicked ? clickColor || fill : hovered && hoverColor ? hoverColor : fill;
                child.attr('fill', resultingFill);
                child.style('fill', resultingFill);
                var hasStroke = child.attr('stroke');
                var baseColor = child.attr('data-base-color');
                var resultingClick = type !== 'scatter'
                    ? [getContrastingStroke(clickColor || baseColor || fill)]
                    : getAccessibleStrokes(clickColor || baseColor || fill);
                var resultingHover = type !== 'scatter'
                    ? [getContrastingStroke(hoverColor || baseColor || fill)]
                    : getAccessibleStrokes(hoverColor || baseColor || fill);
                resultingStroke = clicked
                    ? resultingClick[1] || resultingClick[0]
                    : hovered
                        ? resultingHover[1] || resultingHover[0]
                        : hasStroke
                            ? stroke
                            : getContrastingStroke(fill);
            }
            else if (stroke) {
                var clickColor = clickStyle && clickStyle.color ? getAccessibleStrokes(visaColorToHex(clickStyle.color)) : [stroke];
                var hoverColor = hoverStyle && hoverStyle.color ? getAccessibleStrokes(visaColorToHex(hoverStyle.color)) : [stroke];
                resultingStroke = clicked ? clickColor[1] || clickColor[0] : hovered ? hoverColor[1] || hoverColor[0] : stroke;
            }
            child.attr('stroke', resultingStroke);
            child.style('stroke', resultingStroke);
            var baseStrokeWidth = parseFloat(child.attr('data-stroke-width')) || (stroke === 'none' ? 0 : 1);
            var strokeWidthDenominator = baseStrokeWidth < 1 ? baseStrokeWidth : 1;
            var strokeWidthMultiplier = type !== 'line' ? 1 : 2;
            var scale = type !== 'scatter' ? 1 : 4;
            child.attr('stroke-width', (clicked
                ? clickStyle && clickStyle.strokeWidth && strokeWidthDenominator
                    ? (parseFloat(clickStyle.strokeWidth + '') * strokeWidthMultiplier) / strokeWidthDenominator
                    : baseStrokeWidth
                : hovered && hoverStyle && hoverStyle.strokeWidth && strokeWidthDenominator
                    ? (parseFloat(hoverStyle.strokeWidth + '') * strokeWidthMultiplier) / strokeWidthDenominator
                    : baseStrokeWidth) / scale);
            child.style('stroke-width', child.attr('stroke-width'));
            var disableDash = type === 'scatter' || type === 'line';
            child.attr('stroke-dasharray', hovered && !clicked && !disableDash ? '8 6' : type !== 'line' ? 'none' : child.attr('stroke-dasharray'));
            child.style('stroke-dasharray', child.attr('stroke-dasharray'));
            var opacity = checkInteraction(d, 1, hoverOpacity, hoverHighlight, clickHighlight || [], interactionKeys);
            child.attr('opacity', opacity);
            text.attr('opacity', !opacity ? 0 : 1);
        });
    }
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
// incorporates all associated OSS License information to bundle with the application build
// licenses are provided as an array of objects for now
var licenses = [
    {
        dependency: 'visa-chart-components',
        github_link: 'https://github.com/visa/visa-chart-components',
        license: {
            type: 'MIT',
            update_date: '11/15/2020',
            link: 'https://github.com/visa/visa-chart-components/blob/master/LICENSE.md',
            text: "\n        Copyright (c) Visa, Inc.\n\n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in\n        all copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n        THE SOFTWARE.\n      "
        }
    },
    {
        dependency: 'node-uuid',
        github_link: 'https://github.com/kelektiv/node-uuid',
        license: {
            type: 'MIT',
            update_date: '10/15/2019',
            link: 'https://github.com/kelektiv/node-uuid/blob/master/LICENSE.md',
            text: "\n        The MIT License (MIT)\n \n        Copyright (c) 2010-2016 Robert Kieffer and other contributors\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
        }
    },
    {
        dependency: 'turf.js',
        github_link: 'https://github.com/Turfjs/turf',
        license: {
            type: 'MIT',
            update_date: '8/8/2019',
            link: 'https://github.com/Turfjs/turf/blob/master/LICENSE',
            text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2019 Morgan Herlocker\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy of\n                this software and associated documentation files (the \"Software\"), to deal in\n                the Software without restriction, including without limitation the rights to\n                use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n                the Software, and to permit persons to whom the Software is furnished to do so,\n                subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in all\n                copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n                FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n                COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n                IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n                CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n            "
        }
    },
    {
        dependency: 'mapbox-gl-draw',
        github_link: 'https://github.com/mapbox/mapbox-gl-draw',
        license: {
            type: 'ISC',
            update_date: '8/8/2019',
            link: 'https://github.com/mapbox/mapbox-gl-draw/blob/master/LICENSE',
            text: "\n                Copyright (c) Mapbox\n\n                All rights reserved.\n                \n                Permission to use, copy, modify, and/or distribute this software for any\n                purpose with or without fee is hereby granted, provided that the above\n                copyright notice and this permission notice appear in all copies.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n                REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n                AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n                INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n                LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n                OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n                PERFORMANCE OF THIS SOFTWARE.\n            "
        }
    },
    {
        dependency: 'mapbox-gl-js',
        github_link: 'https://github.com/mapbox/mapbox-gl-js',
        license: {
            type: 'BSD',
            update_date: '8/8/2019',
            link: 'https://github.com/mapbox/mapbox-gl-js/blob/master/LICENSE.txt',
            text: "\n                Copyright (c) 2016, Mapbox\n\n                All rights reserved.\n                \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n                \n                    * Redistributions of source code must retain the above copyright notice,\n                    this list of conditions and the following disclaimer.\n                    * Redistributions in binary form must reproduce the above copyright notice,\n                    this list of conditions and the following disclaimer in the documentation\n                    and/or other materials provided with the distribution.\n                    * Neither the name of Mapbox GL JS nor the names of its contributors\n                    may be used to endorse or promote products derived from this software\n                    without specific prior written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n                \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n                LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n                A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n                CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n                EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n                PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n                PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n                LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n                NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n                \n                -------------------------------------------------------------------------------\n                \n                Contains Hershey Simplex Font: http://paulbourke.net/dataformats/hershey/\n                \n                -------------------------------------------------------------------------------\n                \n                Contains code from glfx.js\n                \n                Copyright (C) 2011 by Evan Wallace\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy\n                of this software and associated documentation files (the \"Software\"), to deal\n                in the Software without restriction, including without limitation the rights\n                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the Software is\n                furnished to do so, subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in\n                all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                THE SOFTWARE.\n                \n                --------------------------------------------------------------------------------\n                \n                Contains a portion of d3-color https://github.com/d3/d3-color\n                \n                Copyright 2010-2016 Mike Bostock\n                All rights reserved.\n                \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n                \n                * Redistributions of source code must retain the above copyright notice, this\n                list of conditions and the following disclaimer.\n                \n                * Redistributions in binary form must reproduce the above copyright notice,\n                this list of conditions and the following disclaimer in the documentation\n                and/or other materials provided with the distribution.\n                \n                * Neither the name of the author nor the names of contributors may be used to\n                endorse or promote products derived from this software without specific prior\n                written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n                ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n                WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n                DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n                ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n                (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n                LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n                ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n                (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
        }
    },
    {
        dependency: 'numeral.js',
        github_link: 'https://github.com/adamwdraper/Numeral-js',
        license: {
            type: 'MIT',
            update_date: '8/8/2019',
            link: 'https://github.com/adamwdraper/Numeral-js/blob/master/LICENSE',
            text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2016 Adam Draper\n\n                Permission is hereby granted, free of charge, to any person\n                obtaining a copy of this software and associated documentation\n                files (the \"Software\"), to deal in the Software without\n                restriction, including without limitation the rights to use,\n                copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the\n                Software is furnished to do so, subject to the following\n                conditions:\n                \n                The above copyright notice and this permission notice shall be\n                included in all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                OTHER DEALINGS IN THE SOFTWARE.\n            "
        }
    },
    {
        dependency: 'stencil.js',
        github_link: 'https://github.com/ionic-team/stencil',
        license: {
            type: 'MIT',
            update_date: '8/8/2019',
            link: 'https://github.com/ionic-team/stencil/blob/master/LICENSE',
            text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2018-present Drifty Co.\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy\n                of this software and associated documentation files (the \"Software\"), to deal\n                in the Software without restriction, including without limitation the rights\n                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the Software is\n                furnished to do so, subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in\n                all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                THE SOFTWARE.\n            "
        }
    },
    {
        dependency: 'topojson.js',
        github_link: 'https://github.com/topojson/topojson',
        license: {
            type: 'BSD 3-Clause',
            update_date: '8/8/2019',
            link: 'https://github.com/topojson/topojson/blob/master/LICENSE.md',
            text: "\n                Copyright (c) 2012-2016, Michael Bostock All rights reserved.\n\n                Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n                \n                Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n                \n                Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n                \n                The name Michael Bostock may not be used to endorse or promote products derived from this software without specific prior written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
        }
    },
    {
        dependency: 'd3.js',
        github_link: 'https://github.com/d3/d3',
        license: {
            type: 'BSD 3-Clause',
            update_date: '8/8/2019',
            link: 'https://github.com/d3/d3/blob/master/LICENSE',
            text: "\n                Copyright 2010-2017 Mike Bostock\n                All rights reserved.\n        \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n        \n                * Redistributions of source code must retain the above copyright notice, this\n                list of conditions and the following disclaimer.\n        \n                * Redistributions in binary form must reproduce the above copyright notice,\n                this list of conditions and the following disclaimer in the documentation\n                and/or other materials provided with the distribution.\n        \n                * Neither the name of the author nor the names of contributors may be used to\n                endorse or promote products derived from this software without specific prior\n                written permission.\n        \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n                ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n                WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n                DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n                ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n                (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n                LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n                ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n                (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
        }
    },
    {
        dependency: 'd3-annotation.js',
        github_link: 'https://github.com/susielu/d3-annotation',
        license: {
            type: 'Apache-2.0',
            update_date: '8/8/2019',
            link: 'https://raw.githubusercontent.com/susielu/d3-annotation/master/LICENSE',
            text: "\n                            Apache License\n                            Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n                TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n                1. Definitions.\n\n                \"License\" shall mean the terms and conditions for use, reproduction,\n                and distribution as defined by Sections 1 through 9 of this document.\n\n                \"Licensor\" shall mean the copyright owner or entity authorized by\n                the copyright owner that is granting the License.\n\n                \"Legal Entity\" shall mean the union of the acting entity and all\n                other entities that control, are controlled by, or are under common\n                control with that entity. For the purposes of this definition,\n                \"control\" means (i) the power, direct or indirect, to cause the\n                direction or management of such entity, whether by contract or\n                otherwise, or (ii) ownership of fifty percent (50%) or more of the\n                outstanding shares, or (iii) beneficial ownership of such entity.\n\n                \"You\" (or \"Your\") shall mean an individual or Legal Entity\n                exercising permissions granted by this License.\n\n                \"Source\" form shall mean the preferred form for making modifications,\n                including but not limited to software source code, documentation\n                source, and configuration files.\n\n                \"Object\" form shall mean any form resulting from mechanical\n                transformation or translation of a Source form, including but\n                not limited to compiled object code, generated documentation,\n                and conversions to other media types.\n\n                \"Work\" shall mean the work of authorship, whether in Source or\n                Object form, made available under the License, as indicated by a\n                copyright notice that is included in or attached to the work\n                (an example is provided in the Appendix below).\n\n                \"Derivative Works\" shall mean any work, whether in Source or Object\n                form, that is based on (or derived from) the Work and for which the\n                editorial revisions, annotations, elaborations, or other modifications\n                represent, as a whole, an original work of authorship. For the purposes\n                of this License, Derivative Works shall not include works that remain\n                separable from, or merely link (or bind by name) to the interfaces of,\n                the Work and Derivative Works thereof.\n\n                \"Contribution\" shall mean any work of authorship, including\n                the original version of the Work and any modifications or additions\n                to that Work or Derivative Works thereof, that is intentionally\n                submitted to Licensor for inclusion in the Work by the copyright owner\n                or by an individual or Legal Entity authorized to submit on behalf of\n                the copyright owner. For the purposes of this definition, \"submitted\"\n                means any form of electronic, verbal, or written communication sent\n                to the Licensor or its representatives, including but not limited to\n                communication on electronic mailing lists, source code control systems,\n                and issue tracking systems that are managed by, or on behalf of, the\n                Licensor for the purpose of discussing and improving the Work, but\n                excluding communication that is conspicuously marked or otherwise\n                designated in writing by the copyright owner as \"Not a Contribution.\"\n\n                \"Contributor\" shall mean Licensor and any individual or Legal Entity\n                on behalf of whom a Contribution has been received by Licensor and\n                subsequently incorporated within the Work.\n\n                2. Grant of Copyright License. Subject to the terms and conditions of\n                this License, each Contributor hereby grants to You a perpetual,\n                worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n                copyright license to reproduce, prepare Derivative Works of,\n                publicly display, publicly perform, sublicense, and distribute the\n                Work and such Derivative Works in Source or Object form.\n\n                3. Grant of Patent License. Subject to the terms and conditions of\n                this License, each Contributor hereby grants to You a perpetual,\n                worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n                (except as stated in this section) patent license to make, have made,\n                use, offer to sell, sell, import, and otherwise transfer the Work,\n                where such license applies only to those patent claims licensable\n                by such Contributor that are necessarily infringed by their\n                Contribution(s) alone or by combination of their Contribution(s)\n                with the Work to which such Contribution(s) was submitted. If You\n                institute patent litigation against any entity (including a\n                cross-claim or counterclaim in a lawsuit) alleging that the Work\n                or a Contribution incorporated within the Work constitutes direct\n                or contributory patent infringement, then any patent licenses\n                granted to You under this License for that Work shall terminate\n                as of the date such litigation is filed.\n\n                4. Redistribution. You may reproduce and distribute copies of the\n                Work or Derivative Works thereof in any medium, with or without\n                modifications, and in Source or Object form, provided that You\n                meet the following conditions:\n\n                (a) You must give any other recipients of the Work or\n                Derivative Works a copy of this License; and\n\n                (b) You must cause any modified files to carry prominent notices\n                stating that You changed the files; and\n\n                (c) You must retain, in the Source form of any Derivative Works\n                that You distribute, all copyright, patent, trademark, and\n                attribution notices from the Source form of the Work,\n                excluding those notices that do not pertain to any part of\n                the Derivative Works; and\n\n                (d) If the Work includes a \"NOTICE\" text file as part of its\n                distribution, then any Derivative Works that You distribute must\n                include a readable copy of the attribution notices contained\n                within such NOTICE file, excluding those notices that do not\n                pertain to any part of the Derivative Works, in at least one\n                of the following places: within a NOTICE text file distributed\n                as part of the Derivative Works; within the Source form or\n                documentation, if provided along with the Derivative Works; or,\n                within a display generated by the Derivative Works, if and\n                wherever such third-party notices normally appear. The contents\n                of the NOTICE file are for informational purposes only and\n                do not modify the License. You may add Your own attribution\n                notices within Derivative Works that You distribute, alongside\n                or as an addendum to the NOTICE text from the Work, provided\n                that such additional attribution notices cannot be construed\n                as modifying the License.\n\n                You may add Your own copyright statement to Your modifications and\n                may provide additional or different license terms and conditions\n                for use, reproduction, or distribution of Your modifications, or\n                for any such Derivative Works as a whole, provided Your use,\n                reproduction, and distribution of the Work otherwise complies with\n                the conditions stated in this License.\n\n                5. Submission of Contributions. Unless You explicitly state otherwise,\n                any Contribution intentionally submitted for inclusion in the Work\n                by You to the Licensor shall be under the terms and conditions of\n                this License, without any additional terms or conditions.\n                Notwithstanding the above, nothing herein shall supersede or modify\n                the terms of any separate license agreement you may have executed\n                with Licensor regarding such Contributions.\n\n                6. Trademarks. This License does not grant permission to use the trade\n                names, trademarks, service marks, or product names of the Licensor,\n                except as required for reasonable and customary use in describing the\n                origin of the Work and reproducing the content of the NOTICE file.\n\n                7. Disclaimer of Warranty. Unless required by applicable law or\n                agreed to in writing, Licensor provides the Work (and each\n                Contributor provides its Contributions) on an \"AS IS\" BASIS,\n                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n                implied, including, without limitation, any warranties or conditions\n                of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n                PARTICULAR PURPOSE. You are solely responsible for determining the\n                appropriateness of using or redistributing the Work and assume any\n                risks associated with Your exercise of permissions under this License.\n\n                8. Limitation of Liability. In no event and under no legal theory,\n                whether in tort (including negligence), contract, or otherwise,\n                unless required by applicable law (such as deliberate and grossly\n                negligent acts) or agreed to in writing, shall any Contributor be\n                liable to You for damages, including any direct, indirect, special,\n                incidental, or consequential damages of any character arising as a\n                result of this License or out of the use or inability to use the\n                Work (including but not limited to damages for loss of goodwill,\n                work stoppage, computer failure or malfunction, or any and all\n                other commercial damages or losses), even if such Contributor\n                has been advised of the possibility of such damages.\n\n                9. Accepting Warranty or Additional Liability. While redistributing\n                the Work or Derivative Works thereof, You may choose to offer,\n                and charge a fee for, acceptance of support, warranty, indemnity,\n                or other liability obligations and/or rights consistent with this\n                License. However, in accepting such obligations, You may act only\n                on Your own behalf and on Your sole responsibility, not on behalf\n                of any other Contributor, and only if You agree to indemnify,\n                defend, and hold each Contributor harmless for any liability\n                incurred by, or claims asserted against, such Contributor by reason\n                of your accepting any such warranty or additional liability.\n\n                END OF TERMS AND CONDITIONS\n\n\n                APPENDIX: How to apply the Apache License to your work.\n\n                To apply the Apache License to your work, attach the following\n                boilerplate notice, with the fields enclosed by brackets \"[]\"\n                replaced with your own identifying information. (Don't include\n                the brackets!)  The text should be enclosed in the appropriate\n                comment syntax for the file format. We also recommend that a\n                file or class name and description of purpose be included on the\n                same \"printed page\" as the copyright notice for easier\n                identification within third-party archives.\n\n                Copyright (c) 2017, Susie Lu\n\n                Licensed under the Apache License, Version 2.0 (the \"License\");\n                you may not use this file except in compliance with the License.\n                You may obtain a copy of the License at\n\n                http://www.apache.org/licenses/LICENSE-2.0\n\n                Unless required by applicable law or agreed to in writing, software\n                distributed under the License is distributed on an \"AS IS\" BASIS,\n                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                See the License for the specific language governing permissions and\n                limitations under the License.\n            "
        }
    },
    {
        dependency: 'ua-parser-js',
        github_link: 'https://github.com/faisalman/ua-parser-js',
        license: {
            type: 'MIT',
            update_date: '12/16/2020',
            link: 'https://github.com/faisalman/ua-parser-js/blob/master/license.md',
            text: "\n        MIT License\n\n        Copyright (c) 2012-2019 Faisal Salman <<f@faisalman.com>>\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
        }
    },
    {
        dependency: 'yup',
        github_link: 'https://github.com/jquense/yup',
        license: {
            type: 'MIT',
            update_date: '12/16/2020',
            link: 'https://github.com/jquense/yup/blob/master/LICENSE.md',
            text: "\n        The MIT License (MIT)\n\n        Copyright (c) 2014 Jason Quense\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
        }
    },
    {
        dependency: 'htmlwidgets',
        github_link: 'https://github.com/ramnathv/htmlwidgets',
        license: {
            type: 'MIT',
            update_date: '3/11/2021',
            link: 'https://github.com/ramnathv/htmlwidgets/blob/master/LICENSE',
            text: "\n        MIT License\n\n        Copyright (c) 2016, Ramnath Vaidyanathan, Joe Cheng, JJ Allaire, Yihui Xie, and Kenton Russell\n\n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
        }
    }
];
function getLicenses() {
    return licenses;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var polyfillMouseEvents = function (window) {
    // Polyfills DOM4 MouseEvent
    var MouseEventPolyfill = function (eventType, params) {
        params = params || { bubbles: false, cancelable: false };
        var mouseEvent = document.createEvent('MouseEvent');
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, params.screenX || 0, params.screenY || 0, params.clientX || 0, params.clientY || 0, params.ctrlKey || false, params.altKey || false, params.shiftKey || false, params.metaKey || false, params.button || 0, params.relatedTarget || null);
        return mouseEvent;
    };
    MouseEventPolyfill.prototype = Event.prototype;
    window.MouseEvent = MouseEventPolyfill;
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function transformData(data, groupAccessor, ordinalAccessor, valueAccessor) {
    // transform data to below format
    // [{label: "2018", "A": 23, "B": 7, "C": 11}, {label: ..}]
    var dataArr = [];
    data.forEach(function (obj) {
        var o = {};
        if (!dataArr.length) {
            o[groupAccessor] = obj[groupAccessor];
            o[obj[ordinalAccessor]] = obj[valueAccessor];
            dataArr.push(o);
        }
        else {
            o = dataArr.filter(function (d) { return d[groupAccessor] === obj[groupAccessor]; }).pop();
            if (!!o) {
                var idx = dataArr.findIndex(function (d) { return d[groupAccessor] === obj[groupAccessor]; });
                o[obj[ordinalAccessor]] = obj[valueAccessor];
                dataArr[idx] = o;
            }
            else {
                o = {};
                o[groupAccessor] = obj[groupAccessor];
                o[obj[ordinalAccessor]] = obj[valueAccessor];
                dataArr.push(o);
            }
        }
    });
    return dataArr;
}
var accessorFormatMap = {
    number: '0[.][0][0]a',
    date: '%B %d %Y',
    percent: '0[.][0][0]%',
    string: ''
};
var accessorFormats = {
    valueAccessor: 'number',
    nodeSizeAccessor: 'number',
    latitudeAccessor: 'number',
    longitudeAccessor: 'number',
    xAccessor: [
        {
            charts: ['scatter-plot'],
            type: 'number'
        }
    ],
    yAccessor: [
        {
            charts: ['scatter-plot'],
            type: 'number'
        }
    ]
};
var orderColumns = {
    'alluvial-diagram': ['sourceAccessor', 'targetAccessor', 'groupAccessor', 'valueAccessor'],
    'bar-chart': ['ordinalAccessor', 'valueAccessor', 'groupAccessor'],
    'clustered-bar-chart': ['groupAccessor', 'ordinalAccessor', 'valueAccessor'],
    'stacked-bar-chart': ['groupAccessor', 'ordinalAccessor', 'valueAccessor'],
    'line-chart': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
    'pie-chart': ['ordinalAccessor', 'valueAccessor'],
    'scatter-plot': ['groupAccessor', 'xAccessor', 'yAccessor'],
    'heat-map': ['xAccessor', 'yAccessor', 'valueAccessor'],
    'circle-packing': ['clusterAccessor', 'nodeAccessor', 'nodeSizeAccessor', 'idAccessor'],
    'parallel-plot': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
    'dumbbell-plot': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
    'world-map': ['markerNameAccessor', 'joinNameAccessor', 'valueAccessor']
};
var chartAccessors = {
    singleAccessors: [
        'valueAccessor',
        'sizeAccessor',
        'xAccessor',
        'yAccessor',
        'latitudeAccessor',
        'longitudeAccessor',
        'ordinalAccessor',
        'idAccessor',
        'markerAccessor',
        'markerNameAccessor',
        'joinAccessor',
        'joinNameAccessor',
        'nodeAccessor',
        'parentAccessor',
        'groupAccessor',
        'seriesAccessor',
        'filterAccessor',
        'sourceAccessor',
        'targetAccessor'
    ],
    arrayAccessors: ['interactionKeys'],
    nestedAccessors: [
        {
            objectName: 'tooltipLabel',
            objectAccessors: ['labelAccessor'],
            formatAccessors: ['format']
        },
        {
            objectName: 'accessibility',
            objectAccessors: ['elementDescriptionAccessor']
        },
        {
            objectName: 'dataLabel',
            objectAccessors: ['labelAccessor'],
            formatAccessors: ['format']
        }
    ]
};
function orderScopedData(_this, dataSample, chartType) {
    var tableColumns = [];
    orderColumns[chartType].forEach(function (col) {
        if (_this[col]) {
            tableColumns.push(_this[col]);
        }
    });
    Object.keys(dataSample).forEach(function (key) {
        if (tableColumns.indexOf(key) < 0) {
            tableColumns.push(key);
        }
    });
    return tableColumns;
}
function getScopedData(data, keyMap) {
    var scopedData = [];
    data.forEach(function (dataRecord) {
        var scopedDataRecord = {};
        // loop through target fields instead of all data record fields
        Object.keys(keyMap).forEach(function (field) {
            // check if we have a date object, if we do format with provided or default date format
            if (dataRecord[field] instanceof Date) {
                scopedDataRecord[field] = formatDate({
                    date: dataRecord[field],
                    format: keyMap[field] ? keyMap[field] : accessorFormatMap['date'],
                    offsetTimezone: true
                });
            }
            else {
                if (keyMap[field] === 'normalized') {
                    scopedDataRecord[field] =
                        keyMap[field] && dataRecord[field]
                            ? formatStats(dataRecord[field], accessorFormatMap['number'])
                            : dataRecord[field];
                    scopedDataRecord[field + "%"] =
                        keyMap[field] && dataRecord[field] && dataRecord.getSum
                            ? formatStats(dataRecord[field] / dataRecord.getSum(), accessorFormatMap['percent'])
                            : dataRecord[field];
                }
                else {
                    scopedDataRecord[field] =
                        keyMap[field] && dataRecord[field] ? formatStats(dataRecord[field], keyMap[field]) : dataRecord[field];
                }
            }
        });
        scopedData.push(scopedDataRecord);
    });
    return scopedData;
}
function getDefaultFormat(accessor, formats, formatMap, chartType) {
    // we are going to use a map for now instead of finding the type of the data in the data row
    if (formats[accessor]) {
        if (formats[accessor] instanceof Array) {
            // we have chart specific stuff
            var mappedFormat_1 = undefined;
            formats[accessor].forEach(function (formatObj) {
                if (formatObj.charts.indexOf(chartType) >= 0) {
                    mappedFormat_1 = formatMap[formatObj.type];
                }
                else {
                    mappedFormat_1 = mappedFormat_1 ? mappedFormat_1 : (mappedFormat_1 = '');
                }
            });
            return mappedFormat_1;
        }
        else {
            // we can simple return default type based on value
            if (formatMap[formats[accessor]]) {
                return formatMap[formats[accessor]];
            }
            else {
                return '';
            }
        }
    }
    else {
        return '';
    }
}
function scopeDataKeys(_this, accessors, chartType, skipSorting) {
    // this doesn't work need to get the list of props on the element.
    var valueKeyMap = {};
    var valueKeyHash = {};
    // first we do nested accessors, starting with tooltip
    if (accessors.nestedAccessors && accessors.nestedAccessors instanceof Array) {
        accessors.nestedAccessors.forEach(function (accessor) {
            if (accessor.objectName && accessor.objectAccessors && accessor.objectAccessors instanceof Array) {
                if (_this[accessor.objectName]) {
                    accessor.objectAccessors.forEach(function (k, i) {
                        if (_this[accessor.objectName][k] instanceof Array) {
                            _this[accessor.objectName][k].forEach(function (innerK, j) {
                                // is there an associated format that is an array?
                                if (!valueKeyHash[innerK]) {
                                    valueKeyMap[innerK] =
                                        accessor.formatAccessors &&
                                            accessor.formatAccessors instanceof Array &&
                                            _this[accessor.objectName][accessor.formatAccessors[i]]
                                            ? _this[accessor.objectName][accessor.formatAccessors[i]][j]
                                            : undefined;
                                    valueKeyHash[innerK] = 1;
                                }
                            });
                        }
                        else {
                            if (_this[accessor.objectName][k] && !valueKeyHash[_this[accessor.objectName][k]]) {
                                valueKeyMap[_this[accessor.objectName][k]] = accessor.formatAccessors
                                    ? _this[accessor.objectName][accessor.formatAccessors]
                                    : undefined;
                                valueKeyHash[_this[accessor.objectName][k]] = 1;
                            }
                        }
                    });
                }
            }
        });
    }
    // next we do singleAccessors, make sure it exists and is an array
    if (accessors.singleAccessors && accessors.singleAccessors instanceof Array) {
        accessors.singleAccessors.forEach(function (accessor) {
            // now we check whether the chart has the accessor for each
            if (_this[accessor] && !valueKeyHash[_this[accessor]]) {
                var defFormat = getDefaultFormat(accessor, accessorFormats, accessorFormatMap, chartType);
                valueKeyMap[_this[accessor]] = defFormat;
                valueKeyHash[_this[accessor]] = 1;
            }
        });
    }
    // next we do array accessors
    if (accessors.arrayAccessors && accessors.arrayAccessors instanceof Array) {
        accessors.arrayAccessors.forEach(function (accessor) {
            if (_this[accessor]) {
                _this[accessor].forEach(function (k) {
                    if (!valueKeyHash[k] && k !== 'xAccessor' && k !== 'yAccessor') {
                        // have to account for mutation of heat-map interaction key props
                        valueKeyMap[k] = undefined;
                        valueKeyHash[k] = 1;
                    }
                });
            }
        });
    }
    if (!skipSorting) {
        var newKeyMap_1 = {};
        var correctKeysInOrder = orderScopedData(_this, valueKeyMap, chartType);
        correctKeysInOrder.forEach(function (key) {
            newKeyMap_1[key] = valueKeyMap[key];
        });
        valueKeyMap = newKeyMap_1;
    }
    return valueKeyMap;
}
// this operation happens in-place (it mutates the incoming data, must duplicate before sending when necessary)
function fixNestedSparseness(data, ordinalAccessor, groupAccessor, valueAccessor, defaultValue) {
    // full group is what an ideal group will look like in the nest
    var fullGroup = {};
    // currentNest is what the current nest looks like, we check its sparseness against fullGroup
    var currentNest = {};
    // we will now populate fullGroup and currentNest
    data.forEach(function (datum) {
        // make sure the ideal group has every ordinal value we encounter
        fullGroup[datum[ordinalAccessor]] = 1;
        // check if we have a group in the nest yet
        if (!currentNest[datum[groupAccessor]]) {
            // initialize the group if we don't
            currentNest[datum[groupAccessor]] = {};
        }
        // add the ordinal value to the current group
        currentNest[datum[groupAccessor]][datum[ordinalAccessor]] = 1;
    });
    // we create this array once, so we don't have to repeat it inside our looping
    var everyOrdinal = Object.keys(fullGroup);
    // now that we know what the nest looks like, we are checking sparseness against fullGroup
    Object.keys(currentNest).forEach(function (groupValue) {
        // everyOrdinal has the "perfect" group (non-sparse), so we use it to compare
        everyOrdinal.forEach(function (ordinalValue) {
            // we check each group's ordinals against everyOrdinal, one at a time
            if (!currentNest[groupValue][ordinalValue]) {
                // when we encounter a missing item in the current nest, we add to the original array
                var missingPiece = {};
                // make sure we always have some kind of numeric value here if one is not sent
                missingPiece[valueAccessor] = defaultValue || 0;
                missingPiece[ordinalAccessor] = ordinalValue;
                missingPiece[groupAccessor] = groupValue;
                // now our data contains each missing piece it requires
                data.push(missingPiece);
            }
        });
    });
}

/**
 * Copyright (c) 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var createLabel = function (_a) {
    var d = _a.d, i = _a.i, n = _a.n, capitalizedGeomType = _a.capitalizedGeomType, capitalizedGroupName = _a.capitalizedGroupName, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive;
    var datum = !recursive ? d : d.data.data;
    var label = '';
    if (nested) {
        if (datum[nested].length) {
            datum[nested].forEach(function (child) {
                label += iterateKeys(child, dataKeys, includeKeyNames, true);
            });
        }
        if (groupKeys && groupKeys.length) {
            groupKeys.forEach(function (groupKey) {
                label += !groupKey ? '' : datum[groupKey] + '. ';
            });
        }
    }
    else {
        label += iterateKeys(datum, dataKeys, includeKeyNames);
    }
    label += capitalizedGeomType + ' ' + (i + 1) + ' of ' + n.length + '.';
    if (recursive) {
        var depth_1 = d.depth;
        var size = d3Selection.select(n[i].parentNode)
            .selectAll('g:not(.vcl-accessibility-focus-highlight)')
            .filter(function (data) { return (depth_1 === undefined ? true : data && data.depth === depth_1 + 1); })
            .size();
        label +=
            (' This ' + capitalizedGroupName || capitalizedGeomType + ' group') +
                ' contains ' +
                (size || '0') +
                ' child elements' +
                (!size && d.children && d.children.length ? ' (but some may be hidden until you interact with this node)' : '');
    }
    return label;
};
var createGroupLabel = function (_a) {
    var d = _a.d, targetNode = _a.targetNode, index = _a.index, groupAccessor = _a.groupAccessor, groupKeys = _a.groupKeys, siblings = _a.siblings, isOffsetGroup = _a.isOffsetGroup, includeKeyNames = _a.includeKeyNames, capitalizedGroupName = _a.capitalizedGroupName, capitalizedGeomType = _a.capitalizedGeomType, geomType = _a.geomType;
    var tabbableSiblings = 0;
    Array.prototype.forEach.call(siblings, function (sibling) {
        if (d3Selection.select(sibling).attr('tabindex') !== null) {
            tabbableSiblings++;
        }
    });
    if (tabbableSiblings > 1) {
        var targetRootForChildren = !isOffsetGroup ? targetNode : targetNode.parentNode.nextSibling.childNodes[index];
        var firstChild = targetNode.querySelectorAll('*:not(.vcl-accessibility-focus-highlight)')[0];
        var groupData_1 = firstChild && firstChild['__data__']
            ? includeKeyNames && groupAccessor && firstChild['__data__'][groupAccessor]
                ? groupAccessor + ' ' + firstChild['__data__'][groupAccessor] + '. '
                : firstChild['__data__'][groupAccessor] + '. '
            : '';
        if (groupKeys && groupKeys.length) {
            groupKeys.forEach(function (groupKey) {
                groupData_1 += !groupKey ? '' : d[groupKey] + '. ';
            });
        }
        var childrenCount = targetRootForChildren
            ? targetRootForChildren.querySelectorAll('*:not(.vcl-accessibility-focus-highlight)').length
            : 0;
        return (groupData_1 +
            (capitalizedGroupName || capitalizedGeomType + ' group') +
            ' ' +
            (index + 1) +
            ' of ' +
            targetNode.parentNode.querySelectorAll('g:not(.vcl-accessibility-focus-highlight)').length +
            ' which contains ' +
            childrenCount +
            ' interactive ' +
            geomType +
            (childrenCount !== 1 ? 's.' : '.'));
    }
    else {
        var childrenCount = siblings[index].querySelectorAll('*:not(.vcl-accessibility-focus-highlight)').length;
        return ((capitalizedGroupName || capitalizedGeomType + ' group') +
            ' which contains ' +
            childrenCount +
            ' interactive ' +
            geomType +
            (childrenCount !== 1 ? 's.' : '.'));
    }
};
var iterateKeys = function (item, objectOfDataKeys, includeKeyNames, nested) {
    var dataKeys = Object.keys(objectOfDataKeys);
    var label = '';
    var datum = !item.data
        ? getScopedData([item], objectOfDataKeys)[0]
        : getScopedData([item.data], objectOfDataKeys)[0];
    var keyPosition = 1;
    dataKeys.forEach(function (key) {
        if (datum[key] !== undefined) {
            var keyEnding = typeof datum[key] === 'string' && datum[key][datum[key].length - 1] === '.' ? ' ' : '. ';
            if (!(nested && !includeKeyNames)) {
                label += includeKeyNames ? key + ' ' : '';
                label += datum[key] + keyEnding;
            }
            else {
                label += datum[key] + (keyPosition % 2 ? ' ' : keyEnding);
            }
            if (datum[key + '%'] !== undefined) {
                var percentKeyEnding = datum[key + '%'][datum[key + '%'].length - 1] === '.' ? ' ' : '. ';
                label += includeKeyNames ? key + ' as a percentage ' : '';
                label += datum[key + '%'] + percentKeyEnding;
            }
            keyPosition++;
        }
    });
    return label;
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var keyCodes = {
    parent: 27,
    child: 13,
    select: 32,
    nextSibling: 39,
    previousSibling: 37,
    nextCousin: 40,
    previousCousin: 38,
    nextCousinAlternate: 190,
    previousCousinAlternate: 188,
    shift: 16,
    tab: 9 // TAB
};
var browser$1 = getBrowser();
var isIE11$1 = browser$1 === 'IE'; // ua.includes('rv:11.0');
var isIEEdge$1 = browser$1 === 'Edge'; // ua.includes('Edge');
var rootSVGRole = 'application'; // !isIE11 ? 'region' : 'application';
var staticGeometryRole = 'img'; // 'menuitem'; // !(isIE11 || isIEEdge) ? 'img' : 'treeitem';
var interactiveGeometryRole = 'button'; // 'menuitem'; // !(isIE11 || isIEEdge) ? 'button' : 'treeitem';
var controllerPrefix = 'node-';
var fired = false;
if (isIE11$1) {
    polyfillMouseEvents(window);
}
var setAccessibilityController = function (_a) {
    var node = _a.node, chartTag = _a.chartTag, title = _a.title, description = _a.description, uniqueID = _a.uniqueID, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, groupName = _a.groupName, groupAccessor = _a.groupAccessor, recursive = _a.recursive, disableKeyNav = _a.disableKeyNav;
    var svg = d3Selection.select(node);
    var sameGroupCousinKey = groupAccessor && (chartTag === 'bar-chart' || chartTag === 'world-map') ? groupAccessor : '';
    svg
        .attr('role', 'presentation')
        .attr('focusable', false)
        .attr('tabindex', -1)
        .style('overflow', 'hidden')
        .on('focus', !disableKeyNav
        ? function () {
            focusTarget(d3Selection.select(parent)
                .select('.VCL-controller')
                .node());
            // removeKeyboardHighlight(n[i].firstElementChild, true)
        }
        : null);
    var parent = node.parentNode;
    var controller = d3Selection.select(parent).select('.VCL-controller');
    var getRootAriaLabel = function () {
        var titleText = title + ". ";
        var subtitle = description ? description + '. ' : '';
        var descText = subtitle + " Navigate into the chart area by pressing ENTER. ID: " + uniqueID;
        return titleText + descText;
    };
    if (!controller.size()) {
        controller = d3Selection.select(parent).insert('div', ':first-child');
        controller.attr('class', 'VCL-controller screen-reader-info');
    }
    controller
        .attr('id', 'chart-area-' + uniqueID)
        .attr('data-sgck', sameGroupCousinKey || null)
        .attr('data-group', groupAccessor)
        .attr('aria-label', !disableKeyNav ? getRootAriaLabel() : null)
        .text(!disableKeyNav ? "Interactive " + chartTag + "." : '')
        .attr('role', !disableKeyNav ? rootSVGRole : 'presentation')
        .attr('tabindex', !disableKeyNav ? '0' : '-1')
        .on('keyup', !disableKeyNav
        ? function () {
            var e = d3Selection.event;
            var keyCode = e.keyCode || e.which;
            keyUpHandler();
        }
        : null)
        .on('focus', !disableKeyNav
        ? function (_, i, n) {
            d3Selection.select(n[i])
                .selectAll('[tabindex]')
                .attr('tabindex', -1);
            drawKeyboardFocusClone(n[i], recursive);
            controller.attr('aria-label', getRootAriaLabel());
        }
        : null)
        .on('blur', !disableKeyNav
        ? function (_, i, n) {
            removeKeyboardHighlight(d3Selection.select(n[i].parentNode)
                .select('svg :first-child')
                .node(), true);
            controller.attr('aria-label', "Interactive " + chartTag + ". ID: " + uniqueID);
        }
        : null)
        .on('keydown', !disableKeyNav
        ? function () {
            var e = d3Selection.event;
            var keyCode = d3Selection.event.keyCode || d3Selection.event.which;
            var eventType = validKeyCode(keyCode);
            if (eventType && !fired) {
                fired = true;
                e.stopPropagation();
                var targetChild = enterChartArea(e);
                if (targetChild) {
                    prepareControllerNodes({
                        rootNode: controller.node(),
                        nodeID: targetChild.id,
                        geomType: geomType,
                        includeKeyNames: includeKeyNames,
                        dataKeys: dataKeys,
                        groupKeys: groupKeys,
                        nested: nested,
                        groupName: groupName,
                        groupAccessor: groupAccessor,
                        recursive: recursive,
                        sameGroupCousinKey: sameGroupCousinKey
                    });
                }
            }
        }
        : null);
    var controllerChildID = controller.attr('aria-activedescendant');
    if (controllerChildID && !disableKeyNav) {
        var child = document.getElementById(controllerChildID.substring(5));
        if (child) {
            setActiveChild(child);
        }
        else {
            controller.attr('aria-activedescendant', null);
        }
    }
    else {
        controller.attr('aria-activedescendant', null);
    }
    var rootNode = controller.node();
    if (disableKeyNav && rootNode.children && rootNode.children.length) {
        var childrenToRemove = rootNode.children.length;
        while (childrenToRemove) {
            rootNode.removeChild(rootNode.children[0]);
            childrenToRemove--;
        }
    }
    setHighContrastListener(node, uniqueID); // 'chart-area-' + chartTag +
};
var setElementFocusHandler = function (_a) {
    var node = _a.node, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive, groupName = _a.groupName, uniqueID = _a.uniqueID, disableKeyNav = _a.disableKeyNav;
    d3Selection.select(node).on('focus', !disableKeyNav
        ? function (_, i, n) {
            var idOfTarget = n[i].id;
            if (idOfTarget) {
                var rootNode = document.getElementById('chart-area-' + uniqueID);
                var sameGroupCousinKey = d3Selection.select(rootNode).attr('data-sgck');
                var groupAccessor = d3Selection.select(rootNode).attr('data-group');
                prepareControllerNodes({
                    rootNode: rootNode,
                    nodeID: idOfTarget,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    recursive: recursive,
                    sameGroupCousinKey: sameGroupCousinKey,
                    deleteControllers: false
                });
                hideKeyboardHighlight(n[i]);
            }
        }
        : null);
};
var setElementInteractionAccessState = function (node, selected, selectable) {
    var targetID = '#' + controllerPrefix + d3Selection.select(node).attr('id');
    d3Selection.select(node)
        .attr('data-aria-pressed', selectable ? selected : null)
        .attr('data-role', selectable ? interactiveGeometryRole : staticGeometryRole);
    d3Selection.select(targetID)
        .attr('aria-pressed', selectable ? selected : null)
        .attr('role', selectable ? interactiveGeometryRole : staticGeometryRole);
};
var setElementAccessID = function (_a) {
    var node = _a.node, uniqueID = _a.uniqueID;
    d3Selection.select(node).attr('id', function () {
        if (!node.id) {
            return generateRandomStringID(uniqueID);
        }
        return node.id;
    });
};
var checkAccessFocus = function (parentGNode) {
    return !!d3Selection.select(parentGNode)
        .select('.vcl-accessibility-focus-source')
        .size();
};
var retainAccessFocus = function (_a) {
    var parentGNode = _a.parentGNode, focusDidExist = _a.focusDidExist, recursive = _a.recursive;
    var primaryG = d3Selection.select(parentGNode);
    if (primaryG.select('.vcl-accessibility-focus-source').size()) {
        var target = primaryG.select('.vcl-accessibility-focus-source').node();
        var previouslyHidden = primaryG.select('.vcl-accessibility-focus-indicator').classed('hidden');
        drawKeyboardFocusClone(target, recursive);
        if (previouslyHidden) {
            hideKeyboardHighlight(target);
        }
    }
    else if (focusDidExist) {
        // if there is no focus source, we will put the user back at the start of the current group they are on
        var target_1;
        primaryG.selectAll('[tabindex]').each(function (_, i, n) {
            if (!target_1 && d3Selection.select(n[i]).attr('tabindex') !== null) {
                target_1 = n[i];
            }
        });
        if (!target_1) {
            // if there is not a valid target in the group, we must find a valid target
            var root = findSVGRoot(parentGNode);
            // if there are no tabindex children
            target_1 =
                d3Selection.select(root)
                    .select('[tabindex]')
                    .node() || root;
        }
        focusTarget(target_1);
        drawKeyboardFocusClone(target_1, recursive);
    }
};
var validKeyCode = function (keyCode) {
    return (keyCode === keyCodes.select ||
        keyCode === keyCodes.child ||
        keyCode === keyCodes.parent ||
        keyCode === keyCodes.nextSibling ||
        keyCode === keyCodes.previousSibling ||
        keyCode === keyCodes.nextCousin ||
        keyCode === keyCodes.previousCousin ||
        keyCode === keyCodes.nextCousinAlternate ||
        keyCode === keyCodes.previousCousinAlternate);
};
var prepareControllerNodes = function (_a) {
    var rootNode = _a.rootNode, nodeID = _a.nodeID, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, groupName = _a.groupName, groupAccessor = _a.groupAccessor, recursive = _a.recursive, sameGroupCousinKey = _a.sameGroupCousinKey, deleteControllers = _a.deleteControllers;
    if (isIE11$1 || isIEEdge$1) {
        fired = false;
    }
    var drawCount = 0;
    if (!deleteControllers) {
        // find tab back node, append
        var tabBackNode = findTabBackwardNode(nodeID, recursive);
        if (tabBackNode && tabBackNode.id) {
            drawCount++;
            createControllerNode({
                rootNode: rootNode,
                nodeID: tabBackNode.id,
                isTarget: false,
                geomType: geomType,
                includeKeyNames: includeKeyNames,
                dataKeys: dataKeys,
                groupKeys: groupKeys,
                nested: nested,
                recursive: recursive,
                groupName: groupName,
                groupAccessor: groupAccessor,
                direction: 'backward',
                sourceID: nodeID,
                sameGroupCousinKey: sameGroupCousinKey
            });
        }
        var controllerNodeAlreadyExists = document.getElementById(controllerPrefix + nodeID);
        if (!controllerNodeAlreadyExists) {
            drawCount++;
            createControllerNode({
                rootNode: rootNode,
                nodeID: nodeID,
                isTarget: true,
                geomType: geomType,
                includeKeyNames: includeKeyNames,
                dataKeys: dataKeys,
                groupKeys: groupKeys,
                nested: nested,
                recursive: recursive,
                groupName: groupName,
                groupAccessor: groupAccessor,
                sameGroupCousinKey: sameGroupCousinKey
            });
        }
        else {
            drawCount++;
            rootNode.appendChild(controllerNodeAlreadyExists.parentNode);
            d3Selection.select(controllerNodeAlreadyExists).on('focus', function () { });
        }
        var tabForwardNode = findTabForwardNode(nodeID, recursive);
        if (tabForwardNode && tabForwardNode.id) {
            drawCount++;
            createControllerNode({
                rootNode: rootNode,
                nodeID: tabForwardNode.id,
                isTarget: false,
                geomType: geomType,
                includeKeyNames: includeKeyNames,
                dataKeys: dataKeys,
                groupKeys: groupKeys,
                nested: nested,
                recursive: recursive,
                groupName: groupName,
                groupAccessor: groupAccessor,
                direction: 'forward',
                sourceID: nodeID,
                sameGroupCousinKey: sameGroupCousinKey
            });
        }
    }
    // focus controller node and add keyboard focus indication to chart element
    simulateFocus(nodeID, recursive, deleteControllers);
    // remove old nodes
    var childrenToRemove = rootNode.children.length - drawCount;
    while (childrenToRemove) {
        rootNode.removeChild(rootNode.children[0]);
        childrenToRemove--;
    }
};
var simulateFocus = function (nodeID, recursive, directID) {
    var id = !directID ? controllerPrefix + nodeID : nodeID;
    var targetControllerElement = document.getElementById(id);
    var targetChartElement = document.getElementById(nodeID);
    simulateBlur(!directID ? targetControllerElement.parentNode.parentNode : targetControllerElement);
    focusTarget(targetControllerElement);
    if (!directID) {
        d3Selection.select(targetControllerElement).classed('VCL-controller-focused', true);
        focusAsMouseover(targetChartElement, recursive, false);
        setActiveChild(targetChartElement);
    }
    else {
        removeActiveChild(targetChartElement, true);
    }
    drawKeyboardFocusClone(targetChartElement, recursive);
};
var simulateBlur = function (controllerRoot) {
    var controllerToBlur = d3Selection.select(controllerRoot).select('.VCL-controller-focused');
    if (controllerToBlur.size()) {
        controllerToBlur.classed('VCL-controller-focused', false);
        var targetNode = document.getElementById(controllerToBlur.node().id.substring(5));
        controllerBlurToMouseout(targetNode);
    }
};
var createControllerNode = function (_a) {
    var rootNode = _a.rootNode, nodeID = _a.nodeID, isTarget = _a.isTarget, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive, groupName = _a.groupName, groupAccessor = _a.groupAccessor, direction = _a.direction, sourceID = _a.sourceID, sameGroupCousinKey = _a.sameGroupCousinKey;
    var sourceNode = document.getElementById(nodeID);
    var isOffsetGroup = d3Selection.select(sourceNode).attr('data-offset-group');
    var isGroup = sourceNode.nodeName === 'g' || isOffsetGroup;
    var nodeType = 'div';
    var nodeRole = 'img';
    var nodeCanBePressed = null;
    if (!isGroup) {
        nodeRole = d3Selection.select(sourceNode).attr('data-role');
        nodeCanBePressed = d3Selection.select(sourceNode).attr('data-aria-pressed');
        nodeType = nodeCanBePressed ? 'button' : 'div';
    }
    d3Selection.select(rootNode)
        .append(!isIEEdge$1 ? 'figure' : 'div')
        .attr('role', 'figure')
        .append(nodeType)
        .attr('role', nodeRole)
        .attr('id', controllerPrefix + nodeID)
        .attr('tabindex', -1)
        .on('keydown', function () {
        var e = d3Selection.event;
        e.stopPropagation();
        var result = getInteractionResult(nodeID, e, isGroup, recursive, sameGroupCousinKey);
        if (result) {
            if (result.clicked) {
                // we will "click" the element now
                var resultTarget = document.getElementById(result.id);
                hideKeyboardHighlight(resultTarget.parentNode);
                var evt = new MouseEvent('click', { bubbles: false, cancelable: true });
                resultTarget.dispatchEvent(evt);
                // focus controller node and add keyboard focus indication to chart element
                simulateFocus(nodeID, recursive);
            }
            else if (result.focused) {
                // this will prepare the controller's nodes and then focus the result.id
                var idOfTarget = result.id || rootNode.id;
                prepareControllerNodes({
                    rootNode: rootNode,
                    nodeID: idOfTarget,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    recursive: recursive,
                    sameGroupCousinKey: sameGroupCousinKey,
                    deleteControllers: idOfTarget === rootNode.id
                });
            }
        }
    })
        .on('keyup', function () {
        fired = false;
    })
        .on('focus', !isTarget
        ? function () {
            var id = nodeID;
            if (direction) {
                var node = direction === 'backward'
                    ? findTabBackwardNode(sourceID, recursive)
                    : findTabForwardNode(sourceID, recursive);
                id = node ? node.id : '';
            }
            if (id) {
                prepareControllerNodes({
                    rootNode: rootNode,
                    nodeID: id,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    recursive: recursive,
                    sameGroupCousinKey: sameGroupCousinKey
                });
            }
        }
        : null)
        .on('blur', function () {
        var node = document.getElementById(nodeID);
        controllerBlurToMouseout(node);
    })
        .attr('aria-label', function (_, i, n) {
        var label = '';
        var capitalizedGeomType = geomType[0].toUpperCase() + geomType.substring(1);
        var capitalizedGroupName = groupName ? groupName[0].toUpperCase() + groupName.substring(1) : '';
        var targetNode = !recursive ? sourceNode : sourceNode.parentNode;
        var siblings = !recursive ? targetNode.parentNode.childNodes : findValidRecursiveSiblings(sourceNode);
        var index = Array.prototype.indexOf.call(siblings, sourceNode);
        var element = d3Selection.select(targetNode);
        var d = targetNode['__data__'] || element.data()[0];
        if (isGroup) {
            label = createGroupLabel({
                d: d,
                targetNode: targetNode,
                index: index,
                groupAccessor: groupAccessor,
                groupKeys: groupKeys,
                siblings: siblings,
                isOffsetGroup: isOffsetGroup,
                includeKeyNames: includeKeyNames,
                capitalizedGroupName: capitalizedGroupName,
                capitalizedGeomType: capitalizedGeomType,
                geomType: geomType
            });
        }
        else {
            label = createLabel({
                d: d,
                i: index,
                n: siblings,
                capitalizedGeomType: capitalizedGeomType,
                capitalizedGroupName: capitalizedGroupName,
                includeKeyNames: includeKeyNames,
                dataKeys: dataKeys,
                groupKeys: groupKeys,
                nested: nested,
                recursive: recursive
            });
        }
        d3Selection.select(n[i]).text(label);
        if (nodeCanBePressed) {
            d3Selection.select(n[i]).attr('aria-pressed', nodeCanBePressed);
        }
        return label;
    });
};
var findFirstOffsetValidChild = function (node) {
    var i = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
    return node.parentNode.nextSibling.childNodes[i]
        ? node.parentNode.nextSibling.childNodes[i].childNodes[0]
        : undefined;
};
var findOffsetParent = function (node, direction) {
    var parent = direction === 'next' ? 'target' : 'source';
    var i = direction
        ? node.__data__[parent].index
        : Array.prototype.indexOf.call(node.parentNode.parentNode.childNodes, node.parentNode);
    return node.parentNode.parentNode.previousSibling.childNodes[i];
};
var generateRandomStringID = function (lead) {
    return (lead +
        '-' +
        Math.round(Math.random() * 1000000) +
        '-' +
        Math.round(Math.random() * 1000000) +
        '-' +
        Math.round(Math.random() * 1000000));
};
var findTabForwardNode = function (elementID, recursive, siblingsOnly) {
    var target = document.getElementById(elementID);
    if (!target || target.tagName === 'svg') {
        return null;
    }
    else if (!recursive && target.nextElementSibling) {
        if (d3Selection.select(target.nextElementSibling).attr('tabindex') !== null) {
            return target.nextElementSibling;
        }
        else {
            return findTabForwardNode(target.nextElementSibling.id, recursive);
        }
    }
    else if (recursive && findValidCousin(target, 'next', true)) {
        return findValidCousin(target, 'next', true);
    }
    else if (!siblingsOnly) {
        var parent = findValidParent(target, recursive);
        var parentSibling = !recursive
            ? parent.nextElementSibling
            : parent
                ? findValidCousin(parent, 'next', true)
                : null;
        if (parentSibling) {
            if (d3Selection.select(parentSibling).attr('tabindex') !== null) {
                return parentSibling;
            }
            else if (parentSibling.id) {
                return findTabForwardNode(parentSibling.id, recursive, true);
            }
        }
    }
    return null;
};
var findTabBackwardNode = function (elementID, recursive) {
    var target = document.getElementById(elementID);
    if (!target || target.tagName === 'svg') {
        return null;
    }
    else if (!recursive && target.previousElementSibling) {
        if (d3Selection.select(target.previousElementSibling).attr('tabindex') !== null) {
            return target.previousElementSibling;
        }
        else {
            return findTabBackwardNode(target.previousElementSibling.id, recursive);
        }
    }
    else if (recursive && findValidCousin(target, 'previous', true)) {
        return findValidCousin(target, 'previous', true);
    }
    else if (target.tagName === 'g') {
        return null;
    }
    return findValidParent(target, recursive);
};
var setActiveChild = function (node) {
    var rootSVG = findSVGRoot(node);
    if (!(rootSVG === document.body) && rootSVGRole === 'application') {
        var targetRoot = rootSVG.parentNode.firstElementChild;
        targetRoot.setAttribute('aria-activedescendant', controllerPrefix + node.id);
    }
};
var removeActiveChild = function (node, isTheRoot) {
    var rootSVG = !isTheRoot ? findSVGRoot(node) : node;
    if (!(rootSVG === document.body) && rootSVGRole === 'application') {
        var targetRoot = !isTheRoot ? rootSVG.parentNode.firstElementChild : node;
        targetRoot.setAttribute('aria-activedescendant', null);
    }
};
var focusTarget = function (target) {
    // set the target focus state
    if (isIE11$1) {
        // https://mkyong.com/javascript/focus-is-not-working-in-ie-solution/
        // IE has lazy focusing, so it must be wrapped in a timeout
        setTimeout(function () {
            target.focus();
            // target.dispatchEvent(new Event('focus')); // .focus() is not working in jsdom dispatch for testing instead
        }, 10);
        // HTMLElement.prototype.focus.apply(target);
    } /* else if (isIEEdge) {
      FocusableForeignObject(target);
    }*/
    else {
        target.focus();
        // target.dispatchEvent(new Event('focus')); // .focus() is not working in jsdom dispatch for testing instead
    }
};
var controllerBlurToMouseout = function (target) {
    if (!target) {
        return;
    }
    // remove the target focus state
    removeActiveChild(target);
    blurAsMouseout(target);
    removeKeyboardHighlight(target);
};
var findValidSibling = function (currentTarget, direction) {
    var sibling = direction + 'Sibling';
    var loopSibling = (direction === 'next' ? 'first' : 'last') + 'ElementChild';
    var loopSiblingElement = function () {
        return direction === 'next' ? currentTarget.parentNode.firstElementChild : findValidFinalSibling(currentTarget);
    };
    var siblingElement = currentTarget[sibling] && d3Selection.select(currentTarget[sibling]).attr('tabindex') !== null ? currentTarget[sibling] : null;
    var target = !siblingElement ? loopSiblingElement() : currentTarget[sibling];
    return target || target.parentNode[loopSibling];
};
var findValidFinalSibling = function (node) {
    if (d3Selection.select(node.parentNode.lastElementChild).attr('tabindex') !== null) {
        return node.parentNode.lastElementChild;
    }
    var target = null;
    var index = node.parentNode.childNodes.length - 2;
    while (!target && index >= 0) {
        var currentChild = node.parentNode.childNodes[index];
        if (d3Selection.select(currentChild).attr('tabindex') !== null) {
            target = currentChild;
        }
        index--;
    }
    return target;
};
var findValidParent = function (currentTarget, recursive) {
    if (!recursive) {
        return currentTarget.parentNode;
    }
    if (currentTarget.parentNode &&
        currentTarget.parentNode.parentNode &&
        currentTarget.parentNode.parentNode.firstElementChild) {
        return (findValidChildTarget(currentTarget.parentNode.parentNode.firstElementChild, true) || findSVGRoot(currentTarget));
    }
    return findSVGRoot(currentTarget);
};
var findSVGRoot = function (node) {
    if (node.ownerSVGElement) {
        return node.ownerSVGElement;
    }
    if (node.parentNode.nodeName === 'svg' || node.parentNode === document.body) {
        return node.parentNode;
    }
    else {
        return findSVGRoot(node.parentNode);
    }
};
var enterChartArea = function (_event) {
    var currentTarget = _event.target;
    var keyCode = _event.keyCode || _event.which;
    if (keyCode === keyCodes.child || keyCode === keyCodes.select) {
        // we will allow ENTER or SPACEBAR to enter the chart area
        _event.preventDefault();
        return d3Selection.select(currentTarget.parentNode)
            .select('svg')
            .select('[tabindex]')
            .node();
    }
};
var keyUpHandler = function (code) {
    fired = false;
};
var findFirstValidChild = function (currentTarget, recursive) {
    // recursive by default until it finds something with a tab index?
    var target = !recursive ? currentTarget : findValidSiblingTarget(currentTarget);
    return target && target.firstElementChild ? findValidChildTarget(target.firstElementChild, true) : null;
};
var findValidRecursiveSiblings = function (node) {
    var parentOfParent = node.parentNode.parentNode;
    var parents = parentOfParent.childNodes;
    var siblings = [];
    Array.prototype.forEach.call(parents, function (parent) {
        if (parent.tagName === 'g' && !parent.classList.contains('.vcl-accessibility-focus-highlight')) {
            siblings.push(parent.firstElementChild);
        }
    });
    return siblings;
};
var findValidCousin = function (currentTarget, direction, returnEarly) {
    var parentSiblingChildren;
    var target;
    var currentParentIdx = getElementIndex(currentTarget.parentNode);
    var currentIdx = getElementIndex(currentTarget);
    var _parent = currentTarget.parentNode.parentNode;
    var parentsSiblings = [];
    // const parentsSiblings = _parent.querySelectorAll('g:not(.vcl-accessibility-focus-highlight)')
    Array.prototype.forEach.call(_parent.childNodes, function (child) {
        if (child.tagName === 'g' && !child.classList.contains('vcl-accessibility-focus-highlight')) {
            parentsSiblings.push(child);
        }
    });
    var childrenCount = parentsSiblings.length;
    if (!childrenCount) {
        return null;
    }
    if (direction === 'previous') {
        // up
        if (returnEarly && currentParentIdx === 0) {
            return null;
        }
        parentSiblingChildren =
            currentParentIdx !== 0
                ? parentsSiblings[currentParentIdx - 1].childNodes
                : parentsSiblings[childrenCount - 1].childNodes;
    }
    else if (direction === 'next') {
        // down
        if (returnEarly && currentParentIdx === childrenCount - 1) {
            return null;
        }
        parentSiblingChildren =
            currentParentIdx !== childrenCount - 1
                ? parentsSiblings[currentParentIdx + 1].childNodes
                : parentsSiblings[0].childNodes;
    }
    // set target
    target = parentSiblingChildren[currentIdx];
    // ensure that target is actually something, will check backwards across groups if group sizes don't match
    while (!target && currentIdx > -1) {
        target = parentSiblingChildren[currentIdx];
        currentIdx--;
    }
    return !(currentTarget === target) ? target : null;
};
var findValidSameGroupCousin = function (currentTarget, direction, sameGroupCousinKey) {
    var currentData = d3Selection.select(currentTarget).data()[0];
    var targetGroup = currentData[sameGroupCousinKey];
    var target;
    var cousins = [];
    var targetIndex = -1;
    var found = 0;
    d3Selection.select(currentTarget.parentNode)
        .selectAll('*')
        .each(function (d, i, n) {
        if (d && d[sameGroupCousinKey] === targetGroup) {
            cousins.push(n[i]);
            found++;
        }
        if (targetIndex < 0 && currentTarget === n[i]) {
            // same reference means we know our index
            targetIndex = found - 1;
        }
    });
    if (found && targetIndex > -1) {
        // we have results and a starting point
        if (direction === 'previous') {
            // return either the previous or last cousin
            target = cousins[targetIndex - 1] || cousins[cousins.length - 1];
        }
        else if (direction === 'next') {
            // return either the next or first cousin
            target = cousins[targetIndex + 1] || cousins[0];
        }
    }
    return target;
};
var getElementIndex = function (el) {
    var i = 0;
    var originalNodeName = el.nodeName;
    while (el.previousSibling) {
        if (originalNodeName === el.previousSibling.nodeName &&
            !d3Selection.select(el.previousSibling).classed('vcl-accessibility-focus-hover')) {
            i++;
        }
        el = el.previousSibling;
    }
    return i;
};
var getInteractionResult = function (nodeID, _event, isGroup, recursive, sameGroupCousinKey) {
    var target;
    var result = {
        clicked: false,
        focused: false,
        id: ''
    };
    var currentTarget = document.getElementById(nodeID);
    var keyCode = _event.keyCode || _event.which;
    var direction = keyCode === keyCodes.nextSibling || keyCode === keyCodes.nextCousin || keyCode === keyCodes.nextCousinAlternate
        ? 'next'
        : keyCode === keyCodes.previousSibling ||
            keyCode === keyCodes.previousCousin ||
            keyCode === keyCodes.previousCousinAlternate
            ? 'previous'
            : keyCode === keyCodes.parent
                ? 'up'
                : keyCode === keyCodes.child
                    ? 'down'
                    : '';
    if (direction || keyCode === keyCodes.select) {
        _event.preventDefault();
    }
    if (!fired) {
        fired = true;
        if (keyCode === keyCodes.select) {
            // a selection has happened
            result.clicked = true;
            result.id = nodeID;
        }
        else if ((keyCode === keyCodes.nextSibling || keyCode === keyCodes.previousSibling) && !recursive) {
            // we are moving among siblings
            target = findValidSibling(currentTarget, direction);
        }
        else if ((!recursive &&
            (keyCode === keyCodes.nextCousin ||
                keyCode === keyCodes.nextCousinAlternate ||
                keyCode === keyCodes.previousCousin ||
                keyCode === keyCodes.previousCousinAlternate)) ||
            ((keyCode === keyCodes.nextSibling || keyCode === keyCodes.previousSibling) && recursive)) {
            // we are moving among cousins (which are siblings if the chart is recursive)
            if (sameGroupCousinKey && !isGroup) {
                // the cousin is in the same tree and must be found among siblings
                target = findValidSameGroupCousin(currentTarget, direction, sameGroupCousinKey);
            }
            else if (!isGroup) {
                // the dom is structured in a hierarchy, so we navigate accordingly
                var isOffset = d3Selection.select(currentTarget).attr('data-offset-element');
                target = !isOffset ? findValidCousin(currentTarget, direction) : findOffsetParent(currentTarget, direction);
            }
        }
        else if (direction === 'down' ||
            (recursive && (keyCode === keyCodes.nextCousin || keyCode === keyCodes.nextCousinAlternate))) {
            // we are moving down
            if (isGroup || recursive) {
                var isOffset = d3Selection.select(currentTarget).attr('data-offset-group');
                target = !isOffset ? findFirstValidChild(currentTarget, recursive) : findFirstOffsetValidChild(currentTarget);
            }
        }
        else if (direction === 'up' ||
            (recursive && (keyCode === keyCodes.previousCousin || keyCode === keyCodes.previousCousinAlternate))) {
            // we are moving up
            if (isGroup) {
                target = findSVGRoot(currentTarget);
            }
            else {
                var isOffset = d3Selection.select(currentTarget).attr('data-offset-element');
                target = !isOffset ? findValidParent(currentTarget, recursive) : findOffsetParent(currentTarget);
            }
        }
    }
    if (target && d3Selection.select(target).attr('tabindex')) {
        result.focused = true;
        result.id = target.id;
    }
    return result;
};
var removeKeyboardHighlight = function (parent, rootOnly) {
    var className = !rootOnly ? 'vcl-accessibility-focus' : 'vcl-accessibility-focus-root';
    d3Selection.select(parent.ownerSVGElement)
        .selectAll('.' + className + '-source')
        .classed(className + '-source', false);
    d3Selection.select(parent.ownerSVGElement)
        .selectAll('.' + className + '-indicator')
        .remove();
};
var hideKeyboardHighlight = function (parent) {
    d3Selection.select(parent.ownerSVGElement)
        .selectAll('.vcl-accessibility-focus-indicator')
        .classed('hidden', true)
        .style('opacity', 0)
        .attr('opacity', 0);
};
var drawKeyboardFocusClone = function (inputElement, recursive) {
    var source = inputElement.tagName !== 'DIV'
        ? inputElement
        : d3Selection.select(inputElement.parentNode)
            .select('svg')
            .node();
    var shouldDeleteSource = false;
    var className = !(source.tagName === 'svg') ? 'vcl-accessibility-focus' : 'vcl-accessibility-focus-root';
    var isNotAGeometry = source.tagName === 'g' || source.tagName === 'svg';
    if (isNotAGeometry) {
        var bbox = source.getBBox();
        var width = source.tagName === 'svg' ? Math.max(+source.getAttribute('width') - 10, 0) : +bbox.width + 10;
        var height = source.tagName === 'svg' ? Math.max(+source.getAttribute('height') - 10, 0) : +bbox.height + 10;
        var x = source.tagName === 'svg' ? 5 : +bbox.x - 5;
        var y = source.tagName === 'svg' ? 5 : +bbox.y - 5;
        var newSource = d3Selection.select(!(source.tagName === 'svg') ? source.parentNode : source)
            .append('rect')
            .attr('x', x)
            .attr('y', y)
            .attr('width', width)
            .attr('height', height)
            .attr('transform', d3Selection.select(source).attr('transform') || null)
            .attr('fill', 'none')
            .style('fill', 'none');
        source = newSource.node();
        shouldDeleteSource = true;
    }
    else {
        var shouldHideOutline = d3Selection.select(source)
            .style('outline')
            .includes('auto');
        if (shouldHideOutline) {
            d3Selection.select(source)
                .style('outline-width', '0px')
                .style('outline-offset', '0px')
                .style('outline-color', 'none');
        }
    }
    var parent = source.parentNode;
    removeKeyboardHighlight(parent.tagName !== 'svg' ? parent : parent.firstElementChild);
    d3Selection.select(source).classed(className + '-source', true);
    var hasWidth = d3Selection.select(source).attr('width');
    var highlightCopy = source.cloneNode(false);
    var haloCopy = source.cloneNode(false);
    var copy = source.cloneNode(false);
    if ((!recursive && !shouldDeleteSource) || (recursive && isNotAGeometry)) {
        var elevateParentLevel = !isNotAGeometry &&
            (!(d3Selection.select(source.parentNode).attr('tabindex') === null) || d3Selection.select(source.parentNode).classed('offset-target'));
        var targetAppendLocation = !elevateParentLevel ? parent : parent.parentNode;
        var parentCopy = parent.cloneNode(false);
        parentCopy.appendChild(haloCopy);
        parentCopy.appendChild(highlightCopy);
        parentCopy.appendChild(copy);
        targetAppendLocation.appendChild(parentCopy);
        applyDefaults$1(d3Selection.select(parentCopy), className);
        d3Selection.select(parentCopy).attr('filter', null);
    }
    else {
        if (recursive) {
            // NOTE: below chunk assumes recursive === a circle SVG primitive
            // this is true for now, with circle-packing as the only current recursive chart
            // future hierarchical charts will need special treatment
            var baseRadius = +d3Selection.select(copy).attr('r');
            parent.parentNode.appendChild(haloCopy);
            d3Selection.select(haloCopy)
                .attr('r', baseRadius + 6)
                .attr('stroke-width', 0);
            parent.parentNode.appendChild(highlightCopy);
            d3Selection.select(highlightCopy)
                .attr('r', baseRadius + 3)
                .attr('stroke-width', 0);
            // NOTE ALSO: recursive elements do not need to copy+append themselves,
            // they only need to append their halo + highlight elements
        }
        else {
            var isOffsetGroup = !!d3Selection.select(inputElement).attr('data-offset-group');
            if (!isOffsetGroup) {
                if (source.nextSibling) {
                    parent.insertBefore(copy, source.nextSibling);
                    parent.insertBefore(highlightCopy, source.nextSibling);
                    parent.insertBefore(haloCopy, source.nextSibling);
                }
                else {
                    parent.appendChild(haloCopy);
                    parent.appendChild(highlightCopy);
                    parent.appendChild(copy);
                }
            }
            else {
                var offsetTarget = parent.nextSibling.nextSibling;
                parent.parentNode.insertBefore(haloCopy, offsetTarget);
                parent.parentNode.insertBefore(highlightCopy, offsetTarget);
                parent.parentNode.insertBefore(copy, offsetTarget);
            }
        }
    }
    var copyStyle = d3Selection.select(copy)
        .style('opacity', !isNotAGeometry ? 1 : 0)
        .attr('opacity', !isNotAGeometry ? 1 : 0)
        .style('stroke-opacity', !isNotAGeometry ? 1 : 0)
        .attr('stroke-opacity', !isNotAGeometry ? 1 : 0);
    if ((!recursive && !isNotAGeometry && hasWidth) || isNotAGeometry) {
        copyStyle.style('fill-opacity', 0).attr('fill-opacity', 0);
    }
    applyDefaults$1(copyStyle, className);
    var isAlluvial = d3Selection.select(source).data() &&
        d3Selection.select(source).data()[0] &&
        d3Selection.select(source).data()[0].source &&
        d3Selection.select(source).data()[0].target &&
        (d3Selection.select(source).data()[0].y0 || d3Selection.select(source).data()[0].y0 === 0);
    var highlightStyle = d3Selection.select(highlightCopy);
    applyDefaults$1(highlightStyle, className);
    applyOutlineOverride$1(highlightStyle, !isNotAGeometry && !recursive && !hasWidth ? 10 : 6, '#ffffff', isAlluvial ? d3Selection.select(source).data()[0] : undefined);
    if (!recursive && !isNotAGeometry && hasWidth) {
        applySizeOverride(highlightStyle, 3);
    }
    highlightStyle.style('opacity', 1).attr('opacity', 1);
    var haloStyle = d3Selection.select(haloCopy);
    applyDefaults$1(haloStyle, className);
    applyOutlineOverride$1(haloStyle, !isNotAGeometry && !recursive && !hasWidth ? 14 : !isNotAGeometry ? 2 : 10, '#000000', isAlluvial ? d3Selection.select(source).data()[0] : undefined);
    if (!recursive && !isNotAGeometry && hasWidth) {
        applySizeOverride(haloStyle, 7);
    }
    haloStyle.style('opacity', 1).attr('opacity', 1);
    if (shouldDeleteSource) {
        d3Selection.select(source).remove();
    }
};
var applyDefaults$1 = function (selection, className) {
    if (selection.attr('d') && selection.attr('filter') && !selection.attr('marker-start')) {
        selection.attr('filter', null);
    }
    selection
        .attr('id', null)
        .attr('class', className + '-highlight ' + className + '-indicator')
        .attr('focusable', false)
        .attr('aria-label', null)
        .attr('aria-hidden', true)
        .attr('role', null)
        .style('pointer-events', 'none')
        .attr('tabindex', null)
        .attr('mix-blend-mode', null)
        .style('mix-blend-mode', null)
        .attr('r', function (_, i, n) {
        var r = parseFloat(d3Selection.select(n[i]).attr('r'));
        return r || 1;
    });
};
var applySizeOverride = function (selection, offset) {
    selection
        .attr('width', function (_, i, n) {
        var width = parseFloat(d3Selection.select(n[i]).attr('width'));
        return width + offset * 2;
    })
        .attr('height', function (_, i, n) {
        var height = parseFloat(d3Selection.select(n[i]).attr('height'));
        return height + offset * 2;
    })
        .attr('x', function (_, i, n) {
        var x = parseFloat(d3Selection.select(n[i]).attr('x'));
        return x - offset;
    })
        .attr('y', function (_, i, n) {
        var y = parseFloat(d3Selection.select(n[i]).attr('y'));
        return y - offset;
    });
};
var applyOutlineOverride$1 = function (selection, extraStrokeWidth, strokeColor, d) {
    selection
        .style('stroke-dasharray', '')
        .attr('stroke-dasharray', null)
        .style('outline-offset', '0px')
        .style('outline-color', 'none')
        .style('outline-width', '0px')
        .attr('filter', null)
        .style('stroke-linecap', !d ? 'round' : 'butt')
        .style('fill', 'none')
        .style('stroke-opacity', 1)
        .style('stroke', strokeColor)
        .style('stroke-width', function (_, i, n) {
        var width = d3Selection.select(n[i]).style('stroke') !== 'none' ? parseFloat(d3Selection.select(n[i]).style('stroke-width')) || 0 : 0;
        var scaleIndex = d3Selection.select(n[i]).attr('transform')
            ? d3Selection.select(n[i])
                .attr('transform')
                .indexOf('scale')
            : -1;
        var scale = 1;
        if (scaleIndex > -1) {
            var scaleSubstring = d3Selection.select(n[i])
                .attr('transform')
                .substring(scaleIndex + 6);
            var endSubstring = scaleSubstring.indexOf(',') < scaleSubstring.indexOf(')') && scaleSubstring.indexOf(',') !== -1
                ? scaleSubstring.indexOf(',')
                : scaleSubstring.indexOf(')');
            scale = +scaleSubstring.substring(0, endSubstring);
        }
        var bonus = 0;
        var me = d3Selection.select(n[i]);
        if (me.attr('d') && d) {
            var originalPath = me.attr('d').substr(1);
            var offsetStart = "M " + (d.source.x1 - extraStrokeWidth / 2) + " " + d.y0 + " L";
            var offsetEnd = "L " + (d.target.x0 + extraStrokeWidth / 2) + " " + d.y1;
            me.attr('d', offsetStart + originalPath + offsetEnd);
        }
        else if (me.attr('marker-start') && me.attr('data-centerX1') && me.attr('d')) {
            var x1 = me.attr('data-centerX1');
            var y1 = me.attr('data-centerY1');
            var x2 = me.attr('data-centerX2');
            var y2 = me.attr('data-centerY2');
            me.attr('d', "M " + x1 + " " + y1 + " L " + x2 + " " + y2);
            bonus = +me.attr('data-barSize') + 6;
        }
        me.attr('marker-start', null);
        me.attr('marker-end', null);
        return (width + extraStrokeWidth + bonus) / scale + 'px';
    });
};
var findValidSiblingTarget = function (element) {
    return !element.nextElementSibling
        ? null
        : element.nextElementSibling.nodeName === 'g'
            ? element.nextElementSibling
            : findValidSiblingTarget(element.nextElementSibling);
};
var findValidChildTarget = function (element, requireTabIndex) {
    if ((!requireTabIndex || (requireTabIndex && d3Selection.select(element).attr('tabindex') !== null)) &&
        !d3Selection.select(element).classed('vcl-accessibility-focus-highlight')) {
        return element;
    }
    if (element.nextElementSibling) {
        return findValidChildTarget(element.nextElementSibling, requireTabIndex);
    }
    else {
        return null;
    }
};
var getOffset = function (el) {
    var bounds = el.getBoundingClientRect(); // bounds.top
    var left = bounds.left + document.body.scrollLeft + document.documentElement.scrollLeft;
    var top = bounds.top + document.body.scrollTop + document.documentElement.scrollTop;
    return {
        top: top,
        left: left
    };
};
var blurAsMouseout = function (node) {
    removeKeyboardHighlight(node.parentNode);
    var evt = new MouseEvent('mouseout', { bubbles: false, cancelable: true });
    node.dispatchEvent(evt);
};
var focusAsMouseover = function (node, recursive, drawClone) {
    var leftPos = getOffset(node).left;
    var topPos = getOffset(node).top;
    var evt = new MouseEvent('mouseover', { bubbles: false, cancelable: true, clientX: leftPos, clientY: topPos });
    if (drawClone) {
        drawKeyboardFocusClone(node, recursive);
    }
    node.dispatchEvent(evt);
};

/**
 * Copyright (c) 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var userOS = getOS();
var emptyDescriptions = {
    'vcl-access-title': 'This chart has no title provided.',
    'vcl-access-subtitle': 'This chart has no subtitle provided.',
    'vcl-access-long-description': '',
    'vcl-access-context': '',
    'vcl-access-executive-summary': '',
    'vcl-access-purpose': '',
    'vcl-access-statistics': '',
    'vcl-access-layout': '',
    'vcl-access-xAxis': '',
    'vcl-access-yAxis': '',
    'vcl-access-notes': '',
    'vcl-access-annotation': '',
    'vcl-access-annotation-title': '',
    'vcl-access-annotation-description': '',
    headings: ''
};
var initializeDescriptionRoot = function (_a) {
    var rootEle = _a.rootEle, geomType = _a.geomType, title = _a.title, chartTag = _a.chartTag, uniqueID = _a.uniqueID, groupName = _a.groupName, isSubgroup = _a.isSubgroup, highestHeadingLevel = _a.highestHeadingLevel, redraw = _a.redraw, recursive = _a.recursive, disableKeyNav = _a.disableKeyNav;
    var level1 = findTagLevel(highestHeadingLevel, 0);
    level1 = level1 === 'h1' ? 'h2' : level1;
    var level2 = findTagLevel(level1, 1);
    var level3 = findTagLevel(level1, 2);
    var level4 = findTagLevel(level1, 3);
    var instructionsWrapper = d3Selection.select(rootEle).select('.vcl-accessibility-instructions');
    var group = groupName || geomType + ' group';
    if (!instructionsWrapper.size() || redraw) {
        if (!instructionsWrapper.size()) {
            instructionsWrapper = d3Selection.select(rootEle)
                .select('.o-layout')
                .insert('div', ':first-child')
                .attr('class', 'vcl-accessibility-instructions')
                .style('position', 'absolute')
                .style('width', '200px');
        }
        else {
            instructionsWrapper.selectAll('*').remove();
        }
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-region-label')
            .on('focus', focusInstructions)
            .on('blur', blurInstructions)
            .attr('tabindex', 0);
        instructionsWrapper
            .append(level1)
            .attr('class', 'screen-reader-info vcl-access-title')
            .text(emptyDescriptions['vcl-access-title']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-subtitle')
            .text(emptyDescriptions['vcl-access-subtitle']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-executive-summary-heading')
            .text(emptyDescriptions['headings']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-executive-summary')
            .attr('data-level', level2)
            .text(emptyDescriptions['vcl-access-executive-summary']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-purpose-heading')
            .text(emptyDescriptions['headings']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-purpose')
            .attr('data-level', level2)
            .text(emptyDescriptions['vcl-access-purpose']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-long-description-heading')
            .text(emptyDescriptions['headings']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-long-description')
            .attr('data-level', level2)
            .text(emptyDescriptions['vcl-access-long-description']);
        instructionsWrapper
            .append(level4)
            .attr('data-level', level2)
            .attr('class', 'screen-reader-info vcl-access-context')
            .text(emptyDescriptions['vcl-access-context']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-structure-heading')
            .text('Structure');
        instructionsWrapper
            .append(level3)
            .attr('class', 'screen-reader-info vcl-access-statistics-heading')
            .text(emptyDescriptions['headings']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-statistics')
            .attr('data-level', level3)
            .text(emptyDescriptions['vcl-access-statistics']);
        instructionsWrapper
            .append(level3)
            .attr('class', 'screen-reader-info vcl-access-chart-layout-heading')
            .text('Chart Layout Description');
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-layout')
            .text(emptyDescriptions['vcl-access-layout']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-xAxis')
            .text(emptyDescriptions['vcl-access-xAxis']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-yAxis')
            .text(emptyDescriptions['vcl-access-yAxis']);
        instructionsWrapper
            .append(level3)
            .attr('class', 'screen-reader-info vcl-access-notes-heading')
            .text(emptyDescriptions['headings']);
        instructionsWrapper
            .append(level4)
            .attr('class', 'screen-reader-info vcl-access-notes')
            .attr('data-level', level3)
            .attr('data-annotationlevel', level2)
            .text(emptyDescriptions['vcl-access-notes']);
        instructionsWrapper
            .append(level2)
            .attr('class', 'screen-reader-info vcl-access-annotations-heading')
            .text(emptyDescriptions['headings']);
        if (!disableKeyNav) {
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-interaction-instructions')
                .text('Interaction Instructions');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("Use Regions/Landmarks or TAB to skip ahead to the chart area or the data table. The following subsections explain how to use this chart's interactivity.");
            if (userOS === 'Mac OS') {
                instructionsWrapper
                    .append(level3)
                    .attr('class', 'screen-reader-info')
                    .text("Note for Mac users");
                instructionsWrapper
                    .append(level4)
                    .attr('class', 'screen-reader-info')
                    .text("If you are using Voice Over for Mac, you will need to press CONTROL plus SHIFT before using any arrow keys, ENTER, SPACEBAR, or ESCAPE, to ensure that Voice Over does not interfere with the chart's controls.");
            }
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info')
                .text("Enabling this chart's interactivity");
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("Screen readers that are able to switch between Browse and Forms mode will need to turn on Forms mode once the chart area is reached.");
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info')
                .text('Using the TAB key outside the Chart area and Exposing new Layers with the ENTER key');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("Each chart has three main TAB areas at first: the information and instructions (which is this), the chart area, and the data table. You may TAB out of this section to the chart area at any time. Once on the chart area, you may focus the chart's first " + group + " by pressing ENTER. Doing this will navigate you into the chart area, which enables you to use the ARROW keys focus new elements.");
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info')
                .text('Using the ESCAPE key');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("When in the chart area, pressing the ESCAPE key will always move your keyboard focus to the parent of the " + geomType + " or " + group + " you are currently on, until you reach the root of the chart." //  Pressing SHIFT plus TAB will move your focus backwards, which will be the previous sibling to the ${geomType} or ${group} you are on or (if no previous sibling exists), then the parent of the ${geomType} or ${group} you are currently on.
            );
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info')
                .text('Exploring Sibling Groups and Elements with LEFT and RIGHT');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("When in the chart area, pressing RIGHT ARROW will move your focus to the next available " + geomType + " or " + group + " at the same level, within the same group. If there is not another " + geomType + " or " + group + " at the same level within your group, focus will move back to the first " + geomType + " or " + group + " among the siblings to your " + geomType + " or " + group + ". Pressing LEFT ARROW works in the same circular manner, but in reverse. This functionality is intended to allow easier comparison and navigation among siblings at the beginning and end of a group without leaving the group. This can be helpful when elements are sorted or ordered, because you can jump from the first to last elements easily.");
            if (isSubgroup) {
                instructionsWrapper
                    .append(level3)
                    .attr('class', 'screen-reader-info')
                    .text('Exploring Cousin Elements with UP and DOWN ARROW keys');
                instructionsWrapper
                    .append(level4)
                    .attr('class', 'screen-reader-info')
                    .text("When in the chart area on a " + geomType + ", pressing UP or DOWN ARROW will move your focus to another " + geomType + " at the same level, but in the previous or next " + group + ". Navigation in this way is also circular, so pressing DOWN when on the last " + group + " will navigate your focus to the corresponding cousin " + geomType + " in the chart's first " + group + " at that level. Navigating to cousin " + geomType + "s in this way can improve the ease of comparison of similar elements across " + group + "s, like using up and down arrows in a table.");
            }
            else if (recursive) {
                instructionsWrapper
                    .append(level3)
                    .attr('class', 'screen-reader-info')
                    .text('A note about navigating Hierarchical Charts');
                instructionsWrapper
                    .append(level4)
                    .attr('class', 'screen-reader-info')
                    .text("This chart contains a nested hierarchy, which means that there could be children contained inside any chart element that you navigate to and this nested structure could be multiple levels deep depending on the chart's data. Your current element will always explain if it contains children or not within it but these elements may be hidden until your current element is activated using SPACEBAR. If the children elements are not hidden, they can be navigated to using ENTER or DOWN ARROW keys and you can always exit your current level by using the ESCAPE or UP ARROW keys.");
            }
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info')
                .text('Selecting Elements with SPACEBAR');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info')
                .text("If a " + geomType + " is selectable and that selection causes something to happen, it will be marked up as a BUTTON and you may select it using SPACEBAR. Note that if you use SPACEBAR while on a " + group + ", it will have no effect. Only using SPACEBAR on a " + geomType + " may have effects.)");
        }
    }
    instructionsWrapper.attr('id', 'chart-instructions-' + uniqueID);
    var chartTitle = title ? ', Titled: ' + title : ', with no title provided.';
    var fullDescription = "Keyboard interactive " + chartTag + chartTitle + ". The next TAB will focus the chart area. Pressing ENTER once on the chart will enter it and focus the chart's first " + group + ". If there are multiple " + group + "s, they can be navigated among using ARROW keys. You may access the group's child " + geomType + "s by pressing ENTER again. You may then use the arrow keys to navigate among " + geomType + "s and SPACEBAR to select them. Use ESCAPE to drill up one level of the chart or TAB to leave it entirely. If you are using a screen reader, this section contains additional information and instructions."; //  Chart Unique ID: ${uniqueID}.
    var nonInteractive = "Static " + chartTag + " image" + chartTitle + ". The next TAB will focus the data table button. If you are using a screen reader, this section contains additional information.";
    instructionsWrapper.select('.vcl-region-label').text(!disableKeyNav ? fullDescription : nonInteractive);
};
var setAccessTitle = function (rootEle, title) {
    d3Selection.select(rootEle)
        .select('.vcl-access-title')
        .text(title ? 'Chart title: ' + title : emptyDescriptions['vcl-access-title']);
};
var setAccessSubtitle = function (rootEle, subtitle) {
    d3Selection.select(rootEle)
        .select('.vcl-access-subtitle')
        .text(subtitle ? 'Chart subtitle: ' + subtitle : emptyDescriptions['vcl-access-subtitle']);
};
var setAccessLongDescription = function (rootEle, description) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), description, 'Long Description', 'vcl-access-long-description', description ||
        d3Selection.select(rootEle)
            .select('.vcl-access-context')
            .text());
};
var setAccessContext = function (rootEle, context) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), context, 'Long Description', 'vcl-access-context', context ||
        d3Selection.select(rootEle)
            .select('.vcl-access-long-description')
            .text(), 'vcl-access-long-description');
};
var setAccessExecutiveSummary = function (rootEle, summary) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), summary, 'Executive Summary', 'vcl-access-executive-summary', !!summary);
};
var setAccessPurpose = function (rootEle, purpose) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), purpose, 'Purpose', 'vcl-access-purpose', !!purpose);
};
var setAccessStatistics = function (rootEle, statistics) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), statistics, 'Statistical Information', 'vcl-access-statistics', !!statistics);
};
var setAccessChartCounts = function (_a) {
    var rootEle = _a.rootEle, parentGNode = _a.parentGNode, chartTag = _a.chartTag, geomType = _a.geomType, groupName = _a.groupName, recursive = _a.recursive;
    var primaryG = d3Selection.select(parentGNode);
    var plural = primaryG
        .selectAll('g')
        .selectAll('*:not(title)')
        .size() > 1 ||
        (primaryG
            .selectAll('g')
            .selectAll('*:not(title)')
            .size() === 0 && primaryG.selectAll('*:not(title)').size()) > 1
        ? 's'
        : '';
    var groupNameString = groupName || geomType + ' group';
    var groupPlural = primaryG.selectAll('g').size() > 1 ? 's' : '';
    var count = !recursive
        ? primaryG.selectAll('g').size()
            ? primaryG.selectAll('g').size() +
                ' ' +
                groupNameString +
                groupPlural +
                ' containing a total ' +
                (primaryG
                    .selectAll('g')
                    .selectAll('*:not(title)')
                    .size() -
                    primaryG
                        .selectAll('g')
                        .selectAll('.vcl-accessibility-focus-highlight')
                        .size()) +
                ' ' +
                geomType +
                plural
            : primaryG.selectAll('*:not(title)').size() -
                primaryG.selectAll('.vcl-accessibility-focus-highlight').size() +
                ' ' +
                geomType +
                plural
        : primaryG.selectAll('g').size() +
            ' ' +
            geomType +
            plural +
            ' (more ' +
            geomType +
            's may be revealed upon interaction)';
    d3Selection.select(rootEle)
        .select('.vcl-access-layout')
        .text("This is a " + chartTag + " with " + count + ".");
};
var setAccessXAxis = function (_a) {
    var rootEle = _a.rootEle, hasXAxis = _a.hasXAxis, xAxis = _a.xAxis, xAxisLabel = _a.xAxisLabel;
    var label = emptyDescriptions['vcl-access-xAxis'];
    if (hasXAxis) {
        var xDomain = xAxis && xAxis.formattedTicks && xAxis.formattedTicks[0] ? xAxis.formattedTicks : [];
        var xAxisTitle = xAxisLabel ? ", titled " + xAxisLabel : '';
        var xAxisRange = xDomain.length
            ? " with a range that starts with " + xDomain[0] + " and ends with " + xDomain[xDomain.length - 1]
            : '';
        label = "The chart has a horizontal X Axis" + xAxisTitle + xAxisRange + ".";
    }
    d3Selection.select(rootEle)
        .select('.vcl-access-xAxis')
        .text(label);
};
var setAccessYAxis = function (_a) {
    var rootEle = _a.rootEle, hasYAxis = _a.hasYAxis, yAxis = _a.yAxis, secondaryYAxis = _a.secondaryYAxis, yAxisLabel = _a.yAxisLabel, secondaryYAxisLabel = _a.secondaryYAxisLabel, xAxisLabel = _a.xAxisLabel;
    var label = emptyDescriptions['vcl-access-yAxis'];
    // y axis range from min to max
    // secondary y axis range from min to max e.g for pareto-chart.
    var yAxisTicks;
    if (yAxis && yAxis.formattedTicks) {
        yAxisTicks = yAxis.formattedTicks;
    }
    var secondaryYAxisTicks;
    if (secondaryYAxis && secondaryYAxis.formattedTicks) {
        secondaryYAxisTicks = secondaryYAxis.formattedTicks;
    }
    if (hasYAxis) {
        if (secondaryYAxisTicks) {
            // secondary y axis present
            var yAxis1Title = yAxisLabel ? ", titled " + yAxisLabel : '';
            var yAxis1Ticks = yAxisTicks
                ? " with a range that starts with " + yAxisTicks[0] + " and ends with " + yAxisTicks[yAxisTicks.length - 1]
                : '';
            var yAxis2Title = secondaryYAxisLabel ? ", titled " + secondaryYAxisLabel : '';
            var yAxis2Ticks = secondaryYAxisTicks
                ? " with a range that starts with " + secondaryYAxisTicks[0] + " and ends with " + secondaryYAxisTicks[secondaryYAxisTicks.length - 1]
                : '';
            label = "The chart has a primary vertical Y Axis" + yAxis1Title + yAxis1Ticks + ". ";
            label += "The chart has a secondary vertical Y Axis" + yAxis2Title + yAxis2Ticks + ".";
        }
        else if (!(typeof yAxis === 'function')) {
            // y axis is an object that may contain multiple axes
            // parallel plot uses this
            var yLabels = Object.keys(yAxis);
            var firstYDomain = yAxis[yLabels[0]].y && yAxis[yLabels[0]].y.formattedTicks && yAxis[yLabels[0]].y.formattedTicks[0]
                ? yAxis[yLabels[0]].y.formattedTicks
                : [];
            var y1Range = firstYDomain.length
                ? ", with a range that starts with " + firstYDomain[0] + " and ends with " + firstYDomain[firstYDomain.length - 1]
                : '';
            label =
                yLabels.length > 1
                    ? "The chart has " + yLabels.length + " vertical Y Axis sections, all using different scales" + (xAxisLabel ? '. This series is titled ' + xAxisLabel : '') + "."
                    : "The chart has a vertical Y Axis, titled " + yLabels[0] + y1Range + ".";
            if (yLabels.length > 1) {
                // the yAxis objected *does* contain multiple objects!
                var i = 0;
                for (i = 0; i < yLabels.length; i++) {
                    var labelScale = yAxis[yLabels[i]].y;
                    var iYDomain = labelScale && labelScale.formattedTicks && labelScale.formattedTicks[0] ? labelScale.formattedTicks : [];
                    var iYRange = iYDomain.length
                        ? ", with a range that starts with " + iYDomain[0] + " and ends with " + iYDomain[iYDomain.length - 1]
                        : '';
                    label += " Y Axis " + (i + 1) + " of " + yLabels.length + ", titled " + yLabels[i] + iYRange + ".";
                }
            }
        }
        else {
            // only one axis present
            var yDomain = yAxis && yAxis.formattedTicks && yAxis.formattedTicks[0] ? yAxis.formattedTicks : [];
            var yAxisTitle = yAxisLabel ? ", titled " + yAxisLabel : '';
            var yAxisRange = yDomain.length
                ? " with a range that starts with " + yDomain[0] + " and ends with " + yDomain[yDomain.length - 1]
                : '';
            label = "The chart has a vertical Y axis" + yAxisTitle + yAxisRange + ".";
        }
    }
    d3Selection.select(rootEle)
        .select('.vcl-access-yAxis')
        .text(label);
};
var setAccessStructure = function (rootEle, structure) {
    setDescriptionNode(d3Selection.select(rootEle).select('.vcl-accessibility-instructions'), structure, 'Notes about the chart structure', 'vcl-access-notes', !!structure);
};
var setAccessAnnotation = function (rootEle, annotations) {
    var parent = d3Selection.select(rootEle).select('.vcl-accessibility-instructions');
    var notesNode = parent.select('.vcl-access-notes').node();
    var header = parent.select('.vcl-access-annotations-heading');
    var instructionsHeading = '.vcl-interaction-instructions';
    var headerLevel = notesNode.dataset.annotationlevel;
    var level1 = findTagLevel(headerLevel, 1);
    var level2 = findTagLevel(headerLevel, 2);
    parent.selectAll('.vcl-access-annotation').remove();
    var i = 1;
    if (annotations && annotations.length) {
        if (!header.size()) {
            header = parent
                .insert(headerLevel, instructionsHeading)
                .attr('class', 'screen-reader-info vcl-access-annotations-heading');
        }
        annotations.forEach(function (annotation) {
            var count = false;
            if (annotation.note) {
                if (annotation.note.title) {
                    count = true;
                    parent
                        .insert(level1, instructionsHeading)
                        .attr('class', 'screen-reader-info vcl-access-annotation')
                        .text(annotation.note.title || 'Annotation ' + i);
                }
                if (annotation.note.label) {
                    count = true;
                    parent
                        .insert(level2, instructionsHeading)
                        .attr('class', 'screen-reader-info vcl-access-annotation')
                        .text(annotation.note.label);
                }
            }
            if (annotation.accessibilityDescription) {
                count = true;
                parent
                    .insert(level2, instructionsHeading)
                    .attr('class', 'screen-reader-info vcl-access-annotation')
                    .text(annotation.accessibilityDescription);
            }
            if (count) {
                i++;
            }
        });
    }
    if (i - 1) {
        var plural = i - 2 > 0 ? 's' : '';
        var headingText = i - 1 + ' annotation' + plural + ' on the chart';
        header.text(headingText);
    }
    else {
        header.remove();
    }
};
var setAccessibilityDescriptionWidth = function (uniqueID, width) {
    d3Selection.select('#chart-instructions-' + uniqueID).style('width', function () {
        return Math.max(width, 200) + 'px';
    });
};
var findTagLevel = function (startLevel, depthFromStart) {
    if (startLevel === 'p' || startLevel === 'P' || !startLevel) {
        return 'p';
    }
    else if (startLevel === 'span' || startLevel === 'SPAN') {
        return 'span';
    }
    else if (startLevel === 'div' || startLevel === 'DIV') {
        return 'div';
    }
    var depth = depthFromStart || 0;
    var start = typeof startLevel !== 'string' || startLevel.length <= 1 ? startLevel : startLevel[1];
    if (+start + depth < 7 && depth < 3) {
        return 'h' + (+start + depth);
    }
    return 'p';
};
var focusInstructions = function (_, i, n) {
    d3Selection.select(n[i])
        .style('width', 'auto')
        .style('height', 'auto')
        .style('left', 'auto')
        .style('top', '15px')
        .style('background', 'white')
        .style('z-index', 9999);
};
var blurInstructions = function (_, i, n) {
    d3Selection.select(n[i])
        .style('width', null)
        .style('height', null)
        .style('left', null)
        .style('top', null)
        .style('background', null)
        .style('z-index', null);
};
var setDescriptionNode = function (root, description, headingText, tag, contentExists, headingTag) {
    var contentNode = root.select('.' + tag).text(description || emptyDescriptions[tag]);
    var headingNode = root.select('.' + (headingTag || tag) + '-heading');
    if (contentExists) {
        if (!headingNode.size()) {
            headingNode = root
                .insert(contentNode.node().dataset.level, '.' + (headingTag || tag))
                .attr('class', 'screen-reader-info ' + (headingTag || tag) + '-heading');
        }
        headingNode.text(headingText);
    }
    else {
        headingNode.remove();
    }
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function getPadding(padding) {
    var paddingSetting;
    if (padding === 'large') {
        paddingSetting = {
            top: 40,
            bottom: 60,
            right: 100,
            left: 80
        };
    }
    else if (padding === 'small') {
        paddingSetting = {
            top: 10,
            bottom: 20,
            right: 40,
            left: 40
        };
    }
    else if (padding === '') {
        paddingSetting = {
            top: 20,
            bottom: 50,
            right: 70,
            left: 60
        };
    }
    return paddingSetting;
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
// import { selection } from 'd3-selection';
// in production build t.moveToFront() was erroring as not a function, refactored
function moveToFront(selection) {
    // selection.prototype.moveToFront = function() {
    return selection.each(function () {
        this.parentNode.appendChild(this);
    });
    // };
    // return node.moveToFront();
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
var mapButtons = {
    alaska: 'M0.2,1ZM0,0ZM0.1,0.3ZM0,0.2L8.1,6.9L3.8,7.5L0,0.2ZM0,0.3ZM0.5,1.2L0.5,1.2ZM1.4,2.5L1.4,2.5ZM5.1,6.6L5.1,6.6ZM1,0.7L4,7.2L1,0.7ZM0,0ZM0.6,0.8L5.5,4.1L0.6,0.8ZM2.1,0ZM0.8,0ZM51.5,5.8L60.5,5.3L66.9,10.4L68.9,20.3L70.9,30.2L72.8,40.1L74.8,50L76.8,60L82.9,61.6L89.5,68.2L94.3,62.3L101.8,67.6L108.9,74.6L116.4,77.9L119.6,85.6L114.5,84.3L110.2,81.3L105.5,75.8L98.9,70.1L97.7,69.7L92.3,68.5L92.3,71.8L83.6,67.7L79.2,66.4L69.8,66.2L62.1,64.5L59.9,61.7L56,64L53.2,68.1L47.1,73.4L45.4,70.6L48.6,62.5L45.6,62.8L41.4,70.4L40.4,75.3L34.9,81.6L29.7,87.2L23.9,90.9L18,93.5L11.9,94.7L7.5,97.8L2.3,99.3L5.3,96.9L12.3,92.3L16.4,91.7L23.2,86.2L27.5,77.7L23.2,76L18.8,74.1L14,72.7L11.2,67.6L5.2,62.2L3.5,56.3L8.3,49.6L15.4,46.7L19.5,41.1L16.1,39.7L8.9,38.9L4.8,32.3L9.5,28.7L14.2,29.8L19.4,28.7L20,27.4L15.2,21.7L10.7,14.4L18.3,10.6L24.8,4.6L32.7,0.2L36.9,1.5L43.1,4.9ZM0.9,2.9L0.9,2.9ZM2.6,2.8L7.4,1.5L3.5,6.8L2.6,2.8ZM0.7,0ZM0.6,0ZM1.4,0ZM1.1,0ZM0.4,0ZM0.5,0ZM0,0ZM0.5,0ZM1.2,0.3ZM3.2,0.1L3.2,0.1ZM5.6,0.1L0.1,3.6L5.6,0.1ZM0,1.8L0,1.8ZM0.9,0ZM0.6,0ZM0.6,0ZM0.7,0L6.6,4.9L0.7,0ZM0.6,0ZM0,0ZM2.6,0.6L2.6,0.6ZM1.7,0.8ZM0.8,0ZM0,0ZM1.6,0.8Z',
    hawaii: 'M67.6,57L65.7,56.3L63.8,55.6L62.9,53.9L63.1,51.9L63.3,49.9L62.5,48.1L61.7,46.2L60.9,44.4L61.2,42.7L62.7,41.3L63.6,39.5L64.1,37.7L63.2,36L63.6,34.2L65.4,35.1L67.2,36.1L69.1,36.9L71,37.5L72.9,38.2L74.5,39.4L76.1,40.7L76.4,42.5L77.5,44.1L79.1,45.3L80.7,46.6L80.2,48L78.8,49.5L77.1,50.4L75.1,50.9L73.2,51.5L71.5,52.6L69.8,53.7L68.6,55.3ZM51.8,20.9L53.1,22.6L54.7,22.8L56.6,22.5L58.5,23.5L60.4,24.5L61.1,25.9L60.1,27.6L58.1,28L56,28.5L54.1,28.2L53.9,26.1L52.7,24.9L50.8,24.2L50.3,22.4L51.8,20.9ZM45.3,17.8L43.9,19.4L41.9,19.6L40,19.4L41.1,17.6L43.2,17.7ZM29.4,9.3L30.3,11.3L31.2,13.2L30.5,15.2L28.8,15.9L26.7,16L25.8,14L24.9,12.1L25.7,11.2L27.7,10.5L29.4,9.3ZM4.7,0L6.7,0.4L7.4,2.4L6.9,4.6L5.2,6L3.2,5.4L1.2,4.6L0,3.3L0.6,1.2L2.6,0.6Z',
    puertoRico: 'M37.3,0L35.4,0.7L34.6,2.3L33.8,4.2L32.5,5.6L30.9,6.7L30.2,8.4L31.3,10.1L32.9,11.3L33.7,13.1L33.9,15L33.6,17L33.2,19L32.5,20.9L32.8,22.9L32.1,24.7L32.6,26.5L34.1,26.2L36,26.9L37.8,26.5L39.8,26.2L41.8,26.5L43.7,27L45.7,27.2L47.7,27L49.6,26.5L51.4,25.6L53.2,25.1L55.2,25.4L57.1,25.9L59.1,25.9L61.2,25.9L63.1,25.5L65,25.3L67,25.8L68.6,26.9L70.5,26.3L72.4,26.4L74.4,26.7L76.4,26.8L78.3,26.8L80,27.3L82,26.7L83.9,26.2L85.9,25.8L87.9,25.7L89.9,25.4L91.8,24.8L93.6,23.9L94.6,22.2L95.8,20.6L96.9,19L97.8,17.2L99.5,16.2L101.1,15L103,14.3L104.7,13.4L105.1,12.1L104,10.5L103.7,8.5L104.2,6.6L102.5,6.2L100.5,6.1L98.6,5.5L96.7,4.7L94.9,3.8L93,3.4L91,2.9L89,2.7L87,2.6L85,2.6L83.1,2.1L81.1,2.3L79.1,2.7L77.3,1.9L75.3,1.7L73.3,1.5L71.3,1.3L69.3,1.1L67.3,1.3L65.3,1.6L63.3,1.5L61.3,1.2L59.3,1.1L57.3,1.2L55.3,1.4L53.3,1.4L51.3,1.2L49.3,1.1L47.2,1.2L45.2,1.1L43.3,0.7L41.3,0.3L39.3,0.1L37.3,0ZM105,5.5ZM20.4,5.8ZM106.8,6.1ZM107.8,6.6ZM115.1,6.6ZM105.7,7ZM116.2,7L116.7,9.1L118.3,10.2L120.1,9.8L120.2,8.5L118.3,7.5L116.2,7ZM114,8ZM105.5,8.7ZM104.2,8.9ZM-1,16.4ZM114,16.5L112,16.7L110.1,17.3L108.2,17.8L106.5,18.7L106.8,20.1L108.7,20.4L110.7,20.1L112.6,19.7L114.6,19.3L116.5,18.8L118.3,18L117.9,17L116,16.7ZM2.8,18.2L0.6,18.5L-0.1,20.4L1.9,21.4L3.8,20.2L2.8,18.2ZM58.2,25.9ZM41.3,26.6ZM37,27.8ZM63.5,28.7Z',
    continentalUS: 'M78.9,25.6L79.9,23.8L81.4,27.2L81.4,23.5L82.8,21.8L84.4,18.8L83.3,18.3L86.8,16.4L87.2,14.9L87.2,11.2L90,8.7L89.5,5.7L87.2,3L85.5,6.1L83.4,9.2L79.6,10.2L77.4,13.3L74.4,15L72.2,18L68.9,20.1L68,17.6L66.1,15.3L65.8,12.1L62.8,13L61.6,16.5L61.5,20.2L59.6,17.9L60,14L60,12.1L63.6,10.7L62.9,9.2L59,9.6L57.1,9L53.6,9.7L54.9,7.7L53.1,6.8L49.3,5.9L45.8,5.1L41.8,5.1L37.8,4.9L33.8,4.6L29.8,4.2L25.8,3.7L21.9,3L18,2.2L14,1.4L10.2,0.4L7.6,1.6L4.5,1.1L4.2,5L2.9,8.8L1.2,12.4L0.4,16.2L0.1,20.1L1.2,24L1.8,27.8L2.8,31.5L6,33.8L8.1,37.1L11.8,38.1L15.2,40.2L18.7,42.1L22.7,42.6L26.5,42.1L29.4,44.8L31.4,48.2L34.5,47.1L37.6,49.3L39.6,52.7L42,55.6L43.6,53.8L45.8,50.7L49.1,48.4L52.9,47.9L56,48.7L59.6,48.4L59.3,45.9L63.2,45.6L67,46.3L70.5,46.3L72.3,49.6L74.2,52.8L77,55.3L78,51.8L76.3,48.1L74.3,44.7L74.5,40.8L76.9,37.7L79.2,34.8L81.2,31.9L81.2,28.5L78.9,25.6ZM75.2,56.8ZM76.5,56.3L76.5,56.3ZM82,32.1L82,32.1ZM88.4,16.4ZM87.5,16.5ZM88.6,9.7ZM89.3,9.2ZM80.4,25.4ZM56.6,7.2ZM65.2,10.4ZM6.8,0.2ZM44.1,55.7L44.6,51.7L44.1,55.7ZM3.3,32.7ZM3.5,32.7ZM5.5,34.7ZM5.4,35.5Z'
};

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function transitionEndAll(transition, callback) {
    var n = 0;
    transition
        .each(function () {
        ++n;
    })
        .on('end', function () {
        if (!--n)
            callback.apply(this, arguments);
    });
}

/**
 * Copyright (c) 2020 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function resolveLines(left, right, key) {
    var output = [[], []];
    if (left.length < 1 || right.length < 1)
        return [];
    var leftKeys = {};
    var rightKeys = {};
    var deltas = [];
    var i = 0;
    for (i = 0; i < left.length; i++) {
        leftKeys[left[i][key]] = 1;
    }
    i = 0;
    for (i = 0; i < right.length; i++) {
        rightKeys[right[i][key]] = 1;
        if (leftKeys[right[i][key]]) {
            deltas.push(0);
        }
        else {
            deltas.push(1);
        }
    }
    i = 0;
    var rightPointer = 0;
    var leftPointer = 0;
    function push(change) {
        var leftElement = __assign({}, left[leftPointer]);
        var rightElement = __assign({}, right[rightPointer]);
        if (change) {
            leftElement[change] = true;
            rightElement[change] = true;
        }
        output[0].push(leftElement);
        output[1].push(rightElement);
    }
    function movePointers(leftChange, rightChange) {
        leftPointer = leftPointer + leftChange;
        rightPointer = rightPointer + rightChange;
    }
    var changeCounter = 0;
    var end = false;
    while (leftPointer < left.length && rightPointer < right.length) {
        var start = rightPointer !== 0 ? false : true;
        var adding = deltas[rightPointer];
        var removing = end && adding ? false : !rightKeys[left[leftPointer][key]];
        var retaining = !end && !removing ? true : false;
        if (removing) {
            var firstMove = !start && !end ? [0, -1] : [0, 0];
            var secondMove = !start && !end ? [1, 1] : [1, 0];
            movePointers(firstMove[0], firstMove[1]);
            push('exit');
            movePointers(secondMove[0], secondMove[1]);
        }
        else if (adding) {
            push('enter');
            movePointers(0, 1);
        }
        else if (retaining) {
            push(false);
            movePointers(1, 1);
        }
        if (!end && leftPointer === left.length && rightPointer < right.length) {
            end = true;
            movePointers(-1, 0);
        }
        else if (!end && leftPointer < left.length && rightPointer === right.length) {
            end = true;
            movePointers(0, -1);
        }
        changeCounter += removing || adding ? 1 : 0;
    }
    if (!changeCounter) {
        return [];
    }
    return output;
}
function generalizePath(element, targetLength) {
    var l = element.getTotalLength();
    var i = 0;
    var increment = l / targetLength;
    var path = 'M';
    while (i <= l) {
        if (i) {
            path += 'L';
        }
        var point = element.getPointAtLength(i);
        path += point.x + ',' + point.y;
        i += increment;
    }
    path += 'Z';
    return path;
}
function equalizePath(element, limit) {
    var l = element.getTotalLength();
    try {
        if (l > limit)
            throw 'Path length exceeds supplied limit. Raise limit.';
    }
    catch (err) {
        console.log(err);
    }
    var i = 0;
    var increment = 1;
    var path = 'M';
    var point = {};
    while (i <= l) {
        if (i) {
            path += 'L';
        }
        point = element.getPointAtLength(i);
        path += point['x'] + ',' + point['y'];
        i += increment;
    }
    while (i <= limit) {
        path += point['x'] + ',' + point['y'];
        i += increment;
    }
    path += 'Z';
    return path;
}

var version = "4.13.0";

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number$1(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$1(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number$1(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity$1(x) {
  return x;
}

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity$1,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function threshold(values, p, valueof) {
  if (valueof == null) valueof = number$1;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number$1).sort(ascending);
  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$1(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number$1(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$1(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number$1(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return threshold(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

var slice$1 = Array.prototype.slice;

function identity$2(x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon$1 = 1e-6;

function translateX$1(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY$1(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number$2(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center$1(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering$1() {
  return !this.__axis;
}

function axis$1(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX$1 : translateY$1;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$2) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center$1 : number$2)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon$1)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon$1)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering$1)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice$1.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis$1(top, scale);
}

function axisRight(scale) {
  return axis$1(right, scale);
}

function axisBottom(scale) {
  return axis$1(bottom, scale);
}

function axisLeft(scale) {
  return axis$1(left, scale);
}

function constant$1(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

function brush() {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = d3Selection.mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = d3Selection.mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max$1 = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = d3Array.range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3Array.range(n));
      k += x;
    }

    // Sort groups
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max$1(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice$2 = Array.prototype.slice;

function constant$2(x) {
  return function() {
    return x;
  };
}

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$2.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = d3Path.path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$2(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
}

var prefix = "$";

function Map$1() {}

Map$1.prototype = map$1.prototype = {
  constructor: Map$1,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map$1(object, f) {
  var map = new Map$1;

  // Copy constructor.
  if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set$1() {}

var proto = map$1.prototype;

Set$1.prototype = set.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set$1;

  // Copy constructor.
  if (object instanceof Set$1) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18,
    Xn = 0.950470, // D65 standard referent
    Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty$1() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty$1 : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$3(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$3(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local$1() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local$1.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

function nopropagation$1() {
  event.stopImmediatePropagation();
}

function noevent$1() {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent$1, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent$1, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent$1, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant$4(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter$1() {
  return !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function drag() {
  var filter = defaultFilter$1,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture) return;
    select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(event.view);
    nopropagation$1();
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent$1();
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent$1();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
        nopropagation$1();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent$1();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation$1();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$4(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$4(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function dsv(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
}

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi$1 = Math.PI,
    halfPi$1 = pi$1 / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi$1);
}

function sinOut(t) {
  return Math.sin(t * halfPi$1);
}

function sinInOut(t) {
  return (1 - Math.cos(pi$1 * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau$1 = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$1);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau$1); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$1);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau$1); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$1);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau$1); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

function center$2(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function constant$5(x) {
  return function() {
    return x;
  };
}

function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function x$1(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$5(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x$1, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function link(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant$5(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = d3Collection.map(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$5(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$2(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function simulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = d3Collection.map(),
      stepper = d3Timer.timer(step),
      event = d3Dispatch.dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody() {
  var nodes,
      node,
      alpha,
      strength = constant$5(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x$2, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial(radius, x, y) {
  var nodes,
      strength = constant$5(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant$5(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$3(x) {
  var strength = constant$5(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$5(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : x;
  };

  return force;
}

function y$2(y) {
  var strength = constant$5(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$5(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : y;
  };

  return force;
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent$1(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

function formatDefault(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

function identity$3(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
}

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add$1(temp, y, this.t);
    add$1(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add$1(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon$2 = 1e-6;
var epsilon2 = 1e-12;
var pi$2 = Math.PI;
var halfPi$2 = pi$2 / 2;
var quarterPi = pi$2 / 4;
var tau$2 = pi$2 * 2;

var degrees = 180 / pi$2;
var radians = pi$2 / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$2 : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
}

function haversin(x) {
  return (x = sin$1(x / 2)) * x;
}

function noop$1() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();

var areaSum = adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau$2 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$1;
  },
  sphere: function() {
    areaSum.add(tau$2);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos$1(phi),
      sinPhi = sin$1(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos$1(adLambda),
      v = k * sdLambda * sin$1(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00$1, phi00$1, // first point
    p0, // previous 3D point
    deltaSum = adder(),
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$2) phi1 = 90;
    else if (deltaSum < -epsilon$2) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00$2, phi00$2, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: noop$1,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
}

function constant$6(x) {
  return function() {
    return x;
  };
}

function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

function rotationIdentity(lambda, phi) {
  return [lambda > pi$2 ? lambda - tau$2 : lambda < -pi$2 ? lambda + tau$2 : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$2) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi$2 ? lambda - tau$2 : lambda < -pi$2 ? lambda + tau$2 : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi),
      sinDeltaPhi = sin$1(deltaPhi),
      cosDeltaGamma = cos$1(deltaGamma),
      sinDeltaGamma = sin$1(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
}

// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos$1(radius),
      sinRadius = sin$1(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau$2;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$2;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau$2 - epsilon$2) % tau$2;
}

function circle() {
  var center = constant$6([0, 0]),
      radius = constant$6(90),
      precision = constant$6(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant$6([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant$6(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link$1(subject);
  link$1(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link$1(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum$1 = adder();

function polygonContains(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [sin$1(lambda), -cos$1(lambda), 0],
      angle = 0,
      winding = 0;

  sum$1.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin$1(phi0),
        cosPhi0 = cos$1(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin$1(phi1),
          cosPhi1 = cos$1(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > pi$2,
          k = sinPhi0 * sinPhi1;

      sum$1.add(atan2(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
      angle += antimeridian ? delta + sign * tau$2 : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);
}

function clip(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = d3Array.merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$2, -halfPi$2]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi$2 : -pi$2,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi$2) < epsilon$2) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$2) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon$2
      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi$2;
    stream.point(-pi$2, phi);
    stream.point(0, phi);
    stream.point(pi$2, phi);
    stream.point(pi$2, 0);
    stream.point(pi$2, -phi);
    stream.point(0, -phi);
    stream.point(-pi$2, -phi);
    stream.point(-pi$2, 0);
    stream.point(-pi$2, phi);
  } else if (abs(from[0] - to[0]) > epsilon$2) {
    var lambda = from[0] < to[0] ? pi$2 : -pi$2;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle(radius) {
  var cr = cos$1(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos$1(lambda) * cos$1(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi$2 : -pi$2), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon$2;
            point1[1] += epsilon$2;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi$2) < epsilon$2,
        meridian = polar || delta < epsilon$2;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi$2 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi$2 - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$2, radius - pi$2]);
}

function clipLine(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = d3Array.merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent$1() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder(),
    lambda0$2,
    sinPhi0$1,
    cosPhi0$1;

var lengthStream = {
  sphere: noop$1,
  point: noop$1,
  lineStart: lengthLineStart,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop$1;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin$1(phi),
      cosPhi = cos$1(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos$1(delta),
      sinDelta = sin$1(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length$1(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length$1(object);
}

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon$2;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = d3Array.range(y0, y1 - epsilon$2, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = d3Array.range(x0, x1 - epsilon$2, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$2; }).map(x))
        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$2; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
      .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}

function graticule10() {
  return graticule()();
}

function interpolate(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos$1(y0),
      sy0 = sin$1(y0),
      cy1 = cos$1(y1),
      sy1 = sin$1(y1),
      kx0 = cy0 * cos$1(x0),
      ky0 = cy0 * sin$1(x0),
      kx1 = cy1 * cos$1(x1),
      ky1 = cy1 * sin$1(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin$1(d);

  var interpolate = d ? function(t) {
    var B = sin$1(t *= d) / k,
        A = sin$1(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
}

function identity$4(x) {
  return x;
}

var areaSum$1 = adder(),
    areaRingSum$1 = adder(),
    x00,
    y00,
    x0$1,
    y0$1;

var areaStream$1 = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity,
    y0$2 = x0$2,
    x1 = -x0$2,
    y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0,
    Y0$1 = 0,
    Z0$1 = 0,
    X1$1 = 0,
    Y1$1 = 0,
    Z1$1 = 0,
    X2$1 = 0,
    Y2$1 = 0,
    Z2$1 = 0,
    x00$1,
    y00$1,
    x0$3,
    y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau$2);
        break;
      }
    }
  },
  result: noop$1
};

var lengthSum$1 = adder(),
    lengthRing,
    x00$2,
    y00$2,
    x0$4,
    y0$4;

var lengthStream$1 = {
  point: noop$1,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop$1;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

function index$1(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform$1(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = clipAntimeridian, // clip angle
      x0 = null, y0, x1, y1, postclip = identity$4, // clip extent
      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * radians, point[1] * radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi$2 / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos$1(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin$1(y)) / n;
    return [r * sin$1(x *= n), r0 - r * cos$1(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos$1(x),
        cy = cos$1(y),
        k = scale(cx * cy);
    return [
      k * cy * sin$1(x),
      k * sin$1(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin$1(c),
        cc = cos$1(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin$1(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi$2 + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi$2];
};

function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau$2);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi$2 * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi$2 + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }
    else { if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }
    var r = f / pow(tany(y), n);
    return [r * sin$1(n * x), f - r * cos$1(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];
  };

  return project;
}

function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon$2) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

function gnomonicRaw(x, y) {
  var cy = cos$1(y), k = cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function identity$5() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity$4, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity$4,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon$2 && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos$1(y) * sin$1(x), sin$1(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon$2);
}

function stereographicRaw(x, y) {
  var cy = cos$1(y), k = 1 + cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi$2 + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi$2];
};

function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Dont include the roots parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice$3 = Array.prototype.slice;

function shuffle$1(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle$1(slice$3.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant$7(x) {
  return function() {
    return x;
  };
}

function defaultRadius$1(d) {
  return Math.sqrt(d.value);
}

function index$2() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius$1))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$7(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix$1 = "$", // Protect against keys like __proto__.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix$1 + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix$1 + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$3() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$7(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$7(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$7(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$7(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$7(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant$8(x) {
  return function() {
    return x;
  };
}

function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$8(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$8(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array$1(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object$1(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolateValue(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$8(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array$1
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees$1 = 180 / Math.PI;

var identity$6 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity$6;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity$6;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$6;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2$1 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2$1) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl$1(hue) {
  return function(start, end) {
    var h = hue((start = hsl(start)).h, (end = hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue) {
  return function(start, end) {
    var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$1(start, end) {
      var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$1.gamma = cubehelixGamma;

    return cubehelix$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

var pi$3 = Math.PI,
    tau$3 = 2 * pi$3,
    epsilon$3 = 1e-6,
    tauEpsilon = tau$3 - epsilon$3;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$3)) ;

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi$3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon$3) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau$3 + tau$3;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$3) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$3)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function area$1(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

function centroid$1(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross$1(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function hull(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

function contains$1(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

function length$2(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

var slice$4 = [].slice;

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = slice$4.call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try { start(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}

function defaultSource$1() {
  return Math.random();
}

var uniform = (function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(defaultSource$1);

var normal = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(defaultSource$1);

var logNormal = (function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(defaultSource$1);

var irwinHall = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(defaultSource$1);

var bates = (function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(defaultSource$1);

var exponential$1 = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(defaultSource$1);

function request(url, callback) {
  var request,
      event = d3Dispatch.dispatch("beforesend", "progress", "load", "error"),
      mimeType,
      headers = d3Collection.map(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", ).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", ).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
}

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}

function type$1(defaultMimeType, response) {
  return function(url, callback) {
    var r = request(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
}

var html = type$1("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

var json = type$1("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
});

var text = type$1("text/plain", function(xhr) {
  return xhr.responseText;
});

var xml = type$1("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

function dsv$1(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = request(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
}

function responseOf(parse, row) {
  return function(request) {
    return parse(request.responseText, row);
  };
}

var csv$1 = dsv$1("text/csv", csvParse);

var tsv$1 = dsv$1("text/tab-separated-values", tsvParse);

var array$2 = Array.prototype;

var map$2 = array$2.map;
var slice$5 = array$2.slice;

var implicit = {name: "implicit"};

function ordinal(range) {
  var index = map$1(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice$5.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point$1() {
  return pointish(band().paddingInner(1));
}

function constant$9(x) {
  return function() {
    return x;
  };
}

function number$3(x) {
  return +x;
}

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$9(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = interpolateValue,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$2.call(_, number$3), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice$5.call(_), interpolate = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}

function tickFormat$1(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat$1(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$2() {
  var scale = continuous(deinterpolateLinear, interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear$2());
  };

  return linearish(scale);
}

function identity$7() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$2.call(_, number$3), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity$7().domain(domain);
  };

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant$9(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log$1() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log$1().base(base));
  };

  return scale;
}

function raise$1(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow$1() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))
        ? function(x) { return (raise$1(x, exponent) - a) / b; }
        : constant$9(b);
  }

  function reinterpolate(a, b) {
    b = raise$1(b, exponent) - (a = raise$1(a, exponent));
    return function(t) { return raise$1(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow$1().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt$1() {
  return pow$1().exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}

function quantize$1() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice$5.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize$1()
        .domain([x0, x1])
        .range(range);
  };

  return linearish(scale);
}

function threshold$1() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold$1()
        .domain(domain)
        .range(range);
  };

  return scale;
}

var t0$1 = new Date,
    t1$1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

var durationSecond$1 = 1000,
    durationMinute$1 = durationSecond$1 * 60,
    durationHour$1 = durationMinute$1 * 60,
    durationDay$1 = durationHour$1 * 24,
    durationWeek$1 = durationDay$1 * 7,
    durationMonth = durationDay$1 * 30,
    durationYear = durationDay$1 * 365;

function date$1(t) {
  return new Date(t);
}

function number$4(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(deinterpolateLinear, interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond$1],
    [second,  5,  5 * durationSecond$1],
    [second, 15, 15 * durationSecond$1],
    [second, 30, 30 * durationSecond$1],
    [minute,  1,      durationMinute$1],
    [minute,  5,  5 * durationMinute$1],
    [minute, 15, 15 * durationMinute$1],
    [minute, 30, 30 * durationMinute$1],
    [  hour,  1,      durationHour$1  ],
    [  hour,  3,  3 * durationHour$1  ],
    [  hour,  6,  6 * durationHour$1  ],
    [  hour, 12, 12 * durationHour$1  ],
    [   day,  1,      durationDay$1   ],
    [   day,  2,  2 * durationDay$1   ],
    [  week,  1,      durationWeek$1  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$2.call(_, number$4)) : domain().map(date$1);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

function utcTime() {
  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

function colors(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix();

function rainbow$1(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
}

function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

function constant$a(x) {
  return function constant() {
    return x;
  };
}

var abs$1 = Math.abs;
var atan2$1 = Math.atan2;
var cos$2 = Math.cos;
var max$2 = Math.max;
var min$1 = Math.min;
var sin$2 = Math.sin;
var sqrt$2 = Math.sqrt;

var epsilon$4 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;

function acos$1(x) {
  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
}

function asin$1(x) {
  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant$a(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$3,
        a1 = endAngle.apply(this, arguments) - halfPi$3,
        da = abs$1(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$4)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$4 - epsilon$4) {
      context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$4) {
        context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$4) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
          rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon$4) {
        var p0 = asin$1(rp / r0 * sin$2(ap)),
            p1 = asin$1(rp / r1 * sin$2(ap));
        if ((da0 -= p0 * 2) > epsilon$4) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$4) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos$2(a01),
          y01 = r1 * sin$2(a01),
          x10 = r0 * cos$2(a10),
          y10 = r0 * sin$2(a10);

      // Apply rounded corners?
      if (rc > epsilon$4) {
        var x11 = r1 * cos$2(a11),
            y11 = r1 * sin$2(a11),
            x00 = r0 * cos$2(a00),
            y00 = r0 * sin$2(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi$4) {
          var oc = da0 > epsilon$4 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
              lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$1(rc, (r0 - lc) / (kc - 1));
          rc1 = min$1(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$4)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon$4) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon$4) || !(da0 > epsilon$4)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$4) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
    return [cos$2(a) * r, sin$2(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x$4(p) {
  return p[0];
}

function y$3(p) {
  return p[1];
}

function line() {
  var x = x$4,
      y = y$3,
      defined = constant$a(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$a(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$a(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$a(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area$2() {
  var x0 = x$4,
      x1 = null,
      y0 = constant$a(0),
      y1 = y$3,
      defined = constant$a(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$a(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$a(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$a(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$a(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$a(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending$1(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity$8(d) {
  return d;
}

function pie() {
  var value = identity$8,
      sortValues = descending$1,
      sort = null,
      startAngle = constant$a(0),
      endAngle = constant$a(tau$4),
      padAngle = constant$a(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$a(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area$2().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice$6 = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link$2(curve) {
  var source = linkSource,
      target = linkTarget,
      x = x$4,
      y = y$3,
      context = null;

  function link() {
    var buffer, argv = slice$6.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$a(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$a(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link$2(curveHorizontal);
}

function linkVertical() {
  return link$2(curveVertical);
}

function linkRadial() {
  var l = link$2(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi$4);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$4);
  }
};

var cross$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10),
    kx = Math.sin(tau$4 / 10) * kr,
    ky = -Math.cos(tau$4 / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau$4 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k$1 = 1 / Math.sqrt(12),
    a = (k$1 / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k$1,
        x1 = x0,
        y1 = r * k$1 + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols$1 = [
  circle$2,
  cross$2,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant$a(circle$2),
      size = constant$a(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$a(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$a(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop$2() {}

function point$2(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point$2(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis$2(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed$1(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$3(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$3(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$4(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$4) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$4) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign$1(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$5(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none$1(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant$a([]),
      order = none$2,
      offset = none$1,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$a(slice$6.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$a(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$a(slice$6.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none$1(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none$1(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$1(series, order);
}

function ascending$2(series) {
  var sums = series.map(sum$2);
  return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum$2(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$2(series) {
  return ascending$2(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$2(series).reverse();
}

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke$1() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke$1, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create$1(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set$2(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create$1(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout$1(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout$1(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set$2(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set$2(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$1(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set$2(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get$1(node, id).value[name];
  };
}

function interpolate$1(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction$1(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS$1(fullname, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
}

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get$1(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set$2(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set$2(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get$1(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set$2(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get$1(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start$1(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start$1(name) ? init : set$2;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get$1(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection$1 = selection.prototype.constructor;

function transition_selection() {
  return new Selection$1(this._groups, this._parents);
}

function styleRemove$1(name, interpolate) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction$1(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this
          .styleTween(name, styleRemove$1(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
          : styleConstant$1(name, i, value + ""), priority);
}

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction$1(tweenValue(this, "text", value))
      : textConstant$1(value == null ? "" : value + ""));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$1(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var root$1 = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root$1, name, +i);
      }
    }
  }

  return null;
}

function constant$b(x) {
  return function() {
    return x;
  };
}

function x$5(d) {
  return d[0];
}

function y$4(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$5
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$5)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon$5 || Math.abs(endY - startY) > epsilon$5) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon$5 && y1 - endY > epsilon$5 ? [x0, Math.abs(startX - x0) < epsilon$5 ? startY : y1]
              : Math.abs(endY - y1) < epsilon$5 && x1 - endX > epsilon$5 ? [Math.abs(startY - y1) < epsilon$5 ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon$5 && endY - y0 > epsilon$5 ? [x1, Math.abs(startX - x1) < epsilon$5 ? startY : y0]
              : Math.abs(endY - y0) < epsilon$5 && endX - x0 > epsilon$5 ? [Math.abs(startY - y0) < epsilon$5 ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2$2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon$5
      && Math.abs(y - lArc.circle.cy) < epsilon$5) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon$5
      && Math.abs(y - rArc.circle.cy) < epsilon$5) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$5) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon$5) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$5) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$5) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$5 = 1e-6;
var epsilon2$2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi() {
  var x = x$5,
      y = y$4,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / epsilon$5) * epsilon$5, Math.round(y(d, i, data) / epsilon$5) * epsilon$5];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$b(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$b(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

function constant$c(x) {
  return function() {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity$9 = new Transform(1, 0, 0);

transform$2.prototype = Transform.prototype;

function transform$2(node) {
  return node.__zoom || identity$9;
}

function nopropagation$2() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent$2() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
function defaultFilter$2() {
  return !d3Selection.event.button;
}

function defaultExtent$1() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || identity$9;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable$1() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom$1() {
  var filter = defaultFilter$2,
      extent = defaultExtent$1,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable$1,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      gestures = [],
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(identity$9.translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent$2();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation$2();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent$2();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent$2();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent$2();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        started,
        n = touches.length, i, t, p;

    nopropagation$2();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent$2();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation$2();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$c(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$c(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$c(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$c([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}



var d3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    version: version,
    bisect: bisectRight,
    bisectRight: bisectRight,
    bisectLeft: bisectLeft,
    ascending: ascending,
    bisector: bisector,
    cross: cross,
    descending: descending,
    deviation: deviation,
    extent: extent,
    histogram: histogram,
    thresholdFreedmanDiaconis: freedmanDiaconis,
    thresholdScott: scott,
    thresholdSturges: sturges,
    max: max,
    mean: mean,
    median: median,
    merge: merge,
    min: min,
    pairs: pairs,
    permute: permute,
    quantile: threshold,
    range: sequence,
    scan: scan,
    shuffle: shuffle,
    sum: sum,
    ticks: ticks,
    tickIncrement: tickIncrement,
    tickStep: tickStep,
    transpose: transpose,
    variance: variance,
    zip: zip,
    axisTop: axisTop,
    axisRight: axisRight,
    axisBottom: axisBottom,
    axisLeft: axisLeft,
    brush: brush,
    brushX: brushX,
    brushY: brushY,
    brushSelection: brushSelection,
    chord: chord,
    ribbon: ribbon,
    nest: nest,
    set: set,
    map: map$1,
    keys: keys,
    values: values,
    entries: entries,
    color: color,
    rgb: rgb,
    hsl: hsl,
    lab: lab,
    hcl: hcl,
    cubehelix: cubehelix,
    dispatch: dispatch,
    drag: drag,
    dragDisable: nodrag,
    dragEnable: yesdrag,
    dsvFormat: dsv,
    csvParse: csvParse,
    csvParseRows: csvParseRows,
    csvFormat: csvFormat,
    csvFormatRows: csvFormatRows,
    tsvParse: tsvParse,
    tsvParseRows: tsvParseRows,
    tsvFormat: tsvFormat,
    tsvFormatRows: tsvFormatRows,
    easeLinear: linear,
    easeQuad: quadInOut,
    easeQuadIn: quadIn,
    easeQuadOut: quadOut,
    easeQuadInOut: quadInOut,
    easeCubic: cubicInOut,
    easeCubicIn: cubicIn,
    easeCubicOut: cubicOut,
    easeCubicInOut: cubicInOut,
    easePoly: polyInOut,
    easePolyIn: polyIn,
    easePolyOut: polyOut,
    easePolyInOut: polyInOut,
    easeSin: sinInOut,
    easeSinIn: sinIn,
    easeSinOut: sinOut,
    easeSinInOut: sinInOut,
    easeExp: expInOut,
    easeExpIn: expIn,
    easeExpOut: expOut,
    easeExpInOut: expInOut,
    easeCircle: circleInOut,
    easeCircleIn: circleIn,
    easeCircleOut: circleOut,
    easeCircleInOut: circleInOut,
    easeBounce: bounceOut,
    easeBounceIn: bounceIn,
    easeBounceOut: bounceOut,
    easeBounceInOut: bounceInOut,
    easeBack: backInOut,
    easeBackIn: backIn,
    easeBackOut: backOut,
    easeBackInOut: backInOut,
    easeElastic: elasticOut,
    easeElasticIn: elasticIn,
    easeElasticOut: elasticOut,
    easeElasticInOut: elasticInOut,
    forceCenter: center$2,
    forceCollide: collide,
    forceLink: link,
    forceManyBody: manyBody,
    forceRadial: radial,
    forceSimulation: simulation,
    forceX: x$3,
    forceY: y$2,
    formatDefaultLocale: defaultLocale,
    get format () { return format; },
    get formatPrefix () { return formatPrefix; },
    formatLocale: formatLocale,
    formatSpecifier: formatSpecifier,
    precisionFixed: precisionFixed,
    precisionPrefix: precisionPrefix,
    precisionRound: precisionRound,
    geoArea: area,
    geoBounds: bounds,
    geoCentroid: centroid,
    geoCircle: circle,
    geoClipAntimeridian: clipAntimeridian,
    geoClipCircle: clipCircle,
    geoClipExtent: extent$1,
    geoClipRectangle: clipRectangle,
    geoContains: contains,
    geoDistance: distance,
    geoGraticule: graticule,
    geoGraticule10: graticule10,
    geoInterpolate: interpolate,
    geoLength: length$1,
    geoPath: index$1,
    geoAlbers: albers,
    geoAlbersUsa: albersUsa,
    geoAzimuthalEqualArea: azimuthalEqualArea,
    geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: azimuthalEquidistant,
    geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
    geoConicConformal: conicConformal,
    geoConicConformalRaw: conicConformalRaw,
    geoConicEqualArea: conicEqualArea,
    geoConicEqualAreaRaw: conicEqualAreaRaw,
    geoConicEquidistant: conicEquidistant,
    geoConicEquidistantRaw: conicEquidistantRaw,
    geoEquirectangular: equirectangular,
    geoEquirectangularRaw: equirectangularRaw,
    geoGnomonic: gnomonic,
    geoGnomonicRaw: gnomonicRaw,
    geoIdentity: identity$5,
    geoProjection: projection,
    geoProjectionMutator: projectionMutator,
    geoMercator: mercator,
    geoMercatorRaw: mercatorRaw,
    geoNaturalEarth1: naturalEarth1,
    geoNaturalEarth1Raw: naturalEarth1Raw,
    geoOrthographic: orthographic,
    geoOrthographicRaw: orthographicRaw,
    geoStereographic: stereographic,
    geoStereographicRaw: stereographicRaw,
    geoTransverseMercator: transverseMercator,
    geoTransverseMercatorRaw: transverseMercatorRaw,
    geoRotation: rotation,
    geoStream: geoStream,
    geoTransform: transform$1,
    cluster: cluster,
    hierarchy: hierarchy,
    pack: index$2,
    packSiblings: siblings,
    packEnclose: enclose,
    partition: partition,
    stratify: stratify,
    tree: tree,
    treemap: index$3,
    treemapBinary: binary,
    treemapDice: treemapDice,
    treemapSlice: treemapSlice,
    treemapSliceDice: sliceDice,
    treemapSquarify: squarify,
    treemapResquarify: resquarify,
    interpolate: interpolateValue,
    interpolateArray: array$1,
    interpolateBasis: basis$1,
    interpolateBasisClosed: basisClosed,
    interpolateDate: date,
    interpolateNumber: interpolateNumber,
    interpolateObject: object$1,
    interpolateRound: interpolateRound,
    interpolateString: interpolateString,
    interpolateTransformCss: interpolateTransformCss,
    interpolateTransformSvg: interpolateTransformSvg,
    interpolateZoom: zoom,
    interpolateRgb: interpolateRgb,
    interpolateRgbBasis: rgbBasis,
    interpolateRgbBasisClosed: rgbBasisClosed,
    interpolateHsl: hsl$2,
    interpolateHslLong: hslLong,
    interpolateLab: lab$1,
    interpolateHcl: hcl$2,
    interpolateHclLong: hclLong,
    interpolateCubehelix: cubehelix$2,
    interpolateCubehelixLong: cubehelixLong,
    quantize: quantize,
    path: path,
    polygonArea: area$1,
    polygonCentroid: centroid$1,
    polygonHull: hull,
    polygonContains: contains$1,
    polygonLength: length$2,
    quadtree: quadtree,
    queue: queue,
    randomUniform: uniform,
    randomNormal: normal,
    randomLogNormal: logNormal,
    randomBates: bates,
    randomIrwinHall: irwinHall,
    randomExponential: exponential$1,
    request: request,
    html: html,
    json: json,
    text: text,
    xml: xml,
    csv: csv$1,
    tsv: tsv$1,
    scaleBand: band,
    scalePoint: point$1,
    scaleIdentity: identity$7,
    scaleLinear: linear$2,
    scaleLog: log$1,
    scaleOrdinal: ordinal,
    scaleImplicit: implicit,
    scalePow: pow$1,
    scaleSqrt: sqrt$1,
    scaleQuantile: quantile,
    scaleQuantize: quantize$1,
    scaleThreshold: threshold$1,
    scaleTime: time,
    scaleUtc: utcTime,
    schemeCategory10: category10,
    schemeCategory20b: category20b,
    schemeCategory20c: category20c,
    schemeCategory20: category20,
    interpolateCubehelixDefault: cubehelix$3,
    interpolateRainbow: rainbow$1,
    interpolateWarm: warm,
    interpolateCool: cool,
    interpolateViridis: viridis,
    interpolateMagma: magma,
    interpolateInferno: inferno,
    interpolatePlasma: plasma,
    scaleSequential: sequential,
    create: create,
    creator: creator,
    local: local$1,
    matcher: matcher$1,
    mouse: mouse,
    namespace: namespace,
    namespaces: namespaces,
    clientPoint: point,
    select: select,
    selectAll: selectAll,
    selection: selection,
    selector: selector,
    selectorAll: selectorAll,
    style: styleValue,
    touch: touch,
    touches: touches,
    window: defaultView,
    get event () { return event; },
    customEvent: customEvent,
    arc: arc,
    area: area$2,
    line: line,
    pie: pie,
    areaRadial: areaRadial,
    radialArea: areaRadial,
    lineRadial: lineRadial$1,
    radialLine: lineRadial$1,
    pointRadial: pointRadial,
    linkHorizontal: linkHorizontal,
    linkVertical: linkVertical,
    linkRadial: linkRadial,
    symbol: symbol,
    symbols: symbols$1,
    symbolCircle: circle$2,
    symbolCross: cross$2,
    symbolDiamond: diamond,
    symbolSquare: square,
    symbolStar: star,
    symbolTriangle: triangle,
    symbolWye: wye,
    curveBasisClosed: basisClosed$1,
    curveBasisOpen: basisOpen,
    curveBasis: basis$2,
    curveBundle: bundle,
    curveCardinalClosed: cardinalClosed,
    curveCardinalOpen: cardinalOpen,
    curveCardinal: cardinal,
    curveCatmullRomClosed: catmullRomClosed,
    curveCatmullRomOpen: catmullRomOpen,
    curveCatmullRom: catmullRom,
    curveLinearClosed: linearClosed,
    curveLinear: curveLinear,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural: natural,
    curveStep: step,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore,
    stack: stack,
    stackOffsetExpand: expand,
    stackOffsetDiverging: diverging,
    stackOffsetNone: none$1,
    stackOffsetSilhouette: silhouette,
    stackOffsetWiggle: wiggle,
    stackOrderAscending: ascending$2,
    stackOrderDescending: descending$2,
    stackOrderInsideOut: insideOut,
    stackOrderNone: none$2,
    stackOrderReverse: reverse,
    timeInterval: newInterval,
    timeMillisecond: millisecond,
    timeMilliseconds: milliseconds,
    utcMillisecond: millisecond,
    utcMilliseconds: milliseconds,
    timeSecond: second,
    timeSeconds: seconds,
    utcSecond: second,
    utcSeconds: seconds,
    timeMinute: minute,
    timeMinutes: minutes,
    timeHour: hour,
    timeHours: hours,
    timeDay: day,
    timeDays: days,
    timeWeek: sunday,
    timeWeeks: sundays,
    timeSunday: sunday,
    timeSundays: sundays,
    timeMonday: monday,
    timeMondays: mondays,
    timeTuesday: tuesday,
    timeTuesdays: tuesdays,
    timeWednesday: wednesday,
    timeWednesdays: wednesdays,
    timeThursday: thursday,
    timeThursdays: thursdays,
    timeFriday: friday,
    timeFridays: fridays,
    timeSaturday: saturday,
    timeSaturdays: saturdays,
    timeMonth: month,
    timeMonths: months,
    timeYear: year,
    timeYears: years,
    utcMinute: utcMinute,
    utcMinutes: utcMinutes,
    utcHour: utcHour,
    utcHours: utcHours,
    utcDay: utcDay,
    utcDays: utcDays,
    utcWeek: utcSunday,
    utcWeeks: utcSundays,
    utcSunday: utcSunday,
    utcSundays: utcSundays,
    utcMonday: utcMonday,
    utcMondays: utcMondays,
    utcTuesday: utcTuesday,
    utcTuesdays: utcTuesdays,
    utcWednesday: utcWednesday,
    utcWednesdays: utcWednesdays,
    utcThursday: utcThursday,
    utcThursdays: utcThursdays,
    utcFriday: utcFriday,
    utcFridays: utcFridays,
    utcSaturday: utcSaturday,
    utcSaturdays: utcSaturdays,
    utcMonth: utcMonth,
    utcMonths: utcMonths,
    utcYear: utcYear,
    utcYears: utcYears,
    timeFormatDefaultLocale: defaultLocale$1,
    get timeFormat () { return timeFormat; },
    get timeParse () { return timeParse; },
    get utcFormat () { return utcFormat; },
    get utcParse () { return utcParse; },
    timeFormatLocale: formatLocale$1,
    isoFormat: formatIso,
    isoParse: parseIso,
    now: now,
    timer: timer,
    timerFlush: timerFlush,
    timeout: timeout$1,
    interval: interval$1,
    transition: transition,
    active: active,
    interrupt: interrupt,
    voronoi: voronoi,
    zoom: zoom$1,
    zoomTransform: transform$2,
    zoomIdentity: identity$9
});

function constant$d(x) {
  return function constant() {
    return x;
  };
}

var epsilon$6 = 1e-12;
var pi$5 = Math.PI;
var halfPi$4 = pi$5 / 2;
var tau$5 = 2 * pi$5;

function arcInnerRadius$1(d) {
  return d.innerRadius;
}

function arcOuterRadius$1(d) {
  return d.outerRadius;
}

function arcStartAngle$1(d) {
  return d.startAngle;
}

function arcEndAngle$1(d) {
  return d.endAngle;
}

function arcPadAngle$1(d) {
  return d && d.padAngle; // Note: optional!
}

function asin$2(x) {
  return x >= 1 ? halfPi$4 : x <= -1 ? -halfPi$4 : Math.asin(x);
}

function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents$1(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc$1() {
  var innerRadius = arcInnerRadius$1,
      outerRadius = arcOuterRadius$1,
      cornerRadius = constant$d(0),
      padRadius = null,
      startAngle = arcStartAngle$1,
      endAngle = arcEndAngle$1,
      padAngle = arcPadAngle$1,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$4,
        a1 = endAngle.apply(this, arguments) - halfPi$4,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$6)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$5 - epsilon$6) {
      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$6) {
        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$6) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon$6) {
        var p0 = asin$2(rp / r0 * Math.sin(ap)),
            p1 = asin$2(rp / r1 * Math.sin(ap));
        if ((da0 -= p0 * 2) > epsilon$6) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$6) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Math.cos(a01),
          y01 = r1 * Math.sin(a01),
          x10 = r0 * Math.cos(a10),
          y10 = r0 * Math.sin(a10);

      // Apply rounded corners?
      if (rc > epsilon$6) {
        var x11 = r1 * Math.cos(a11),
            y11 = r1 * Math.sin(a11),
            x00 = r0 * Math.cos(a00),
            y00 = r0 * Math.sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi$5) {
          var oc = da0 > epsilon$6 ? intersect$1(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$6)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon$6) {
        t0 = cornerTangents$1(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon$6) || !(da0 > epsilon$6)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$6) {
        t0 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents$1(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$5 / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$d(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$d(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$d(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$d(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$d(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$d(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$d(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear$1(context) {
  this._context = context;
}

Linear$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear$1(context) {
  return new Linear$1(context);
}

function x$6(p) {
  return p[0];
}

function y$5(p) {
  return p[1];
}

function line$1() {
  var x = x$6,
      y = y$5,
      defined = constant$d(true),
      context = null,
      curve = curveLinear$1,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$d(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$d(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$d(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function point$6(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$6(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$6(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

function point$7(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$6) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$6) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$7(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom$1(context, alpha) : new Cardinal$1(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function sign$2(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3$1(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2$1(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$8(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX$1(context) {
  this._context = context;
}

MonotoneX$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$8(this, this._t0, slope2$1(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$8(this, slope2$1(this, t1 = slope3$1(this, x, y)), t1); break;
      default: point$8(this, this._t0, t1 = slope3$1(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY$1(context) {
  this._context = new ReflectContext$1(context);
}

(MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function(x, y) {
  MonotoneX$1.prototype.point.call(this, y, x);
};

function ReflectContext$1(context) {
  this._context = context;
}

ReflectContext$1.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

var noop$3 = {value: function() {}};

function dispatch$1() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}

function Dispatch$1(_) {
  this._ = _;
}

function parseTypenames$2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch$1.prototype = dispatch$1.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$2(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$3(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$3(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch$1(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$2(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$3(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$3 = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Annotation = function () {
  function Annotation(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        nx = _ref.nx,
        ny = _ref.ny,
        _ref$dy = _ref.dy,
        dy = _ref$dy === undefined ? 0 : _ref$dy,
        _ref$dx = _ref.dx,
        dx = _ref$dx === undefined ? 0 : _ref$dx,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? "grey" : _ref$color,
        data = _ref.data,
        type = _ref.type,
        subject = _ref.subject,
        connector = _ref.connector,
        note = _ref.note,
        disable = _ref.disable,
        id = _ref.id,
        className = _ref.className;
    classCallCheck(this, Annotation);

    this._dx = nx !== undefined ? nx - x : dx;
    this._dy = ny !== undefined ? ny - y : dy;
    this._x = x;
    this._y = y;
    this._color = color;
    this.id = id;
    this._className = className || "";

    this._type = type || "";
    this.data = data;

    this.note = note || {};
    this.connector = connector || {};
    this.subject = subject || {};

    this.disable = disable || [];
  }

  createClass(Annotation, [{
    key: "updatePosition",
    value: function updatePosition() {
      if (this.type.setPosition) {
        this.type.setPosition();
        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawSubject();
        }
      }
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.type.clearComponents && this.type.clearComponents();
    }
  }, {
    key: "updateOffset",
    value: function updateOffset() {
      if (this.type.setOffset) {
        this.type.setOffset();

        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawConnector();
        }

        this.type.redrawNote();
      }
    }
  }, {
    key: "className",
    get: function get$$1() {
      return this._className;
    },
    set: function set$$1(className) {
      this._className = className;
      if (this.type.setClassName) this.type.setClassName();
    }
  }, {
    key: "type",
    get: function get$$1() {
      return this._type;
    },
    set: function set$$1(type) {
      this._type = type;
      this.clearComponents();
    }
  }, {
    key: "x",
    get: function get$$1() {
      return this._x;
    },
    set: function set$$1(x) {
      this._x = x;
      this.updatePosition();
    }
  }, {
    key: "y",
    get: function get$$1() {
      return this._y;
    },
    set: function set$$1(y) {
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "color",
    get: function get$$1() {
      return this._color;
    },
    set: function set$$1(color) {
      this._color = color;
      this.updatePosition();
    }
  }, {
    key: "dx",
    get: function get$$1() {
      return this._dx;
    },
    set: function set$$1(dx) {
      this._dx = dx;
      this.updateOffset();
    }
  }, {
    key: "dy",
    get: function get$$1() {
      return this._dy;
    },
    set: function set$$1(dy) {
      this._dy = dy;
      this.updateOffset();
    }
  }, {
    key: "nx",
    set: function set$$1(nx) {
      this._dx = nx - this._x;
      this.updateOffset();
    }
  }, {
    key: "ny",
    set: function set$$1(ny) {
      this._dy = ny - this._y;
      this.updateOffset();
    }
  }, {
    key: "offset",
    get: function get$$1() {
      return { x: this._dx, y: this._dy };
    },
    set: function set$$1(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      this._dx = x;
      this._dy = y;
      this.updateOffset();
    }
  }, {
    key: "position",
    get: function get$$1() {
      return { x: this._x, y: this._y };
    },
    set: function set$$1(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      this._x = x;
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "translation",
    get: function get$$1() {
      return {
        x: this._x + this._dx,
        y: this._y + this._dy
      };
    }
  }, {
    key: "json",
    get: function get$$1() {
      var json = {
        x: this._x,
        y: this._y,
        dx: this._dx,
        dy: this._dy
      };

      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;
      if (this.type) json.type = this.type;
      if (this._className) json.className = this._className;

      if (Object.keys(this.connector).length > 0) json.connector = this.connector;
      if (Object.keys(this.subject).length > 0) json.subject = this.subject;
      if (Object.keys(this.note).length > 0) json.note = this.note;

      return json;
    }
  }]);
  return Annotation;
}();

var AnnotationCollection = function () {
  function AnnotationCollection(_ref) {
    var annotations = _ref.annotations,
        accessors = _ref.accessors,
        accessorsInverse = _ref.accessorsInverse;
    classCallCheck(this, AnnotationCollection);

    this.accessors = accessors;
    this.accessorsInverse = accessorsInverse;
    this.annotations = annotations;
  }

  createClass(AnnotationCollection, [{
    key: "clearTypes",
    value: function clearTypes(newSettings) {
      this.annotations.forEach(function (d) {
        d.type = undefined;
        d.subject = newSettings && newSettings.subject || d.subject;
        d.connector = newSettings && newSettings.connector || d.connector;
        d.note = newSettings && newSettings.note || d.note;
      });
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors() {
      var _this = this;

      this.annotations.forEach(function (d) {
        d.type.setPositionWithAccessors(_this.accessors);
      });
    }
  }, {
    key: "editMode",
    value: function editMode(_editMode) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.editMode = _editMode;
          a.type.updateEditMode();
        }
      });
    }
  }, {
    key: "updateDisable",
    value: function updateDisable(disable) {
      this.annotations.forEach(function (a) {
        a.disable = disable;
        if (a.type) {
          disable.forEach(function (d) {
            if (a.type[d]) {
              a.type[d].remove && a.type[d].remove();
              a.type[d] = undefined;
            }
          });
        }
      });
    }
  }, {
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.updateTextWrap) {
          a.type.updateTextWrap(textWrap);
        }
      });
    }
  }, {
    key: "updateText",
    value: function updateText() {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.drawText) {
          a.type.drawText();
        }
      });
    }
  }, {
    key: "updateNotePadding",
    value: function updateNotePadding(notePadding) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.notePadding = notePadding;
        }
      });
    }
  }, {
    key: "json",
    get: function get$$1() {
      var _this2 = this;

      return this.annotations.map(function (a) {
        var json = a.json;
        if (_this2.accessorsInverse && a.data) {
          json.data = {};
          Object.keys(_this2.accessorsInverse).forEach(function (k) {
            json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });

            //TODO make this feasible to map back to data for other types of subjects
          });
        }
        return json;
      });
    }
  }, {
    key: "noteNodes",
    get: function get$$1() {
      return this.annotations.map(function (a) {
        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
      });
    }

    //TODO: come back and rethink if a.x and a.y are applicable in all situations
    // get connectorNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
    // }

    // get subjectNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
    // }

    // get annotationNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
    // }

  }]);
  return AnnotationCollection;
}();

var pointHandle = function pointHandle(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy;

  return { move: { x: cx, y: cy } };
};

var circleHandles = function circleHandles(_ref2) {
  var _ref2$cx = _ref2.cx,
      cx = _ref2$cx === undefined ? 0 : _ref2$cx,
      _ref2$cy = _ref2.cy,
      cy = _ref2$cy === undefined ? 0 : _ref2$cy,
      r1 = _ref2.r1,
      r2 = _ref2.r2,
      padding = _ref2.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};





//arc handles
var addHandles = function addHandles(_ref5) {
  var group = _ref5.group,
      handles = _ref5.handles,
      _ref5$r = _ref5.r,
      r = _ref5$r === undefined ? 10 : _ref5$r;

  //give it a group and x,y to draw handles
  //then give it instructions on what the handles change
  var h = group.selectAll("circle.handle").data(handles);

  h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call(d3Drag.drag().container(d3Selection.select("g.annotations").node()).on("start", function (d) {
    return d.start && d.start(d);
  }).on("drag", function (d) {
    return d.drag && d.drag(d);
  }).on("end", function (d) {
    return d.end && d.end(d);
  }));

  group.selectAll("circle.handle").attr("cx", function (d) {
    return d.x;
  }).attr("cy", function (d) {
    return d.y;
  }).attr("r", function (d) {
    return d.r || r;
  }).attr("class", function (d) {
    return "handle " + (d.className || "");
  });

  h.exit().remove();
};

var leftRightDynamic = function leftRightDynamic(align, y) {
  if (align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = function topBottomDynamic(align, x) {
  if (align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

var noteAlignment = (function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = 0; //-bbox.y
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
});

var lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? curveLinear$1 : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = line$1().curve(curve);

  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var arcBuilder = function arcBuilder(_ref2) {
  var data = _ref2.data,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;


  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = arc$1().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {

    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

var noteVertical = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = leftRightDynamic(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var noteHorizontal = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = topBottomDynamic(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var lineSetup = function lineSetup(_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;

  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

var connectorLine = (function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorElbow = (function (_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;


  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorCurve = (function (_ref) {
  var type = _ref.type,
      connectorData = _ref.connectorData,
      subjectType = _ref.subjectType;


  if (!connectorData) {
    connectorData = {};
  }
  if (!connectorData.points || typeof connectorData.points === "number") {
    connectorData.points = createPoints(type.annotation.offset, connectorData.points);
  }
  if (!connectorData.curve) {
    connectorData.curve = curveCatmullRom;
  }

  var handles = [];

  if (type.editMode) {
    var cHandles = connectorData.points.map(function (c, i) {
      return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
    });

    var updatePoint = function updatePoint(index) {
      connectorData.points[index][0] += d3Selection.event.dx;
      connectorData.points[index][1] += d3Selection.event.dy;
      type.redrawConnector();
    };

    handles = type.mapHandles(cHandles.map(function (h) {
      return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
    }));
  }

  var data = lineSetup({ type: type, subjectType: subjectType });
  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
  var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];

  return { components: components, handles: handles };
});

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

var connectorArrow = (function (_ref) {
  var annotation = _ref.annotation,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var offset = annotation.position;
  if (!start) {
    start = [annotation.dx, annotation.dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [annotation.x - offset.x, annotation.y - offset.y];
  }

  var x1 = end[0],
      y1 = end[1];

  var dx = start[0];
  var dy = start[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(dy / dx);

  if (dx < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [lineBuilder({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
});

var connectorDot = (function (_ref) {
  var line$$1 = _ref.line,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = arcBuilder({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";

  return { components: [dot] };
});

var subjectCircle = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.radius && !subjectData.outerRadius) {
    subjectData.radius = 20;
  }

  var handles = [];
  var c = arcBuilder({ data: subjectData, className: "subject" });
  if (type.editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: subjectData.radiusPadding
    });

    var updateRadius = function updateRadius(attr) {
      var r = subjectData[attr] + d3Selection.event.dx * Math.sqrt(2);
      subjectData[attr] = r;
      type.redrawSubject();
      type.redrawConnector();
    };

    var cHandles = [_extends({}, h.r1, {
      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
    })];

    if (subjectData.innerRadius) {
      cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
    }
    handles = type.mapHandles(cHandles);
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
});

var subjectRect = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.width) {
    subjectData.width = 100;
  }
  if (!subjectData.height) {
    subjectData.height = 100;
  }

  var handles = [];
  var width = subjectData.width,
      height = subjectData.height;


  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = lineBuilder({ data: data, className: "subject" });

  if (type.editMode) {
    var updateWidth = function updateWidth() {
      subjectData.width = d3Selection.event.x;
      type.redrawSubject();
      type.redrawConnector();
    };

    var updateHeight = function updateHeight() {
      subjectData.height = d3Selection.event.y;
      type.redrawSubject();
      type.redrawConnector();
    };

    var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];

    handles = type.mapHandles(rHandles);
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
});

var subjectThreshold = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  var offset = type.annotation.position;

  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,
      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,
      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,
      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [lineBuilder({ data: data, className: 'subject' })] };
});

var subjectBadge = (function (_ref) {
  var _ref$subjectData = _ref.subjectData,
      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? {} : _ref$type;
  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var typeSettings = type.typeSettings && type.typeSettings.subject;

  if (!subjectData.radius) {
    if (typeSettings && typeSettings.radius) {
      subjectData.radius = typeSettings.radius;
    } else {
      subjectData.radius = 14;
    }
  }
  if (!subjectData.x) {
    if (typeSettings && typeSettings.x) {
      subjectData.x = typeSettings.x;
    }
  }
  if (!subjectData.y) {
    if (typeSettings && typeSettings.y) {
      subjectData.y = typeSettings.y;
    }
  }

  var handles = [];
  var components = [];
  var radius = subjectData.radius;
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (subjectData.x && !subjectData.y) {
    x = placement["x" + subjectData.x];
  } else if (subjectData.y && !subjectData.x) {
    y = placement["y" + subjectData.y];
  } else if (subjectData.x && subjectData.y) {
    x = placement["x" + subjectData.x + "corner"];
    y = placement["y" + subjectData.y + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = annotation.color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = arcBuilder({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  // circle.attrs.fill = annotation.color
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = annotation.color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (type.editMode) {
    var dragBadge = function dragBadge() {
      subjectData.x = d3Selection.event.x < -radius * 2 ? "left" : d3Selection.event.x > radius * 2 ? "right" : undefined;
      subjectData.y = d3Selection.event.y < -radius * 2 ? "top" : d3Selection.event.y > radius * 2 ? "bottom" : undefined;

      type.redrawSubject();
    };

    var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = type.mapHandles([bHandles]);
  }

  var text = void 0;
  if (subjectData.text) {
    text = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: subjectData.text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(text);

  return { components: components, handles: handles };
});

//Note options
//Connector options
//Subject options
var Type = function () {
  function Type(_ref) {
    var a = _ref.a,
        annotation = _ref.annotation,
        editMode = _ref.editMode,
        dispatcher = _ref.dispatcher,
        notePadding = _ref.notePadding,
        accessors = _ref.accessors;
    classCallCheck(this, Type);

    this.a = a;

    this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
    this.noteContent = this.note && a.select("g.annotation-note-content");
    this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
    this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
    this.dispatcher = dispatcher;

    if (dispatcher) {
      var handler = addHandlers.bind(null, dispatcher, annotation);
      handler({ component: this.note, name: "note" });
      handler({ component: this.connector, name: "connector" });
      handler({ component: this.subject, name: "subject" });
    }

    this.annotation = annotation;
    this.editMode = annotation.editMode || editMode;
    this.notePadding = notePadding !== undefined ? notePadding : 3;
    this.offsetCornerX = 0;
    this.offsetCornerY = 0;

    if (accessors && annotation.data) {
      this.init(accessors);
    }
  }

  createClass(Type, [{
    key: "init",
    value: function init(accessors) {
      if (!this.annotation.x) {
        this.mapX(accessors);
      }
      if (!this.annotation.y) {
        this.mapY(accessors);
      }
    }
  }, {
    key: "mapY",
    value: function mapY(accessors) {
      if (accessors.y) {
        this.annotation.y = accessors.y(this.annotation.data);
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      if (accessors.x) {
        this.annotation.x = accessors.x(this.annotation.data);
      }
    }
  }, {
    key: "updateEditMode",
    value: function updateEditMode() {
      this.a.selectAll("circle.handle").remove();
    }
  }, {
    key: "drawOnSVG",
    value: function drawOnSVG(component, builders) {
      var _this = this;

      if (!Array.isArray(builders)) {
        builders = [builders];
      }

      builders.filter(function (b) {
        return b;
      }).forEach(function (_ref2) {
        var type = _ref2.type,
            className = _ref2.className,
            attrs = _ref2.attrs,
            handles = _ref2.handles,
            classID = _ref2.classID;

        if (type === "handle") {
          addHandles({ group: component, r: attrs && attrs.r, handles: handles });
        } else {
          newWithClass(component, [_this.annotation], type, className, classID);
          var el = component.select(type + "." + (classID || className));
          var addAttrs = Object.keys(attrs);
          var removeAttrs = [];

          var currentAttrs = el.node().attributes;
          for (var i = currentAttrs.length - 1; i >= 0; i--) {
            var name = currentAttrs[i].name;
            if (addAttrs.indexOf(name) === -1 && name !== "class") removeAttrs.push(name);
          }

          addAttrs.forEach(function (attr) {
            if (attr === "text") {
              el.text(attrs[attr]);
            } else {
              el.attr(attr, attrs[attr]);
            }
          });

          removeAttrs.forEach(function (attr) {
            return el.attr(attr, null);
          });
        }
      });
    }

    //TODO: how to extend this to a drawOnCanvas mode?

  }, {
    key: "getNoteBBox",
    value: function getNoteBBox() {
      return bboxWithoutHandles(this.note, ".annotation-note-content text");
    }
  }, {
    key: "getNoteBBoxOffset",
    value: function getNoteBBoxOffset() {
      var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
      var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
      bbox.offsetX = this.annotation.dx;
      bbox.offsetY = this.annotation.dy;
      return bbox;
    }
  }, {
    key: "drawSubject",
    value: function drawSubject() {
      var _this2 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var subjectData = this.annotation.subject;
      var type = context.type;
      var subjectParams = { type: this, subjectData: subjectData };

      var subject = {};
      if (type === "circle") subject = subjectCircle(subjectParams);else if (type === "rect") subject = subjectRect(subjectParams);else if (type === "threshold") subject = subjectThreshold(subjectParams);else if (type === "badge") subject = subjectBadge(subjectParams, this.annotation);

      var _subject = subject,
          _subject$components = _subject.components,
          components = _subject$components === undefined ? [] : _subject$components,
          _subject$handles = _subject.handles,
          handles = _subject$handles === undefined ? [] : _subject$handles;

      components.forEach(function (c) {
        if (c && c.attrs && !c.attrs.stroke) {
          c.attrs.stroke = _this2.annotation.color;
        }
      });

      if (this.editMode) {
        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
        components.push({ type: "handle", handles: handles });
      }

      return components;
    }
  }, {
    key: "drawConnector",
    value: function drawConnector() {
      var _this3 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var connectorData = this.annotation.connector;
      var type = connectorData.type || context.type;
      var connectorParams = { type: this, connectorData: connectorData };
      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;

      var connector = {};
      if (type === "curve") connector = connectorCurve(connectorParams);else if (type === "elbow") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);
      var _connector = connector,
          _connector$components = _connector.components,
          components = _connector$components === undefined ? [] : _connector$components,
          _connector$handles = _connector.handles,
          handles = _connector$handles === undefined ? [] : _connector$handles;

      var line$$1 = components[0];
      //TODO: genericize this into fill t/f stroke t/f
      if (line$$1) {
        line$$1.attrs.stroke = this.annotation.color;
        line$$1.attrs.fill = "none";
      }
      var endType = connectorData.end || context.end;
      var end = {};
      if (endType === "arrow") {
        var s = line$$1.data[1];
        var e = line$$1.data[0];
        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
        if (distance < 5 && line$$1.data[2]) {
          s = line$$1.data[2];
        }
        end = connectorArrow({
          annotation: this.annotation,
          start: s,
          end: e,
          scale: connectorData.endScale
        });
      } else if (endType === "dot") {
        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
      } else if (!endType || endType === "none") {
        this.connector && this.connector.select(".connector-end").remove();
      }

      if (end.components) {
        end.components.forEach(function (c) {
          c.attrs.fill = _this3.annotation.color;
          c.attrs.stroke = _this3.annotation.color;
        });
        components = components.concat(end.components);
      }

      if (this.editMode) {
        if (handles.length !== 0) components.push({ type: "handle", handles: handles });
      }
      return components;
    }
  }, {
    key: "drawNote",
    value: function drawNote() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var noteData = this.annotation.note;
      var align = noteData.align || context.align || "dynamic";
      var noteParams = {
        bbox: context.bbox,
        align: align,
        offset: this.annotation.offset
      };
      var lineType = noteData.lineType || context.lineType;
      var note = {};
      if (lineType === "vertical") note = noteVertical(noteParams);else if (lineType === "horizontal") note = noteHorizontal(noteParams);

      var _note = note,
          _note$components = _note.components,
          components = _note$components === undefined ? [] : _note$components,
          _note$handles = _note.handles,
          handles = _note$handles === undefined ? [] : _note$handles;

      components.forEach(function (c) {
        c.attrs.stroke = _this4.annotation.color;
      });

      if (this.editMode) {
        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
        components.push({ type: "handle", handles: handles });

        var dragging = this.dragNote.bind(this),
            start = this.dragstarted.bind(this),
            end = this.dragended.bind(this);
        this.note.call(d3Drag.drag().container(d3Selection.select("g.annotations").node()).on("start", function (d) {
          return start(d);
        }).on("drag", function (d) {
          return dragging(d);
        }).on("end", function (d) {
          return end(d);
        }));
      } else {
        this.note.on("mousedown.drag", null);
      }
      return components;
    }
  }, {
    key: "drawNoteContent",
    value: function drawNoteContent(context) {
      var noteData = this.annotation.note;
      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
      var orientation = noteData.orientation || context.orientation || "topBottom";
      var lineType = noteData.lineType || context.lineType;
      var align = noteData.align || context.align || "dynamic";

      if (lineType === "vertical") orientation = "leftRight";else if (lineType === "horizontal") orientation = "topBottom";

      var noteParams = {
        padding: padding,
        bbox: context.bbox,
        offset: this.annotation.offset,
        orientation: orientation,
        align: align
      };

      var _noteAlignment = noteAlignment(noteParams),
          x = _noteAlignment.x,
          y = _noteAlignment.y;

      this.offsetCornerX = x + this.annotation.dx;
      this.offsetCornerY = y + this.annotation.dy;
      this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");

      return [];
    }
  }, {
    key: "drawOnScreen",
    value: function drawOnScreen(component, drawFunction) {
      return this.drawOnSVG(component, drawFunction);
    }
  }, {
    key: "redrawSubject",
    value: function redrawSubject() {
      this.subject && this.drawOnScreen(this.subject, this.drawSubject());
    }
  }, {
    key: "redrawConnector",
    value: function redrawConnector() {
      this.connector && this.drawOnScreen(this.connector, this.drawConnector());
    }
  }, {
    key: "redrawNote",
    value: function redrawNote() {
      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();

      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
      this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = this.annotation.position;
      this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.subject && this.subject.select("*").remove();
      this.connector && this.connector.select("*").remove();
      // this.note && this.note.select("*").remove()
    }
  }, {
    key: "setOffset",
    value: function setOffset() {
      if (this.note) {
        var offset = this.annotation.offset;
        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
      }
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors(accessors) {
      if (accessors && this.annotation.data) {
        this.mapX(accessors);
        this.mapY(accessors);
      }
      this.setPosition();
    }
  }, {
    key: "setClassName",
    value: function setClassName() {
      this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
    }
  }, {
    key: "draw",
    value: function draw() {
      this.setClassName();
      this.setPosition();
      this.setOffset();
      this.redrawSubject();
      this.redrawConnector();
      this.redrawNote();
    }
  }, {
    key: "dragstarted",
    value: function dragstarted() {
      d3Selection.event.sourceEvent.stopPropagation();
      this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
      this.a.classed("dragging", true);
      this.a.selectAll("circle.handle").style("pointer-events", "none");
    }
  }, {
    key: "dragended",
    value: function dragended() {
      this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
      this.a.classed("dragging", false);
      this.a.selectAll("circle.handle").style("pointer-events", "all");
    }
  }, {
    key: "dragSubject",
    value: function dragSubject() {
      var position = this.annotation.position;
      position.x += d3Selection.event.dx;
      position.y += d3Selection.event.dy;
      this.annotation.position = position;
    }
  }, {
    key: "dragNote",
    value: function dragNote() {
      var offset = this.annotation.offset;
      offset.x += d3Selection.event.dx;
      offset.y += d3Selection.event.dy;
      this.annotation.offset = offset;
    }
  }, {
    key: "mapHandles",
    value: function mapHandles(handles) {
      var _this5 = this;

      return handles.map(function (h) {
        return _extends({}, h, {
          start: _this5.dragstarted.bind(_this5),
          end: _this5.dragended.bind(_this5)
        });
      });
    }
  }]);
  return Type;
}();

var customType = function customType(initialType, typeSettings, _init) {
  return function (_initialType) {
    inherits(customType, _initialType);

    function customType(settings) {
      classCallCheck(this, customType);

      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));

      _this6.typeSettings = typeSettings;

      if (typeSettings.disable) {
        typeSettings.disable.forEach(function (d) {
          _this6[d] && _this6[d].remove();

          _this6[d] = undefined;
          if (d === "note") {
            _this6.noteContent = undefined;
          }
        });
      }
      return _this6;
    }

    createClass(customType, [{
      key: "className",
      value: function className() {
        return "" + (typeSettings.className || get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
      }
    }, {
      key: "drawSubject",
      value: function drawSubject(context) {
        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
        return get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
      }
    }, {
      key: "drawConnector",
      value: function drawConnector(context) {
        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
        return get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
      }
    }, {
      key: "drawNote",
      value: function drawNote(context) {
        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
        return get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }, {
      key: "drawNoteContent",
      value: function drawNoteContent(context) {
        return get$3(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }], [{
      key: "init",
      value: function init(annotation, accessors) {
        get$3(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
        if (_init) {
          annotation = _init(annotation, accessors);
        }
        return annotation;
      }
    }]);
    return customType;
  }(initialType);
};

var d3NoteText = function (_Type) {
  inherits(d3NoteText, _Type);

  function d3NoteText(params) {
    classCallCheck(this, d3NoteText);

    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));

    _this7.textWrap = params.textWrap || 120;
    _this7.drawText();
    return _this7;
  }

  createClass(d3NoteText, [{
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.textWrap = textWrap;
      this.drawText();
    }

    //TODO: add update text functionality

  }, {
    key: "drawText",
    value: function drawText() {
      if (this.note) {
        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");

        var noteContent = this.note.select("g.annotation-note-content");
        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");

        var titleBBox = { height: 0 };
        var label = this.a.select("text.annotation-note-label");
        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;

        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;

        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;

        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
        if (typeof bgPadding === "number") {
          bgPaddingFinal = {
            top: bgPadding,
            bottom: bgPadding,
            left: bgPadding,
            right: bgPadding
          };
        } else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
        }

        if (this.annotation.note.title) {
          var title = this.a.select("text.annotation-note-title");
          title.text(this.annotation.note.title);
          title.attr("fill", this.annotation.color);
          title.attr("font-weight", "bold");
          title.call(wrap$1, wrapLength, wrapSplitter);
          titleBBox = title.node().getBBox();
        }

        label.text(this.annotation.note.label).attr("dx", "0");
        label.call(wrap$1, wrapLength, wrapSplitter);

        label.attr("y", titleBBox.height * 1.1 || 0);
        label.attr("fill", this.annotation.color);

        var bbox = this.getNoteBBox();

        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
      }
    }
  }]);
  return d3NoteText;
}(Type);

var d3Label = customType(d3NoteText, {
  className: "label",
  note: { align: "middle" }
});

var d3Callout = customType(d3NoteText, {
  className: "callout",
  note: { lineType: "horizontal" }
});

var d3CalloutElbow = customType(d3Callout, {
  className: "callout elbow",
  connector: { type: "elbow" }
});

var d3CalloutCurve = customType(d3Callout, {
  className: "callout curve",
  connector: { type: "curve" }
});

var d3Badge = customType(Type, {
  className: "badge",
  subject: { type: "badge" },
  disable: ["connector", "note"]
});

var d3CalloutCircle = customType(d3NoteText, {
  className: "callout circle",
  subject: { type: "circle" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var d3CalloutRect = customType(d3NoteText, {
  className: "callout rect",
  subject: { type: "rect" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var ThresholdMap = function (_d3Callout) {
  inherits(ThresholdMap, _d3Callout);

  function ThresholdMap() {
    classCallCheck(this, ThresholdMap);
    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
  }

  createClass(ThresholdMap, [{
    key: "mapY",
    value: function mapY(accessors) {
      get$3(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
        a.y = accessors.y(a.data);
      }
      if ((a.subject.x1 || a.subject.x2) && !a.x) {
        a.x = a.subject.x1 || a.subject.x2;
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      get$3(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
        a.x = accessors.x(a.data);
      }
      if ((a.subject.y1 || a.subject.y2) && !a.y) {
        a.y = a.subject.y1 || a.subject.y2;
      }
    }
  }]);
  return ThresholdMap;
}(d3Callout);

var d3XYThreshold = customType(ThresholdMap, {
  className: "callout xythreshold",
  subject: { type: "threshold" }
});

var newWithClass = function newWithClass(a, d, type, className, classID) {
  var group = a.selectAll(type + "." + (classID || className)).data(d);
  group.enter().append(type).merge(group).attr("class", className);

  group.exit().remove();
  return a;
};

var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
  var component = _ref3.component,
      name = _ref3.name;

  if (component) {
    component.on("mouseover.annotations", function () {
      dispatcher.call(name + "over", component, annotation);
    }).on("mouseout.annotations", function () {
      return dispatcher.call(name + "out", component, annotation);
    }).on("click.annotations", function () {
      return dispatcher.call(name + "click", component, annotation);
    });
  }
};

//Text wrapping code adapted from Mike Bostock
var wrap$1 = function wrap(text, width, wrapSplitter) {
  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;

  text.each(function () {
    var text = d3Selection.select(this),
        words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
      return w !== "";
    });
    var word = void 0,
        line$$1 = [],
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");

    while (word = words.pop()) {
      line$$1.push(word);
      tspan.text(line$$1.join(" "));
      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
        line$$1.pop();
        tspan.text(line$$1.join(" "));
        line$$1 = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
      }
    }
  });
};

var bboxWithoutHandles = function bboxWithoutHandles(selection) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";

  if (!selection) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  return selection.selectAll(selector).nodes().reduce(function (p, c) {
    var bbox = c.getBBox();
    p.x = Math.min(p.x, bbox.x);
    p.y = Math.min(p.y, bbox.y);
    p.width = Math.max(p.width, bbox.width);

    var yOffset = c && c.attributes && c.attributes.y;
    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    return p;
  }, { x: 0, y: 0, width: 0, height: 0 });
};

function annotation() {
  var annotations = [],
      collection = void 0,
      context = void 0,
      //TODO: add canvas functionality
  disable = [],
      accessors = {},
      accessorsInverse = {},
      editMode = false,
      ids = void 0,
      type = d3Callout,
      textWrap = void 0,
      notePadding = void 0,
      annotationDispatcher = dispatch$1("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"),
      sel = void 0;

  var annotation = function annotation(selection) {
    sel = selection;
    //TODO: check to see if this is still needed
    if (!editMode) {
      selection.selectAll("circle.handle").remove();
    }

    var translatedAnnotations = annotations.map(function (a) {
      if (!a.type) {
        a.type = type;
      }
      if (!a.disable) {
        a.disable = disable;
      }
      return new Annotation(a);
    });

    collection = collection || new AnnotationCollection({
      annotations: translatedAnnotations,
      accessors: accessors,
      accessorsInverse: accessorsInverse,
      ids: ids
    });

    var annotationG = selection.selectAll("g").data([collection]);
    annotationG.enter().append("g").attr("class", "annotations");

    var group = selection.select("g.annotations");
    newWithClass(group, collection.annotations, "g", "annotation");

    var annotation = group.selectAll("g.annotation");

    annotation.each(function (d) {
      var a = d3Selection.select(this);

      a.attr("class", "annotation");

      newWithClass(a, [d], "g", "annotation-connector");
      newWithClass(a, [d], "g", "annotation-subject");
      newWithClass(a, [d], "g", "annotation-note");
      newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
      d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
        a: a,
        annotation: d,
        textWrap: textWrap,
        notePadding: notePadding,
        editMode: editMode,
        dispatcher: annotationDispatcher,
        accessors: accessors
      });
      d.type.draw();
      d.type.drawText && d.type.drawText();
    });
  };

  annotation.json = function () {
    /* eslint-disable no-console */
    console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
    /* eslint-enable no-console */
    window.copy(JSON.stringify(collection.json.map(function (a) {
      delete a.type;
      return a;
    })));
    return annotation;
  };

  annotation.update = function () {
    if (annotations && collection) {
      annotations = collection.annotations.map(function (a) {
        a.type.draw();
        return a;
      });
    }
    return annotation;
  };

  annotation.updateText = function () {
    if (collection) {
      collection.updateText(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.updatedAccessors = function () {
    collection.setPositionWithAccessors();
    annotations = collection.annotations;
    return annotation;
  };

  annotation.disable = function (_) {
    if (!arguments.length) return disable;
    disable = _;
    if (collection) {
      collection.updateDisable(disable);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    if (collection) {
      collection.updateTextWrap(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.notePadding = function (_) {
    if (!arguments.length) return notePadding;
    notePadding = _;
    if (collection) {
      collection.updateNotePadding(notePadding);
      annotations = collection.annotations;
    }
    return annotation;
  };
  //todo think of how to handle when undefined is sent
  annotation.type = function (_, settings) {
    if (!arguments.length) return type;
    type = _;
    if (collection) {
      collection.annotations.map(function (a) {
        a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
        a.type.noteContent && a.type.noteContent.selectAll("*").remove();
        a.type.subject && a.type.subject.selectAll("*").remove();
        a.type.connector && a.type.connector.selectAll("*").remove();
        a.type.typeSettings = {};
        a.type = type;

        a.subject = settings && settings.subject || a.subject;
        a.connector = settings && settings.connector || a.connector;
        a.note = settings && settings.note || a.note;
      });

      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.annotations = function (_) {
    if (!arguments.length) return collection && collection.annotations || annotations;
    annotations = _;

    if (collection && collection.annotations) {
      var rerun = annotations.some(function (d) {
        return !d.type || d.type.toString() !== "[object Object]";
      });

      if (rerun) {
        collection = null;
        annotation(sel);
      } else {
        collection.annotations = annotations;
      }
    }
    return annotation;
  };

  annotation.context = function (_) {
    if (!arguments.length) return context;
    context = _;
    return annotation;
  };

  annotation.accessors = function (_) {
    if (!arguments.length) return accessors;
    accessors = _;
    return annotation;
  };

  annotation.accessorsInverse = function (_) {
    if (!arguments.length) return accessorsInverse;
    accessorsInverse = _;
    return annotation;
  };

  annotation.ids = function (_) {
    if (!arguments.length) return ids;
    ids = _;
    return annotation;
  };

  annotation.editMode = function (_) {
    if (!arguments.length) return editMode;
    editMode = _;

    if (sel) {
      sel.selectAll("g.annotation").classed("editable", editMode);
    }

    if (collection) {
      collection.editMode(editMode);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.collection = function (_) {
    if (!arguments.length) return collection;
    collection = _;
    return annotation;
  };

  annotation.on = function () {
    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
    return value === annotationDispatcher ? annotation : value;
  };

  return annotation;
}

var types = {
    annotationLabel: d3Label,
    annotationCallout: d3Callout,
    annotationCalloutElbow: d3CalloutElbow,
    annotationCalloutCurve: d3CalloutCurve,
    annotationCalloutCircle: d3CalloutCircle,
    annotationCalloutRect: d3CalloutRect,
    annotationXYThreshold: d3XYThreshold,
    annotationBadge: d3Badge
};
function annotate(_a) {
    var source = _a.source, data = _a.data, xScale = _a.xScale, xAccessor = _a.xAccessor, yScale = _a.yScale, yAccessor = _a.yAccessor, ignoreScales = _a.ignoreScales;
    select(source)
        .selectAll('.vcl-annotation-group')
        .remove();
    var annotations = select(source)
        .append('g')
        .attr('class', 'vcl-annotation-group')
        .attr('data-testid', 'annotation-group');
    hideNode(annotations.node());
    var editable = select(source)
        .append('g')
        .attr('class', 'editable vcl-annotation-group')
        .attr('data-testid', 'editable-annotation-group');
    hideNode(editable.node());
    if (data && data.length) {
        var percentX_1 = linear$2()
            .range(xScale ? xScale.range() : [0, 100])
            .domain([0, 100]);
        var yRange_1 = yScale ? yScale.range() : [0, 100];
        var y0 = yRange_1[0] >= yRange_1[1] ? 100 : 0;
        var y1 = 100 - y0;
        var percentY_1 = linear$2()
            .range(yRange_1)
            .domain([y0, y1]);
        var invertedY_1 = function (d) {
            var height = yRange_1[0] >= yRange_1[1] ? yRange_1[0] : yRange_1[1];
            return yScale(d) - height;
        };
        var annotationData_1 = [];
        var annotationEditableData_1 = [];
        data.forEach(function (datum, i) {
            var d = {};
            var dKeys = Object.keys(datum);
            dKeys.forEach(function (key) {
                if (key !== 'data' && key !== 'subject' && key !== 'connector' && key !== 'note') {
                    if (datum[key] instanceof Array) {
                        d[key] = __spreadArrays(datum[key]);
                    }
                    else {
                        d[key] = datum[key];
                    }
                }
                else {
                    d[key] = {};
                    var innerKeys = Object.keys(datum[key]);
                    innerKeys.forEach(function (innerKey) {
                        if (datum[key][innerKey] instanceof Array) {
                            if (innerKey === 'points') {
                                // [ // datum[key][innerKey]
                                //   [ // point
                                //     40,
                                //     50
                                //   ],
                                //   [
                                //     200,
                                //     100
                                //   ]
                                // ]
                                // or
                                // [ // datum[key][innerKey]
                                //   [ // point
                                //     [val,val],
                                //     [val]
                                //   ],
                                //   [
                                //     [val],
                                //     [val]
                                //   ]
                                // ]
                                d[key][innerKey] = [];
                                datum[key][innerKey].forEach(function (point) {
                                    var clonedPoint = [];
                                    if (point[0] instanceof Array && point[1] instanceof Array) {
                                        clonedPoint.push(__spreadArrays(point[0]));
                                        clonedPoint.push(__spreadArrays(point[1]));
                                    }
                                    else {
                                        clonedPoint.push(point[0]);
                                        clonedPoint.push(point[1]);
                                    }
                                    d[key][innerKey].push(clonedPoint);
                                });
                            }
                            else {
                                d[key][innerKey] = __spreadArrays(datum[key][innerKey]);
                            }
                        }
                        else {
                            d[key][innerKey] = datum[key][innerKey];
                        }
                    });
                }
            });
            var yToDate = d.parseAsDates && (d.parseAsDates.includes('y') || d.parseAsDates.includes(yAccessor));
            var xToDate = d.parseAsDates && (d.parseAsDates.includes('x') || d.parseAsDates.includes(xAccessor));
            var diff = 0;
            if (d.data) {
                var keys = Object.keys(d.data);
                var i_1 = 0;
                if (yToDate || xToDate) {
                    for (i_1 = 0; i_1 < keys.length; i_1++) {
                        if (keys[i_1] === 'x' || keys[i_1] === xAccessor) {
                            d.data[keys[i_1]] = checkDate(d.data[keys[i_1]], xToDate);
                        }
                        else if (keys[i_1] === yAccessor || keys[i_1] === 'y') {
                            d.data[keys[i_1]] = checkDate(d.data[keys[i_1]], yToDate);
                        }
                    }
                }
            }
            if (d.x) {
                d.x = resolveValue(d.x, xScale, percentX_1, xToDate);
            }
            if (d.y) {
                d.y = resolveValue(d.y, yScale, percentY_1, yToDate);
            }
            if (d.dx) {
                if (d.dx instanceof Array) {
                    diff = d.data && d.data[xAccessor] !== undefined ? xScale(d.data[xAccessor]) : d.x ? d.x : 0;
                }
                d.dx = resolveValue(d.dx, xScale, percentX_1, xToDate) - diff;
            }
            if (d.dy) {
                diff = 0;
                if (d.dy instanceof Array) {
                    diff = d.data && d.data[yAccessor] !== undefined ? yScale(d.data[yAccessor]) : d.y ? d.y : 0;
                }
                d.dy = resolveValue(d.dy, yScale, percentY_1, yToDate) - diff;
            }
            if (d.subject) {
                if (d.subject.x1) {
                    d.subject.x1 = resolveValue(d.subject.x1, xScale, percentX_1, xToDate);
                }
                if (d.subject.y1) {
                    d.subject.y1 = resolveValue(d.subject.y1, yScale, percentY_1, yToDate);
                }
                if (d.subject.x2) {
                    d.subject.x2 = resolveValue(d.subject.x2, xScale, percentX_1, xToDate);
                }
                if (d.subject.y2) {
                    d.subject.y2 = resolveValue(d.subject.y2, yScale, percentY_1, yToDate);
                }
                if (d.subject.width) {
                    d.subject.width = resolveValue(d.subject.width, xScale, percentX_1, xToDate);
                }
                if (d.subject.height) {
                    d.subject.height = resolveValue(d.subject.height, invertedY_1, percentY_1, yToDate);
                }
            }
            if (d.connector) {
                if (typeof d.connector.curve === 'string') {
                    d.connector.curve = d3[d.connector.curve];
                }
                if (d.connector.points instanceof Array) {
                    d.connector.points.forEach(function (point) {
                        point[0] = resolveValue(point[0], xScale, percentX_1, xToDate);
                        point[1] = resolveValue(point[1], yScale, percentY_1, yToDate);
                    });
                }
            }
            if (d.type && typeof d.type === 'string') {
                d.type = types[d.type];
            }
            if (!d.editMode) {
                annotationData_1.push(d);
            }
            else {
                annotationEditableData_1.push(d);
            }
            if (d.color) {
                d.color = visaColorToHex(d.color) || d.color;
            }
        });
        var makeAnnotations = annotation().annotations(annotationData_1);
        var makeEditableAnnotations = annotation()
            .editMode(true)
            .annotations(annotationEditableData_1);
        if (!ignoreScales) {
            makeAnnotations = annotation()
                .accessors({
                x: function (d) {
                    return xScale(d[xAccessor]);
                },
                y: function (d) {
                    return yScale(d[yAccessor]);
                }
            })
                .annotations(annotationData_1);
            makeEditableAnnotations = annotation()
                .editMode(true)
                .accessors({
                x: function (d) {
                    return xScale(d[xAccessor]);
                },
                y: function (d) {
                    return yScale(d[yAccessor]);
                }
            })
                .annotations(annotationEditableData_1);
        }
        annotations.call(makeAnnotations);
        editable.call(makeEditableAnnotations);
    }
    // addStrokeUnder(
    //   d3
    //     .select(source)
    //     .selectAll('.vcl-annotation-group')
    //     .selectAll('text'),
    //   'white'
    // );
}
function resolveValue(d, scale, percentScale, shouldBeDate) {
    if (d) {
        if (d instanceof Array) {
            if (d.length === 1) {
                return checkZero(scale(checkDate(d[0], shouldBeDate)));
            }
            else if (d.length === 2) {
                return checkZero(scale(checkDate(d[0], shouldBeDate)) - scale(checkDate(d[1], shouldBeDate)));
            }
        }
        else if (typeof d === 'string' && d.substring(d.length - 1, d.length) === '%') {
            return checkZero(percentScale(+d.substring(0, d.length - 1)));
        }
    }
    return checkZero(d);
}
function checkZero(v) {
    if (v === 0) {
        return 0.000000001;
    }
    return v;
}
function checkDate(d, shouldCheck) {
    if (shouldCheck) {
        if (typeof d === 'object' && typeof d.getMonth === 'function') {
            return d;
        }
        return new Date(d);
    }
    return d;
}

var validationStyle = {
    warningStyle: 'color: #C6003F;font-size:medium;',
    recommendationStyle: 'font-size:medium;',
    specialRecommendationStyle: 'color: #0061C1;font-size:medium;'
};
var VALIDATIONRULES = {
    TITLE: {
        MIN: 5,
        MAX: 50
    },
    PURPOSE: {
        MIN: 40,
        MAX: 250
    },
    EXECUTIVE: {
        MIN: 40,
        MAX: 250
    },
    EXECUTIVECOMBINED: {
        MIN: 40,
        MAX: 250
    },
    CONTEXTEXPLANATION: {
        MIN: 40,
        MAX: 500
    },
    CONTEXTEXPLANATIONCOMBINED: {
        MIN: 40,
        MAX: 500
    },
    STATISTICALNOTES: {
        MIN: 40,
        MAX: 250
    },
    STRUCTURENOTES: {
        MIN: 40,
        MAX: 250
    },
    DATAELEMENTDESCRIPTIONACCESSOR: {
        MIN: 0,
        MAX: 125
    },
    ELEMENTDESCRIPTIONACCESSOR: {
        MAX: 125
    },
    ANNOTATIONNOTETITLE: {
        MIN: 5,
        MAX: 50
    },
    ANNOTATIONNOTELABEL: {
        MIN: 25,
        MAX: 125
    },
    ANNOTATIONACCESSIBILITYDESCRIPTION: {
        MIN: 25,
        MAX: 125
    },
    UNIQUEID: {
        MIN: 1,
        MAX: 125
    }
};
var VALIDATIONMESSAGES = {
    WARNINGS: {
        TITLE: 'Either mainTitle or accessibility.title is required',
        LONGDESCRIPTION: 'Either accessibility.longDescription or accessibility.contextExplanation is required',
        EXECUTIVESUMMARY: 'Either accessibility.purpose or accessibility.executiveSummary is required',
        ONCLICKFUNC: 'accessibility.elementsAreInterface needs a boolean value either true or false',
        ANNOTATIONDESCRIPTION: 'Either annotation.accessibilityDescription or annotation.note.label is required',
        WARNINGLOGGROUP: 'CHARTNAME has accessibility warnings and other messages',
        NORMALIZED: 'Either tooltipLabel or dataLabel should have normalized format'
    },
    RECOMMENDATIONS: {
        EXECUTIVESUMMARY: 'Either accessibility.purpose or accessibility.executiveSummary should have minimum 40 characters and a combined length between 40 and 250 characters',
        LONGDESCRIPTION: 'Either accessibility.longDescription or accessibility.contextExplanation should have minimum 40 characters and a combined length between 40 and 500 characters',
        TITLE: 'Either mainTitle or accessibility.title should have length between 5 and 50 characters',
        STATISTICALNOTES: 'accessibility.statisticalNotes should have length between 40 and 250 characters',
        STRUCTURENOTES: 'accessibility.structureNotes should have length between 40 and 250 characters',
        DATAELEMENTDESCRIPTIONACCESSOR: 'accessibility.elementDescriptionAccessor should have length between 0 and 125 characters',
        ELEMENTDESCRIPTIONACCESSOR: 'Passing accessibility.elementDescriptionAccessor can add description to chart elements',
        ANNOTATIONNOTETITLE: 'Should have length between 5 and 50 characters',
        ANNOTATIONNOTELABEL: 'Should have length between 25 and 125 characters',
        ANNOTATIONACCESSIBILITYDESCRIPTION: 'Should have length between 25 and 125 characters',
        UNIQUEID: 'Should have human readable uniqueID',
        INCLUDEDATAKEYNAMES: "accessibility.includeDataKeyNames: data's key names are recommended ashuman-readable with includeDataKeyNames set to true",
        RECOMMENDATIONLOGGROUP: 'CHARTNAME has strong accessibility recommendations',
        SPECIALRECOMMENDATION: 'Success! CHARTNAME has met minimum accessibility, we recommend you disable accessibility validation by setting accessibility.disableValidation'
    }
};
var ACCESSIBILITYPROPS = {
    MAINTITLE: 'mainTitle',
    LONGDESCRIPTION: 'longDescription',
    CONTEXTEXPLANATION: 'contextExplanation',
    PURPOSE: 'purpose',
    ONCLICKFUNC: 'onClickFunc',
    NOTE: 'note',
    DISABLEVALIDATION: 'disableValidation',
    INCLUDEDATAKEYNAMES: 'includeDataKeyNames',
    CHARTNAME: 'CHARTNAME',
    TOOLTIPLABEL: 'tooltipLabel',
    DATALABEL: 'dataLabel',
    VALUEACCESSOR: 'valueAccessor'
};
var options$1 = {
    abortEarly: false
};
var accessibilityWarningsSubSchema = {
    requiredSchema: yup.string()
        .required()
        .trim(),
    requiredSubSchema: yup.object().shape({
        label: yup.string()
            .required()
            .trim()
    }),
    requiredBooleanSchema: yup.bool().required()
};
var getCustomSchema = function (min, max) {
    return yup.string()
        .required()
        .trim()
        .min(min)
        .max(max);
};
var getCustomRegexSchema = function (regexWord) {
    return yup.string()
        .required()
        .trim()
        .matches(regexWord);
};
var validateBySchemaRefs = function (validationMessage, tooltipLabelRef, dataLabelRef, valueAccessorRef, schema) {
    return this.test({
        message: validationMessage,
        test: function (value) {
            var tooltipLabelValue = this.resolve(tooltipLabelRef);
            var dataLabelValue = this.resolve(dataLabelRef);
            var valueAccessorValue = this.resolve(valueAccessorRef);
            if (value &&
                yup.string()
                    .min(1)
                    .isValidSync(valueAccessorValue, options$1)) {
                var valueAccessorIndex = Array.prototype.findIndex.call(tooltipLabelValue.labelAccessor, function (el) { return el.trim() === ('' + valueAccessorValue).trim(); });
                return valueAccessorIndex > -1
                    ? schema.isValidSync(((tooltipLabelValue || {}).format || [''])[valueAccessorIndex], options$1)
                    : schema.isValidSync((dataLabelValue || {}).format, options$1);
            }
            return true;
        }
    });
};
var validateBySchemaRef = function (validationMessage, ref, firstSchema, secondSchema) {
    return this.test({
        message: validationMessage,
        test: function (value) {
            secondSchema = secondSchema ? secondSchema : firstSchema;
            var refField = this.resolve(ref);
            var isFieldValid = firstSchema.isValidSync(value, options$1);
            var isRefFieldValid = secondSchema.isValidSync(refField, options$1);
            return isRefFieldValid || isFieldValid ? true : false;
        }
    });
};
var validateBySchemaRefBoolean = function (schema, booleanSchema, ref, validationMessage) {
    return this.test({
        message: validationMessage,
        test: function (value) {
            var refField = this.resolve(ref);
            return schema.isValidSync(refField, options$1)
                ? booleanSchema.isValidSync(value, { abortyEarly: false, strict: true })
                : true;
        }
    });
};
var validateBySchemaRefAndCondition = function (schema, combinedSchema, ref, validationMessage) {
    return this.test({
        message: validationMessage,
        test: function (value) {
            var refField = (this.resolve(ref) || '').toString().trim();
            var field = (value || '').toString().trim();
            var fieldRefFieldCombined = "" + refField + field;
            var isValidRefField = schema.isValidSync(refField, options$1);
            var isValidField = schema.isValidSync(field, options$1);
            var isValid = combinedSchema.isValidSync(fieldRefFieldCombined, options$1);
            var derivedValidStatus = (refField.length && !isValidRefField) || (field.length && !isValidField) ? false : true;
            return derivedValidStatus && (isValidField || isValidRefField) && isValid ? true : false;
        }
    });
};
var validateBySchema = function (schema, validationMessage) {
    return this.test({
        message: validationMessage,
        test: function (value) {
            return schema.isValidSync(value, options$1);
        }
    });
};
var getAccessibilityWarningsSchema = function () {
    return yup.object().shape({
        title: yup.string().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.TITLE, yup.ref("$" + ACCESSIBILITYPROPS.MAINTITLE), accessibilityWarningsSubSchema.requiredSchema),
        longDescription: yup.string().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.LONGDESCRIPTION, yup.ref("" + ACCESSIBILITYPROPS.CONTEXTEXPLANATION), accessibilityWarningsSubSchema.requiredSchema),
        executiveSummary: yup.string().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.EXECUTIVESUMMARY, yup.ref("" + ACCESSIBILITYPROPS.PURPOSE), accessibilityWarningsSubSchema.requiredSchema),
        elementsAreInterface: yup.bool().validateBySchemaRefBoolean(accessibilityWarningsSubSchema.requiredSchema, accessibilityWarningsSubSchema.requiredBooleanSchema, yup.ref("$" + ACCESSIBILITYPROPS.ONCLICKFUNC), VALIDATIONMESSAGES.WARNINGS.ONCLICKFUNC),
        normalized: yup.bool().validateBySchemaRefs(VALIDATIONMESSAGES.WARNINGS.NORMALIZED, yup.ref("$" + ACCESSIBILITYPROPS.TOOLTIPLABEL), yup.ref("$" + ACCESSIBILITYPROPS.DATALABEL), yup.ref("$" + ACCESSIBILITYPROPS.VALUEACCESSOR), getCustomRegexSchema(/^normalized$/)),
        annotations: yup.array().of(yup.object().shape({
            accessibilityDescription: yup.string().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.ANNOTATIONDESCRIPTION, yup.ref("" + ACCESSIBILITYPROPS.NOTE), accessibilityWarningsSubSchema.requiredSchema, accessibilityWarningsSubSchema.requiredSubSchema)
        }))
    });
};
var getAccessibilityRecommendationSchema = function () {
    return yup.object().shape({
        title: yup.string().validateBySchemaRef(VALIDATIONMESSAGES.RECOMMENDATIONS.TITLE, yup.ref("$" + ACCESSIBILITYPROPS.MAINTITLE), getCustomSchema(VALIDATIONRULES.TITLE.MIN, VALIDATIONRULES.TITLE.MAX)),
        longDescription: yup.string().validateBySchemaRefAndCondition(getCustomSchema(VALIDATIONRULES.CONTEXTEXPLANATION.MIN, VALIDATIONRULES.CONTEXTEXPLANATION.MAX), getCustomSchema(VALIDATIONRULES.CONTEXTEXPLANATIONCOMBINED.MIN, VALIDATIONRULES.CONTEXTEXPLANATIONCOMBINED.MAX), yup.ref("" + ACCESSIBILITYPROPS.CONTEXTEXPLANATION), VALIDATIONMESSAGES.RECOMMENDATIONS.LONGDESCRIPTION),
        executiveSummary: yup.string().validateBySchemaRefAndCondition(getCustomSchema(VALIDATIONRULES.PURPOSE.MIN, VALIDATIONRULES.PURPOSE.MAX), getCustomSchema(VALIDATIONRULES.EXECUTIVECOMBINED.MIN, VALIDATIONRULES.EXECUTIVECOMBINED.MAX), yup.ref("" + ACCESSIBILITYPROPS.PURPOSE), VALIDATIONMESSAGES.RECOMMENDATIONS.EXECUTIVESUMMARY),
        statisticalNotes: yup.string().validateBySchema(getCustomSchema(VALIDATIONRULES.STATISTICALNOTES.MIN, VALIDATIONRULES.STATISTICALNOTES.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.STATISTICALNOTES),
        structureNotes: yup.string().validateBySchema(getCustomSchema(VALIDATIONRULES.STRUCTURENOTES.MIN, VALIDATIONRULES.STRUCTURENOTES.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.STRUCTURENOTES),
        elementDescriptionAccessor: yup.string().nullable().validateBySchema(yup.string()
            .nullable()
            .max(VALIDATIONRULES.ELEMENTDESCRIPTIONACCESSOR.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ELEMENTDESCRIPTIONACCESSOR),
        annotations: yup.array().of(yup.object().shape({
            note: yup.object().shape({
                title: yup.string().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONNOTETITLE.MIN, VALIDATIONRULES.ANNOTATIONNOTETITLE.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONNOTETITLE),
                label: yup.string().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONNOTELABEL.MIN, VALIDATIONRULES.ANNOTATIONNOTELABEL.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONNOTELABEL)
            }),
            accessibilityDescription: yup.string().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONACCESSIBILITYDESCRIPTION.MIN, VALIDATIONRULES.ANNOTATIONACCESSIBILITYDESCRIPTION.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONACCESSIBILITYDESCRIPTION)
        })),
        data: yup.array()
            .nullable()
            .of(yup.object().shape({
            note: yup.string().nullable().validateBySchema(yup.string()
                .nullable()
                .max(VALIDATIONRULES.DATAELEMENTDESCRIPTIONACCESSOR.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.DATAELEMENTDESCRIPTIONACCESSOR)
        })),
        uniqueID: yup.string().validateBySchema(yup.string()
            .required()
            .trim()
            .min(VALIDATIONRULES.UNIQUEID.MIN), VALIDATIONMESSAGES.RECOMMENDATIONS.UNIQUEID)
    });
};
function validateRecommendations(chartName, accessibilityProps, optionsWithContext, isAnyWarnings) {
    var recommendationSpecialMessage = VALIDATIONMESSAGES.RECOMMENDATIONS.SPECIALRECOMMENDATION.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
    var recommendationGroup = VALIDATIONMESSAGES.RECOMMENDATIONS.RECOMMENDATIONLOGGROUP.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
    try {
        var accessibilityRecommendationSchema = getAccessibilityRecommendationSchema();
        accessibilityRecommendationSchema.validateSync(accessibilityProps, optionsWithContext);
        if (!isAnyWarnings && accessibilityProps && !accessibilityProps[ACCESSIBILITYPROPS.DISABLEVALIDATION]) {
            console.log("%c " + recommendationSpecialMessage, validationStyle.specialRecommendationStyle);
        }
    }
    catch (errors) {
        var allErrors_1 = {};
        if (!isAnyWarnings) {
            console.groupCollapsed("%c " + recommendationGroup, validationStyle.recommendationStyle);
        }
        errors.inner.map(function (error) {
            allErrors_1[error.path] = error.message;
            console.log("%c " + error.path + ": " + error.message, validationStyle.recommendationStyle);
        });
    }
    if (!accessibilityProps && !accessibilityProps[ACCESSIBILITYPROPS.INCLUDEDATAKEYNAMES]) {
        console.log("%c " + VALIDATIONMESSAGES.RECOMMENDATIONS.INCLUDEDATAKEYNAMES, validationStyle.recommendationStyle);
    }
    console.groupEnd();
}
function validateWarnings(chartName, accessibilityProps, optionsWithContext) {
    var warningGroup = VALIDATIONMESSAGES.WARNINGS.WARNINGLOGGROUP.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
    try {
        var accessibilityWarningSchema = getAccessibilityWarningsSchema();
        accessibilityWarningSchema.validateSync(accessibilityProps, optionsWithContext);
        return false;
    }
    catch (errors) {
        console.groupCollapsed("%c " + warningGroup, validationStyle.warningStyle);
        var allErrors_2 = {};
        errors.inner.map(function (error) {
            allErrors_2[error.path] = error.message;
            console.warn("%c " + error.path + ": " + error.message, validationStyle.warningStyle);
        });
        return true;
    }
}
var validateAccessibilityProps = function (chartName, accessibilityObject, otherProps) {
    if (accessibilityObject === void 0) { accessibilityObject = {}; }
    if (otherProps === void 0) { otherProps = { context: {}, data: {}, uniqueID: '', annotations: [], misc: {} }; }
    var context = otherProps.context, annotations = otherProps.annotations, data = otherProps.data, uniqueID = otherProps.uniqueID, misc = otherProps.misc;
    var optionsWithContext = {
        context: context,
        abortEarly: false
    };
    var accessibilityProps = __assign(__assign(__assign({}, accessibilityObject), { annotations: annotations, data: data, uniqueID: uniqueID }), misc);
    yup.addMethod(yup.string, 'validateBySchemaRefAndCondition', validateBySchemaRefAndCondition);
    yup.addMethod(yup.string, 'validateBySchema', validateBySchema);
    yup.addMethod(yup.bool, 'validateBySchemaRefs', validateBySchemaRefs);
    yup.addMethod(yup.string, 'validateBySchemaRef', validateBySchemaRef);
    yup.addMethod(yup.bool, 'validateBySchemaRefBoolean', validateBySchemaRefBoolean);
    var isAnyWarnings = validateWarnings(chartName, accessibilityProps, optionsWithContext);
    validateRecommendations(chartName, accessibilityProps, optionsWithContext, isAnyWarnings);
};

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
// import { darkerColor } from './colors';
var accessibility = {
    longDescription: '',
    executiveSummary: '',
    purpose: '',
    contextExplanation: '',
    title: '',
    elementDescriptionAccessor: '',
    statisticalNotes: '',
    structureNotes: '',
    includeDataKeyNames: false,
    hideDataTableButton: false,
    disableValidation: false,
    elementsAreInterface: null,
    hideTextures: false,
    hideStrokes: false,
    showSmallLabels: false,
    showExperimentalTextures: false,
    keyboardNavConfig: {
        disabled: false
    }
};
var highestHeadingLevel = 'h2';
var sortOrder = '';
var sortOrderAsc = 'asc';
var sortOrderDesc = 'desc';
var layout = 'vertical';
var xAxis = {
    visible: true,
    gridVisible: true,
    label: 'X Axis',
    format: '0[.][0][0]a',
    tickInterval: 1
};
var xAxisDate = {
    visible: true,
    gridVisible: false,
    label: 'X Axis',
    unit: 'month',
    format: '%b %y',
    tickInterval: 1
};
var yAxis = {
    visible: true,
    gridVisible: true,
    label: 'Y Axis',
    format: '0[.][0][0]a',
    tickInterval: 1
};
var wrapLabel = true;
var colorPaletteSingle = 'single_blue';
var colorPaletteSequential = 'sequential_suppPurple';
var colorPaletteSequentialGrey = 'sequential_grey';
var colorPaletteDiverging = 'diverging_RtoB';
var colorPaletteCategorical = 'categorical';
var colorSteps4 = 4;
var colorSteps5 = 5;
var hoverStyle = {
    color: '',
    strokeWidth: 2
};
var clickStyle = {
    color: '',
    strokeWidth: 2
};
var symbolHoverStyle = {
    color: '',
    strokeWidth: 2
};
var symbolClickStyle = {
    color: '',
    strokeWidth: 3
};
var referenceStyle = {
    color: 'pri_grey',
    strokeWidth: '1px',
    opacity: 1,
    dashed: ''
};
var seriesLabel = {
    visible: true,
    placement: 'right',
    label: []
};
var cursor = 'default';
var hoverOpacity = 1;
var strokeWidth1 = 1;
var strokeWidth2 = 2;
var roundedCorner = 0;
var barIntervalRatio = 0.2;
var dotRadius6 = 6;
var dotRadius5 = 5;
var dotRadius4 = 4;
var dotOpacity = 1;
var dotSymbols = ['circle'];
var showDots = true;
var showFitLine = false;
var showBaselineTrue = true;
var showBaselineFalse = false;
var secondaryLines = {
    keys: [],
    showDataLabel: true,
    showSeriesLabel: true,
    opacity: 1
};
var hiddenDataLabel = {
    visible: false,
    labelAccessor: '',
    format: ''
};
var dataLabel = {
    visible: true,
    placement: 'top',
    labelAccessor: '',
    format: '0[.][0][0]a'
};
var dataLabelOutside = {
    visible: true,
    placement: 'outside',
    labelAccessor: '',
    format: '0[.][0][0]a'
};
var dataLabelMiddle = {
    visible: true,
    placement: 'middle',
    labelAccessor: '',
    format: '0[.][0][0]a'
};
var dataLabelEnds = {
    visible: true,
    placement: 'ends',
    labelAccessor: '',
    format: '0[.][0][0]a'
};
var dataLabelBottomRight = {
    visible: true,
    placement: 'bottom-right',
    labelAccessor: 'value',
    format: '0[.][0][0]a'
};
var dataLabelNormalizedOut = {
    visible: true,
    placement: 'outside',
    labelAccessor: '',
    format: 'normalized'
};
var tooltipLabel = {
    labelAccessor: [],
    labelTitle: [],
    format: ''
};
var legend = {
    visible: true,
    interactive: false,
    format: '0[.][0][0]a',
    labels: ''
};
var categoryLegend = {
    visible: true,
    interactive: false,
    format: '',
    labels: ''
};
var keyLegend = {
    visible: true,
    interactive: false,
    type: 'key',
    format: '0[.][0][0]a',
    labels: ''
};
var hiddenLegend = {
    visible: false,
    interactive: false,
    labels: ''
};
var showTooltip = true;
var suppressEvents = false;
var referenceLines = [];
var annotations = [];
var clickHighlight = [];

var propDefaultValues = /*#__PURE__*/Object.freeze({
    __proto__: null,
    accessibility: accessibility,
    highestHeadingLevel: highestHeadingLevel,
    sortOrder: sortOrder,
    sortOrderAsc: sortOrderAsc,
    sortOrderDesc: sortOrderDesc,
    layout: layout,
    xAxis: xAxis,
    xAxisDate: xAxisDate,
    yAxis: yAxis,
    wrapLabel: wrapLabel,
    colorPaletteSingle: colorPaletteSingle,
    colorPaletteSequential: colorPaletteSequential,
    colorPaletteSequentialGrey: colorPaletteSequentialGrey,
    colorPaletteDiverging: colorPaletteDiverging,
    colorPaletteCategorical: colorPaletteCategorical,
    colorSteps4: colorSteps4,
    colorSteps5: colorSteps5,
    hoverStyle: hoverStyle,
    clickStyle: clickStyle,
    symbolHoverStyle: symbolHoverStyle,
    symbolClickStyle: symbolClickStyle,
    referenceStyle: referenceStyle,
    seriesLabel: seriesLabel,
    cursor: cursor,
    hoverOpacity: hoverOpacity,
    strokeWidth1: strokeWidth1,
    strokeWidth2: strokeWidth2,
    roundedCorner: roundedCorner,
    barIntervalRatio: barIntervalRatio,
    dotRadius6: dotRadius6,
    dotRadius5: dotRadius5,
    dotRadius4: dotRadius4,
    dotOpacity: dotOpacity,
    dotSymbols: dotSymbols,
    showDots: showDots,
    showFitLine: showFitLine,
    showBaselineTrue: showBaselineTrue,
    showBaselineFalse: showBaselineFalse,
    secondaryLines: secondaryLines,
    hiddenDataLabel: hiddenDataLabel,
    dataLabel: dataLabel,
    dataLabelOutside: dataLabelOutside,
    dataLabelMiddle: dataLabelMiddle,
    dataLabelEnds: dataLabelEnds,
    dataLabelBottomRight: dataLabelBottomRight,
    dataLabelNormalizedOut: dataLabelNormalizedOut,
    tooltipLabel: tooltipLabel,
    legend: legend,
    categoryLegend: categoryLegend,
    keyLegend: keyLegend,
    hiddenLegend: hiddenLegend,
    showTooltip: showTooltip,
    suppressEvents: suppressEvents,
    referenceLines: referenceLines,
    annotations: annotations,
    clickHighlight: clickHighlight
});

/**
 * Copyright (c) 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
function targetDepth(d) {
    return d.target.depth;
}
function sankeyLeft(node) {
    return node.depth;
}
function sankeyRight(node, n) {
    return n - 1 - node.height;
}
function sankeyJustify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
}
function sankeyCenter(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? d3Array.min(node.sourceLinks, targetDepth) - 1 : 0;
}
function constant$e(x) {
    return function () {
        return x;
    };
}
function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
    return a.y0 - b.y0;
}
function value(d) {
    return d.value;
}
function defaultId$1(d, _i, _nodes) {
    return d.index;
}
function defaultNodes(graph) {
    return graph.nodes;
}
function defaultLinks(graph) {
    return graph.links;
}
function find$1(nodeById, id) {
    var node = nodeById.get(id);
    if (!node)
        throw new Error('missing: ' + id);
    return node;
}
function computeLinkBreadths(_a) {
    var nodes = _a.nodes;
    for (var _b = 0, nodes_1 = nodes; _b < nodes_1.length; _b++) {
        var node = nodes_1[_b];
        var y0 = node.y0;
        var y1 = y0;
        for (var _c = 0, _d = node.sourceLinks; _c < _d.length; _c++) {
            var link = _d[_c];
            link.y0 = y0 + link.width / 2;
            y0 += link.width;
        }
        for (var _e = 0, _f = node.targetLinks; _e < _f.length; _e++) {
            var link = _f[_e];
            link.y1 = y1 + link.width / 2;
            y1 += link.width;
        }
    }
}
// The 'compareNodes' argument here was to the original d3-sankey script in order to allow us to bottom align nodes in VCC's alluvial-diagram
function Sankey(compareNodes, showLinks) {
    var x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent
    var dx = 24; // nodeWidth
    var dy = 8, py; // nodePadding
    var id = defaultId$1;
    var align = sankeyJustify;
    var sort;
    var linkSort;
    var nodes = defaultNodes;
    var links = defaultLinks;
    var iterations = 6;
    function sankey() {
        var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
        computeNodeLinks(graph);
        computeNodeValues(graph);
        computeNodeDepths(graph);
        computeNodeHeights(graph);
        computeNodeBreadths(graph);
        computeLinkBreadths(graph);
        return graph;
    }
    sankey.update = function (graph) {
        computeLinkBreadths(graph);
        return graph;
    };
    sankey.nodeId = function (_) {
        return arguments.length ? ((id = typeof _ === 'function' ? _ : constant$e(_)), sankey) : id;
    };
    sankey.nodeAlign = function (_) {
        return arguments.length ? ((align = typeof _ === 'function' ? _ : constant$e(_)), sankey) : align;
    };
    sankey.nodeSort = function (_) {
        return arguments.length ? ((sort = _), sankey) : sort;
    };
    sankey.nodeWidth = function (_) {
        return arguments.length ? ((dx = +_), sankey) : dx;
    };
    sankey.nodePadding = function (_) {
        return arguments.length ? ((dy = py = +_), sankey) : dy;
    };
    sankey.nodes = function (_) {
        return arguments.length ? ((nodes = typeof _ === 'function' ? _ : constant$e(_)), sankey) : nodes;
    };
    sankey.links = function (_) {
        return arguments.length ? ((links = typeof _ === 'function' ? _ : constant$e(_)), sankey) : links;
    };
    sankey.linkSort = function (_) {
        return arguments.length ? ((linkSort = _), sankey) : linkSort;
    };
    sankey.size = function (_) {
        return arguments.length ? ((x0 = y0 = 0), (x1 = +_[0]), (y1 = +_[1]), sankey) : [x1 - x0, y1 - y0];
    };
    sankey.extent = function (_) {
        return arguments.length
            ? ((x0 = +_[0][0]), (x1 = +_[1][0]), (y0 = +_[0][1]), (y1 = +_[1][1]), sankey)
            : [[x0, y0], [x1, y1]];
    };
    sankey.iterations = function (_) {
        return arguments.length ? ((iterations = +_), sankey) : iterations;
    };
    // VCC had to transform for .. of with object.entries to forEach for es5 support
    function computeNodeLinks(_a) {
        var nodes = _a.nodes, links = _a.links;
        nodes.forEach(function (node, i) {
            node.index = i;
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        var nodeById = new Map(nodes.map(function (d, i) { return [id(d, i, nodes), d]; }));
        links.forEach(function (link, i) {
            link.index = i;
            var source = link.source, target = link.target;
            if (typeof source !== 'object')
                source = link.source = find$1(nodeById, source);
            if (typeof target !== 'object')
                target = link.target = find$1(nodeById, target);
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
        if (linkSort != null) {
            for (var _b = 0, nodes_2 = nodes; _b < nodes_2.length; _b++) {
                var _c = nodes_2[_b], sourceLinks = _c.sourceLinks, targetLinks = _c.targetLinks;
                sourceLinks.sort(linkSort);
                targetLinks.sort(linkSort);
            }
        }
    }
    function computeNodeValues(_a) {
        var nodes = _a.nodes;
        for (var _b = 0, nodes_3 = nodes; _b < nodes_3.length; _b++) {
            var node = nodes_3[_b];
            node.value =
                node.fixedValue === undefined
                    ? Math.max(d3Array.sum(node.sourceLinks, value), d3Array.sum(node.targetLinks, value))
                    : node.fixedValue;
        }
    }
    // VCC had to transform for .. of with Set() to forEach for es5 support
    function computeNodeDepths(_a) {
        var nodes = _a.nodes;
        var n = nodes.length;
        var current = new Set(nodes);
        var next = new Set();
        var x = 0;
        while (current.size) {
            current.forEach(function (node) {
                node.depth = x;
                for (var _a = 0, _b = node.sourceLinks; _a < _b.length; _a++) {
                    var target = _b[_a].target;
                    next.add(target);
                }
            });
            if (++x > n)
                throw new Error('circular link');
            current = next;
            next = new Set();
        }
    }
    // VCC had to transform for .. of with Set() to forEach for es5 support
    function computeNodeHeights(_a) {
        var nodes = _a.nodes;
        var n = nodes.length;
        var current = new Set(nodes);
        var next = new Set();
        var x = 0;
        while (current.size) {
            current.forEach(function (node) {
                node.height = x;
                for (var _a = 0, _b = node.targetLinks; _a < _b.length; _a++) {
                    var source = _b[_a].source;
                    next.add(source);
                }
            });
            if (++x > n)
                throw new Error('circular link');
            current = next;
            next = new Set();
        }
    }
    // added in order to compute x position when links are hidden
    function computeNodeLayersWhenLinksHidden(_a) {
        var nodes = _a.nodes;
        var x = d3Array.max(nodes, function (d) { return d.depth; });
        var allNodeWidths = x * (2 * dx);
        var leftPadding = (x1 - allNodeWidths) / 2;
        var columns = new Array(x + 1);
        for (var _b = 0, nodes_4 = nodes; _b < nodes_4.length; _b++) {
            var node = nodes_4[_b];
            var i = Math.max(0, Math.min(x, Math.floor(align.call(null, node, x + 1))));
            node.layer = i;
            node.x0 = leftPadding + node.depth * (2 * dx);
            node.x1 = node.x0 + dx;
            if (columns[i])
                columns[i].push(node);
            else
                columns[i] = [node];
        }
        if (sort)
            for (var _c = 0, columns_1 = columns; _c < columns_1.length; _c++) {
                var column = columns_1[_c];
                column.sort(sort);
            }
        return columns;
    }
    function computeNodeLayers(_a) {
        var nodes = _a.nodes;
        var x = d3Array.max(nodes, function (d) { return d.depth; }) + 1;
        var kx = (x1 - x0 - dx) / (x - 1);
        var columns = new Array(x);
        for (var _b = 0, nodes_5 = nodes; _b < nodes_5.length; _b++) {
            var node = nodes_5[_b];
            var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
            node.layer = i;
            node.x0 = x0 + i * kx;
            node.x1 = node.x0 + dx;
            if (columns[i])
                columns[i].push(node);
            else
                columns[i] = [node];
        }
        if (sort)
            for (var _c = 0, columns_2 = columns; _c < columns_2.length; _c++) {
                var column = columns_2[_c];
                column.sort(sort);
            }
        return columns;
    }
    // This function was added to the original d3-sankey script in order to allow us to bottom align nodes in VCC's alluvial-diagram
    function setBottomAlignedNodes(columns) {
        var nodeCount = d3Array.max(columns, function (c) { return c.length; });
        var maxValues = [];
        for (var i = 0; i < nodeCount; ++i) {
            var max_1 = 0;
            for (var j = 0; j < columns.length; ++j) {
                if (columns[j][i] && columns[j][i].value && columns[j][i].value > max_1) {
                    max_1 = columns[j][i].value;
                }
            }
            maxValues[i] = max_1;
        }
        var ky = (y1 - y0 - (nodeCount - 1) * py) / d3Array.sum(maxValues);
        for (var _a = 0, columns_3 = columns; _a < columns_3.length; _a++) {
            var nodes_6 = columns_3[_a];
            var y = y0;
            for (var i = 0; i < nodes_6.length; ++i) {
                nodes_6[i].y1 = y + maxValues[i] * ky;
                nodes_6[i].y0 = nodes_6[i].y1 - nodes_6[i].value * ky;
                y = nodes_6[i].y1 + py;
                for (var _b = 0, _c = nodes_6[i].sourceLinks; _b < _c.length; _b++) {
                    var link = _c[_b];
                    link.width = link.value * ky;
                }
            }
        }
    }
    function initializeNodeBreadths(columns) {
        var ky = d3Array.min(columns, function (c) { return (y1 - y0 - (c.length - 1) * py) / d3Array.sum(c, value); });
        for (var _a = 0, columns_4 = columns; _a < columns_4.length; _a++) {
            var nodes_8 = columns_4[_a];
            var y = y0;
            for (var _b = 0, nodes_7 = nodes_8; _b < nodes_7.length; _b++) {
                var node = nodes_7[_b];
                node.y0 = y;
                node.y1 = y + node.value * ky;
                y = node.y1 + py;
                for (var _c = 0, _d = node.sourceLinks; _c < _d.length; _c++) {
                    var link = _d[_c];
                    link.width = link.value * ky;
                }
            }
            y = (y1 - y + py) / (nodes_8.length + 1);
            for (var i = 0; i < nodes_8.length; ++i) {
                var node = nodes_8[i];
                node.y0 += y * (i + 1);
                node.y1 += y * (i + 1);
            }
            reorderLinks(nodes_8);
        }
    }
    function computeNodeBreadths(graph) {
        var columns = !showLinks ? computeNodeLayersWhenLinksHidden(graph) : computeNodeLayers(graph);
        py = Math.min(dy, (y1 - y0) / (d3Array.max(columns, function (c) { return c.length; }) - 1));
        // This operation was added to the original d3-sankey script to allow us to call a function that bottom aligns nodes in VCC's alluvial-diagram
        compareNodes ? setBottomAlignedNodes(columns) : initializeNodeBreadths(columns);
        for (var i = 0; i < iterations; ++i) {
            var alpha = Math.pow(0.99, i);
            var beta = Math.max(1 - alpha, (i + 1) / iterations);
            // This prop and operation was to the original d3-sankey script to allow us to bottom align nodes in VCC's alluvial-diagram
            if (!compareNodes) {
                relaxRightToLeft(columns, alpha, beta);
                relaxLeftToRight(columns, alpha, beta);
            }
        }
    }
    // Reposition each node based on its incoming (target) links.
    function relaxLeftToRight(columns, alpha, beta) {
        for (var i = 1, n = columns.length; i < n; ++i) {
            var column = columns[i];
            for (var _a = 0, column_1 = column; _a < column_1.length; _a++) {
                var target = column_1[_a];
                var y = 0;
                var w = 0;
                for (var _b = 0, _c = target.targetLinks; _b < _c.length; _b++) {
                    var _d = _c[_b], source = _d.source, value_1 = _d.value;
                    var v = value_1 * (target.layer - source.layer);
                    y += targetTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0))
                    continue;
                var dy_1 = (y / w - target.y0) * alpha;
                target.y0 += dy_1;
                target.y1 += dy_1;
                reorderNodeLinks(target);
            }
            if (sort === undefined)
                column.sort(ascendingBreadth);
            resolveCollisions(column, beta);
        }
    }
    // Reposition each node based on its outgoing (source) links.
    function relaxRightToLeft(columns, alpha, beta) {
        for (var n = columns.length, i = n - 2; i >= 0; --i) {
            var column = columns[i];
            for (var _a = 0, column_2 = column; _a < column_2.length; _a++) {
                var source = column_2[_a];
                var y = 0;
                var w = 0;
                for (var _b = 0, _c = source.sourceLinks; _b < _c.length; _b++) {
                    var _d = _c[_b], target = _d.target, value_2 = _d.value;
                    var v = value_2 * (target.layer - source.layer);
                    y += sourceTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0))
                    continue;
                var dy_2 = (y / w - source.y0) * alpha;
                source.y0 += dy_2;
                source.y1 += dy_2;
                reorderNodeLinks(source);
            }
            if (sort === undefined)
                column.sort(ascendingBreadth);
            resolveCollisions(column, beta);
        }
    }
    function resolveCollisions(nodes, alpha) {
        var i = nodes.length >> 1;
        var subject = nodes[i];
        resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
        resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
        resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
        resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
    }
    // Push any overlapping nodes down.
    function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
        for (; i < nodes.length; ++i) {
            var node = nodes[i];
            var dy_3 = (y - node.y0) * alpha;
            if (dy_3 > 1e-6)
                (node.y0 += dy_3), (node.y1 += dy_3);
            y = node.y1 + py;
        }
    }
    // Push any overlapping nodes up.
    function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
        for (; i >= 0; --i) {
            var node = nodes[i];
            var dy_4 = (node.y1 - y) * alpha;
            if (dy_4 > 1e-6)
                (node.y0 -= dy_4), (node.y1 -= dy_4);
            y = node.y0 - py;
        }
    }
    function reorderNodeLinks(_a) {
        var sourceLinks = _a.sourceLinks, targetLinks = _a.targetLinks;
        if (linkSort === undefined) {
            for (var _b = 0, targetLinks_1 = targetLinks; _b < targetLinks_1.length; _b++) {
                var sourceLinks_2 = targetLinks_1[_b].source.sourceLinks;
                sourceLinks_2.sort(ascendingTargetBreadth);
            }
            for (var _c = 0, sourceLinks_1 = sourceLinks; _c < sourceLinks_1.length; _c++) {
                var targetLinks_2 = sourceLinks_1[_c].target.targetLinks;
                targetLinks_2.sort(ascendingSourceBreadth);
            }
        }
    }
    function reorderLinks(nodes) {
        if (linkSort === undefined) {
            for (var _a = 0, nodes_9 = nodes; _a < nodes_9.length; _a++) {
                var _b = nodes_9[_a], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
                sourceLinks.sort(ascendingTargetBreadth);
                targetLinks.sort(ascendingSourceBreadth);
            }
        }
    }
    // Returns the target.y0 that would produce an ideal link from source to target.
    function targetTop(source, target) {
        var y = source.y0 - ((source.sourceLinks.length - 1) * py) / 2;
        for (var _a = 0, _b = source.sourceLinks; _a < _b.length; _a++) {
            var _c = _b[_a], node = _c.target, width = _c.width;
            if (node === target)
                break;
            y += width + py;
        }
        for (var _d = 0, _e = target.targetLinks; _d < _e.length; _d++) {
            var _f = _e[_d], node = _f.source, width = _f.width;
            if (node === source)
                break;
            y -= width;
        }
        return y;
    }
    // Returns the source.y0 that would produce an ideal link from source to target.
    function sourceTop(source, target) {
        var y = target.y0 - ((target.targetLinks.length - 1) * py) / 2;
        for (var _a = 0, _b = target.targetLinks; _a < _b.length; _a++) {
            var _c = _b[_a], node = _c.source, width = _c.width;
            if (node === source)
                break;
            y += width + py;
        }
        for (var _d = 0, _e = source.sourceLinks; _d < _e.length; _d++) {
            var _f = _e[_d], node = _f.target, width = _f.width;
            if (node === target)
                break;
            y -= width;
        }
        return y;
    }
    return sankey;
}
function horizontalSource(d) {
    return [d.source.x1, d.y0];
}
function horizontalTarget(d) {
    return [d.target.x0, d.y1];
}
function sankeyLinkHorizontal() {
    return d3Shape.linkHorizontal()
        .source(horizontalSource)
        .target(horizontalTarget);
}

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
// incorporate OSS licenses into build
window['VisaChartsLibOSSLicenses'] = getLicenses(); // tslint:disable-line no-string-literal

var Utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    autoTextColor: autoTextColor,
    buildStrokes: buildStrokes,
    checkAttributeTransitions: checkAttributeTransitions,
    createTextStrokeFilter: createTextStrokeFilter,
    getBrowser: getBrowser,
    getOS: getOS,
    findTagLevel: findTagLevel,
    createUrl: createUrl,
    createMultiStrokeFilter: createMultiStrokeFilter,
    removeFilters: removeFilters,
    drawHoverStrokes: drawHoverStrokes,
    removeHoverStrokes: removeHoverStrokes,
    mirrorStrokeTransition: mirrorStrokeTransition,
    initializeElementAccess: initializeElementAccess,
    initializeDescriptionRoot: initializeDescriptionRoot,
    setElementFocusHandler: setElementFocusHandler,
    setElementAccessID: setElementAccessID,
    setTooltipAccess: setTooltipAccess,
    setLegendAccess: setLegendAccess,
    setHighContrastListener: setHighContrastListener,
    createLabel: createLabel,
    createGroupLabel: createGroupLabel,
    setAccessibilityController: setAccessibilityController,
    hideNonessentialGroups: hideNonessentialGroups,
    hideNode: hideNode,
    setAccessTitle: setAccessTitle,
    setAccessSubtitle: setAccessSubtitle,
    setAccessLongDescription: setAccessLongDescription,
    setAccessExecutiveSummary: setAccessExecutiveSummary,
    setAccessPurpose: setAccessPurpose,
    setAccessContext: setAccessContext,
    setAccessStatistics: setAccessStatistics,
    setAccessChartCounts: setAccessChartCounts,
    setAccessXAxis: setAccessXAxis,
    setAccessYAxis: setAccessYAxis,
    setAccessStructure: setAccessStructure,
    setAccessAnnotation: setAccessAnnotation,
    retainAccessFocus: retainAccessFocus,
    checkAccessFocus: checkAccessFocus,
    setElementInteractionAccessState: setElementInteractionAccessState,
    setAccessibilityDescriptionWidth: setAccessibilityDescriptionWidth,
    annotate: annotate,
    getTexture: getTexture,
    convertColorsToTextures: convertColorsToTextures,
    prepareStrokeColorsFromScheme: prepareStrokeColorsFromScheme,
    calculateLuminance: calculateLuminance,
    calculateRelativeLuminance: calculateRelativeLuminance,
    getAccessibleStrokes: getAccessibleStrokes,
    getRecursiveStroke: getRecursiveStroke,
    getContrastingStroke: getContrastingStroke,
    ensureTextContrast: ensureTextContrast,
    convertVisaColor: convertVisaColor,
    circularFind: circularFind,
    capitalized: capitalized,
    chartAccessors: chartAccessors,
    checkInteraction: checkInteraction,
    checkClicked: checkClicked,
    checkHovered: checkHovered,
    drawAxis: drawAxis,
    wrap: wrap,
    drawGrid: drawGrid,
    drawLegend: drawLegend,
    setLegendInteractionState: setLegendInteractionState,
    drawTooltip: drawTooltip,
    darkerColor: darkerColor,
    equalizePath: equalizePath,
    formatDataLabel: formatDataLabel,
    formatStats: formatStats,
    formatDate: formatDate,
    getColors: getColors,
    getLicenses: getLicenses,
    generalizePath: generalizePath,
    getDataSymbol: getDataSymbol,
    getScopedData: getScopedData,
    getTextWidth: getTextWidth,
    verifyTextHasSpace: verifyTextHasSpace,
    manuallyWrapText: manuallyWrapText,
    getPadding: getPadding,
    interactionStyle: interactionStyle,
    initTooltipStyle: initTooltipStyle,
    leastSquares: leastSquares,
    moveToFront: moveToFront,
    mapButtons: mapButtons,
    orderScopedData: orderScopedData,
    outlineColor: outlineColor,
    overrideTitleTooltip: overrideTitleTooltip,
    placeDataLabels: placeDataLabels,
    propDefaultValues: propDefaultValues,
    resolveLines: resolveLines,
    roundTo: roundTo,
    symbols: symbols,
    sankey: Sankey,
    sankeyCenter: sankeyCenter,
    sankeyJustify: sankeyJustify,
    sankeyLeft: sankeyLeft,
    sankeyLinkHorizontal: sankeyLinkHorizontal,
    sankeyRight: sankeyRight,
    transitionEndAll: transitionEndAll,
    transformData: transformData,
    scopeDataKeys: scopeDataKeys,
    visaColors: visaColors,
    validateAccessibilityProps: validateAccessibilityProps,
    fixNestedSparseness: fixNestedSparseness
});

var index$4 = __assign({}, Utils);

module.exports = index$4;
